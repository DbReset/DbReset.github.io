<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一点唠叨</title>
    <url>/2021/06/30/%E7%BD%AE%E9%A1%B6%E5%94%A0%E5%8F%A8/</url>
    <content><![CDATA[<p>&ensp;&ensp;一直认为自己是个很话痨的人，以前自己的微博也都很啰嗦，洋洋洒洒好几千条，现在想起来回头看，正经自己发的微博已经是18年的事情了，是什么消减了我的网络表达欲呢？<br></p>
<span id="more"></span>
<p>&ensp;&ensp;我想大概是不存粹了把，网络上的语言垃圾越来越多，有各种各样的搬运机器人，僵尸粉们保活发的垃圾话。后来又热衷于微信的唠叨，现在也大抵是被广告和琐碎淹没了把。也许这也是一种循环吧，从最初的有效表达，到后来被淹没，当然可能也和年龄有关吧。照这么想，一个我理想中社交软件应该是什么样的呢？ 一、要够简单明了的输出观点，情感。简单简单简单。二、要能吸引年轻人的观点输出，大抵就是18-25岁区间。如果在一个表达欲这么强的年纪都没兴趣上去骂两句，基本也就拜拜了。 三、最好有一定的准入门槛，起码只要话痨（笑 四、保持以上三点，保持以上三点，保持以上三点。<br><br>&ensp;&ensp;越活越俗，越活越无趣。以前梦想用热情影响世界，改变世界，现在也唯有用手熟的技能换碎银了。<br><br>&ensp;&ensp;没地输出了，在这记录点唯手熟尔的相关技能，也许以后再把热情和冲动燃一把，烧了自己，照亮我自己。<br><br>&ensp;&ensp;大致的拼凑，日常的笔记，绝对不是日记，正经人谁写日记。<br><br>&ensp;&ensp;不正经了再来更两篇随笔。</p>
]]></content>
  </entry>
  <entry>
    <title>高项——信息化与信息系统</title>
    <url>/2024/03/20/%E8%BD%AF%E8%80%83/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9_%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="信息的传输模型"><a href="#信息的传输模型" class="headerlink" title="信息的传输模型"></a>信息的传输模型</h2><p><strong>①物理层</strong>：该层包括物理连网媒介，如电缆连线连接器。该层的协议产生并检测电压以 便发送和接收携带数据的信号。有<strong>RS232、V. 35、RJ-45、FDDI</strong>。</p>
<p><strong>②数据链路层</strong>：它控制网络层与物理层之间的通信。它的主要功能是将从网络层接收到 的数据分割成特定的可被物理层传输的帧。协议有<strong>IEEE802.3/.2、HDLC、PPP、ATM</strong>。</p>
<p><strong>③网络层</strong>：其主要功能是将网络地址（例如，IP地址）翻译成对应的物理地址（例如， 网卡地址），并决定如何将数据从发送方路由到接收方。有<strong>IP、ICMP、IGMP、IPX、 ARP</strong>等。</p>
<p><strong>④传输层</strong>：主要负责确保数据可靠、顺序、无错地从A点传输到B点。如提供建立、维 护和拆除传送连接的功能；选择网络层提供最合适的服务；在系统之间提供可靠的透明 的数据传送，提供端到端的错误恢复和流量控制。有<strong>TCP、UDP、SPX</strong>。</p>
<p><strong>⑤会话层</strong>：负责在网络中的两节点之间建立和维持通信，以及提供交互会话的管理功能， 如三种数据流方向的控制，即一路交互、两路交替和两路同时会话模式。有<strong>RPC、SQL、 NFS</strong>。</p>
<p><strong>⑥表示层</strong>：如同应用程序和网络之间的翻译官，数据将按照网络能理解的方案进行格式 化；管理数据的解密加密、数据转换、格式化和文本压缩。有<strong>JPEG、ASCII、GIf、DES、 MPEG</strong>。</p>
<p><strong>⑦应用层</strong>：负责对软件提供接口以使程序能使用网络服务，如事务处理程序、文件传送 协议和网络管理等。有<strong>HTTP、Telnet、FTP、SMTP</strong>。</p>
<h2 id="信息化5个层次"><a href="#信息化5个层次" class="headerlink" title="信息化5个层次"></a>信息化5个层次</h2><ol>
<li>产品信息化      – 智能电视、智能灯具</li>
<li>企业信息化  – 生产制造系统、ERP、CRM、SCM</li>
<li>产业信息化  –农业、工业、交通运输业、生产制造业、服务业等传统行业</li>
<li>国民经济信息化   –金融、贸易、投资、计划、通关、营销等组成一个信息大系统</li>
<li>社会生活信息化  – 智慧城市、互联网金融</li>
</ol>
<h2 id="信息化的主体手段途径目标"><a href="#信息化的主体手段途径目标" class="headerlink" title="信息化的主体手段途径目标"></a>信息化的主体手段途径目标</h2><p><strong>主体：全体社会成员，包括政府、企业、事业、团体和个人</strong></p>
<p>时域：一个长期的过程</p>
<p>空域：是政治、经济、文化、军事和社会的一切领域</p>
<p>手段：是基于现代信息技术的先进生产工具</p>
<p>途径：是创建信息时代的社会生产力，推动社会生产关系以及社会上层建筑的改革</p>
<p>目标：是使国家的综合实力、社会的文明素质和人民的生活质量全面提升</p>
<h2 id="信息化6要素及其地位"><a href="#信息化6要素及其地位" class="headerlink" title="信息化6要素及其地位"></a>信息化6要素及其地位</h2><p><img src="/2024/03/20/%E8%BD%AF%E8%80%83/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9_%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E6%81%AF%E5%8C%966%E8%A6%81%E7%B4%A0.png" alt="信息化6要素"></p>
<span id="more"></span>

<h2 id="信息系统生命周期5个阶段及其内容"><a href="#信息系统生命周期5个阶段及其内容" class="headerlink" title="信息系统生命周期5个阶段及其内容"></a>信息系统生命周期5个阶段及其内容</h2><p>①系统<strong>规划</strong>阶段：对组织的环境、目标及现行系统的状况进行初步调查，根据 组织目标和发展战略，确定信息系统的发展战略，对建设新系统的需求做出分 析和预测，研究建设新系统的必要性和可能性。给出拟建系统的备选方案，写 出<strong>可行性研究报告</strong>。</p>
<p>②系统<strong>分析</strong>阶段：根据系统设计任务书所确定的范围，对现行系统进行详细调 查，描述现行系统的业务流程，指出现行系统的局限性和不足之处，确定新系 统的基本目标和逻辑功能要求，即<strong>提出新系统的逻辑模型</strong>。（做什么）</p>
<p>③系统<strong>设计</strong>阶段：根据系统说明书中规定的功能要求，考虑实际条件，具体设 计实现逻辑模型的技术方案，也就是<strong>设计新系统的物理模型</strong>。又称为物理设计 阶段，可分为<strong>总体设计（概要设计）和详细设计</strong>两个子阶段。技术文档是系统 设计说明书。（怎么做）</p>
<p>④系统<strong>实施</strong>阶段：将<strong>设计的系统付诸实施</strong>的阶段。任务包括计算机等设备的购 置、安装和调试、程序的编写和调试、人员培训、数据文件转换、系统调试与 转换等。这个阶段的特点是几个互相联系、互相制约的任务同时展开，必须精 心安排、合理组织。系统实施是按实施计划分阶段完成的，每个阶段应<strong>写出实 施进展报告</strong>。系统测试之后写出系统测试分析报告。</p>
<p>⑤系统<strong>运行和维护</strong>阶段：系统投入运行后，需要经常进行<strong>维护和评价</strong>，记录系 统运行的情况，根据一定的规则对系统进行必要的修改，评价系统的工作质量 和经济效益。</p>
<h2 id="信息系统开发方法：结构化、面向对象、原型法、面向服务的方法特征及-优缺点"><a href="#信息系统开发方法：结构化、面向对象、原型法、面向服务的方法特征及-优缺点" class="headerlink" title="信息系统开发方法：结构化、面向对象、原型法、面向服务的方法特征及 优缺点"></a>信息系统开发方法：结构化、面向对象、原型法、面向服务的方法特征及 优缺点</h2><p>结构化和面向对象</p>
<p><img src="/2024/03/20/%E8%BD%AF%E8%80%83/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9_%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/%E7%BB%93%E6%9E%84%E5%8C%96%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.png" alt="结构化和面向对象"></p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI协议7层及其作用协议"><a href="#OSI协议7层及其作用协议" class="headerlink" title="OSI协议7层及其作用协议"></a>OSI协议7层及其作用协议</h3><p><img src="/2024/03/20/%E8%BD%AF%E8%80%83/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9_%E4%BF%A1%E6%81%AF%E5%8C%96%E4%B8%8E%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/osi7.png" alt="osi7"></p>
<h3 id="IEEE802协议"><a href="#IEEE802协议" class="headerlink" title="IEEE802协议"></a>IEEE802协议</h3><p><strong>802.3（以太网的CSMA/CD载波监听多路访问/冲突检测协议）</strong></p>
<p><strong>802.11（无线局域网WLAN标准协议）</strong></p>
<h3 id="TCP-IP-协议4层及其协议作用"><a href="#TCP-IP-协议4层及其协议作用" class="headerlink" title="TCP/IP 协议4层及其协议作用"></a>TCP/IP 协议4层及其协议作用</h3><h3 id="网络交换"><a href="#网络交换" class="headerlink" title="网络交换"></a>网络交换</h3><h3 id="网络设备及其作用"><a href="#网络设备及其作用" class="headerlink" title="网络设备及其作用"></a>网络设备及其作用</h3><h3 id="无线-网络"><a href="#无线-网络" class="headerlink" title="无线 网络"></a>无线 网络</h3><h3 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h3><h3 id="网络接入技术"><a href="#网络接入技术" class="headerlink" title="网络接入技术"></a>网络接入技术</h3><h3 id="网络规划与设计"><a href="#网络规划与设计" class="headerlink" title="网络规划与设计"></a>网络规划与设计</h3><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><h3 id="数据仓库技术"><a href="#数据仓库技术" class="headerlink" title="数据仓库技术"></a>数据仓库技术</h3><h3 id="中间件技术（定义、层次、应-用）"><a href="#中间件技术（定义、层次、应-用）" class="headerlink" title="中间件技术（定义、层次、应 用）"></a>中间件技术（定义、层次、应 用）</h3><h3 id="可用性和可靠性"><a href="#可用性和可靠性" class="headerlink" title="可用性和可靠性"></a>可用性和可靠性</h3>]]></content>
      <categories>
        <category>cs基础</category>
        <category>软考</category>
        <category>信息化与信息系统</category>
      </categories>
      <tags>
        <tag>软考高级</tag>
      </tags>
  </entry>
  <entry>
    <title>高项论文</title>
    <url>/2024/03/20/%E8%BD%AF%E8%80%83/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h2 id="软考高项论文写作历年考题"><a href="#软考高项论文写作历年考题" class="headerlink" title="软考高项论文写作历年考题"></a>软考高项论文写作历年考题</h2><p><img src="/2024/03/20/%E8%BD%AF%E8%80%83/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9%E8%AE%BA%E6%96%87/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9%E5%8E%86%E5%B9%B4%E9%A2%98%E7%9B%AE.png" alt="软考高项历年题目"></p>
<p>主要为：10大领域47个过程</p>
<hr>
<h2 id="八股文论文架构"><a href="#八股文论文架构" class="headerlink" title="八股文论文架构"></a>八股文论文架构</h2><ol>
<li><p>背景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">项目的背景、名称、投资规模、周期、参与方、建设内容、特点（隐含的点 题！）我的角色、团队</span><br><span class="line">建议2段左右完成，字数控制在500 左右为佳，对应子题目1</span><br></pre></td></tr></table></figure></li>
<li><p>过渡段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写150字左右的过渡段，承上启下， 回答部分子题目2、3的要求</span><br></pre></td></tr></table></figure></li>
<li><p>正文实践 部分</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">◼ 过程类论文写法： 按照“xx 管理的过程”顺序写，但一定要注意突出实践！ ！ ！</span><br><span class="line">◼ 控制类论文写法： 一、编制XX管理计划（计划的理论（100 字左右） 、计划的实践（200 字左右）——要有具体的计划！ ） 二、XX计划的监控（控制的理论（100 字左右）、控制的实践（1000 字左右）——写“问题” ：描述 问题、分析问题（分析问题时，要结合前文的计划分析！ ） 、解决问题。</span><br><span class="line"></span><br><span class="line">一般3<span class="string">-7</span>个论点，根据题目的要求来 看，一个论点一般1<span class="string">-2</span>段，整体字数 在1300左右，这是论文的核心内容， 也是大家平时需要积累的东西</span><br></pre></td></tr></table></figure></li>
<li><p>收尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般1段，画龙点睛的作用，总结经 验和教训，表决心，字数一般300字 左右为佳</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="写作要求"><a href="#写作要求" class="headerlink" title="写作要求"></a>写作要求</h2><ul>
<li><p>简要介绍项目的背景、发起单位、目的、开始时间、结束时间、主要交付物、最终交 付产品。着重介绍<strong>论文要求撰写的领域</strong>方面的管理及作者在其中承担的工作和角色。提 出针对撰写领域的论点。—对应于<strong>子题目1</strong></p>
</li>
<li><p>基于上述背景，介绍作者对<strong>该领域</strong>的认识。通常可以按照每个领域的每个过程分别介绍。这里的每个过程可以作为一个段落，注意不要遗漏，每个过程都涵盖。要理论联系实际，对每个过程适当的展开阐述，描述在实际项目中的做法，包括谁来做的，怎么做 的，何时做的等方面。对每个过程要重点说明你的做法以及使用的工具，工具说明1-2 种就行了，要总结每个过程在实际管理中碰到的问题，你的解决办法和心得体会；<strong>注意 要与题目的第二、三小问结合 。—对应于子题目2、3</strong></p>
</li>
<li><p>总结在实际项目中对这一领域管理的体会和心得，包括实际效果和存在的不足和问题，并且分析好的经验如何在以后的项目中推广，不好的原因是什么以及在以后如何改进和提高—收尾</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cs基础</category>
        <category>软考</category>
        <category>论文</category>
      </categories>
      <tags>
        <tag>软考高级</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法比较</title>
    <url>/2024/03/20/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="各排序算法比较"><a href="#各排序算法比较" class="headerlink" title="各排序算法比较"></a>各排序算法比较</h3><table>
<thead>
<tr>
<th>类别</th>
<th>排序方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>复杂性</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>最好-平均-最坏</td>
<td>辅助存储</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>1-1直接插入</td>
<td>O(N)-O(N2)-O(N2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>插入排序</td>
<td>1-2希尔排序</td>
<td>O(N)-O(N1.3)-O(N2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>复杂</td>
</tr>
<tr>
<td>选择排序*</td>
<td>2-1直接选择</td>
<td>O(N)-O(N2)-O(N2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>简单</td>
</tr>
<tr>
<td>选择排序*</td>
<td>2-2堆排序</td>
<td>O(N<em>log2N)-O(N</em>log2N)-O(N*log2N)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>复杂</td>
</tr>
<tr>
<td>交换排序*</td>
<td>3-1冒泡排序</td>
<td>O(N)-O(N2)-O(N2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>交换排序*</td>
<td>3-2快速排序</td>
<td>O(N<em>log2N)-O(N</em>log2N)- O(N2)</td>
<td>O(log2n)~O(n)</td>
<td>不稳定</td>
<td>复杂</td>
</tr>
<tr>
<td>归并排序</td>
<td></td>
<td>O(N<em>log2N)-O(N</em>log2N)-O(N*log2N)</td>
<td>O(1)</td>
<td>稳定</td>
<td>复杂</td>
</tr>
<tr>
<td>基数排序</td>
<td></td>
<td>O(d(r+n))-O(d(r+n))-O(d(r+n))</td>
<td>O(rd+n)</td>
<td>稳定</td>
<td>复杂</td>
</tr>
</tbody></table>
<p>*：（每轮都能确定最终位置）</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>1、冒泡排序是一种用时间换空间的排序方法<br>2、最坏情况是把顺序的排列变成逆序，或者把逆序的数列变成顺序，最差时间复杂度O(N^2)只是表示其操作次数的数量级<br>3、最好的情况是数据本来就有序，复杂度为O(n)</p>
<h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h3><p>1、n大时好，快速排序比较占用内存，内存随n的增大而增大，但却是效率高不稳定的排序算法。<br>2、划分之后一边是一个，一边是n-1个，<br>这种极端情况的时间复杂度就是O(N^2)<br>3、最好的情况是每次都能均匀的划分序列，O(N*log2N)</p>
<h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><p>1、n大时好，归并比较占用内存，内存随n的增大而增大，但却是效率高且稳定的排序算法。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年软件设计师知识点整理</title>
    <url>/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/</url>
    <content><![CDATA[<h1 id="2020年软件设计师知识点"><a href="#2020年软件设计师知识点" class="headerlink" title="2020年软件设计师知识点"></a>2020年软件设计师知识点</h1><hr>
<ol>
<li>高速缓存和主存间的地址映射由<strong>硬件</strong>自动完成。</li>
</ol>
<p>全相联映射-将主存一个块的地址与内容一起存入 cache 中，拷贝灵活但是比较器电路难设计实现；</p>
<p>直接映射-一个主存块只能拷贝到 cache 的特定行上 去，硬件简单成本低但是容易冲突效率下降。</p>
<p>组相联映射-主存块放到哪个组是固定的，但 是放到哪一行是灵活的，折中办法广泛采用。</p>
<ol start="2">
<li></li>
</ol>
<ul>
<li>存储器：内存，外存</li>
<li>运算器：算术逻辑单元ALU，累加寄存器AC，数据缓冲寄存器DR，状态条件寄存器PSW</li>
<li>控制器：指令寄存器IR，程序计数器PC，地址寄存器AR，指令译码器ID</li>
</ul>
<ol start="3">
<li>浮点数相加减</li>
</ol>
<p>运算过程：对阶（<strong>阶码小的向阶码大的对齐</strong> 损失更少精度）、尾数求和（(阶码用双符号位，尾数用单符号位）、规格化、舍入、溢出判断</p>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/2.png" alt="截屏2022-05-05 22.31.15"></p>
<span id="more"></span>

<ol start="4">
<li><p>指令执行速度（<strong>MIPS</strong>）=<strong>主频（MHz）/cpi</strong>  ;CPI=<strong>机器周期*时钟周期</strong>；</p>
</li>
<li><p>中断向量提供中断服务程序入口地址，用来恢复运行。</p>
</li>
<li><p>认证只能阻止<strong>主动攻击（中断，篡改，伪造）</strong>，不能阻止<strong>被动攻击（窃听</strong>）。</p>
</li>
<li><ul>
<li>路由信息<em>协议</em>(<em><strong>RIP</strong></em>) 是一种距离矢量<em>协议</em>，这表示它根据跳数来判断到达目标的最佳路由。</li>
<li><strong>O<em>SPF</em>路由<em>协议</em></strong>是用于网际<em>协议</em>（IP）网络的链路状态路由<em>协议</em>。</li>
<li><em><strong>BGP协议</strong></em>一般指边界网关协议。 边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议。</li>
<li><em>UDP协议</em>一般指UDP。 Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。</li>
</ul>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/%E5%8D%8F%E8%AE%AE.png" alt="image-20220509213944537"></p>
<p><strong>MIME</strong>互联网标准，扩展了电子邮件标准，使其能够支持附件等功能。</p>
<p>S/MIME安全多用途互联网邮件扩展协议</p>
<ol start="8">
<li>常见unix命令</li>
</ol>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/1.png" alt="截屏2022-05-05 23.12.49"></p>
</li>
<li><ul>
<li><p>修改权受到永久保护。作者的署名权、修改权、保护作品完整权的保护期不受限制。</p>
</li>
<li><p>发表权、著作财产权的保护期为作者终生及其死亡后五十年,截止于作者死亡后第五十年的12月31日;如果是合作作品,截止于最后死亡的作者死亡后第五十年的12月31日。</p>
</li>
</ul>
</li>
<li><p>加密算法</p>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.png" alt="截屏2022-05-09 22.52.23"></p>
<p><strong>非对称：EIGamal,背包算法，Rabin(RSA的特例)，ECC（椭圆曲线加密算法）</strong></p>
</li>
<li><p><strong>结构化分析方法</strong>中 ，数据流图中的元素在<strong>数据字典</strong>中进行定义。</p>
</li>
<li><p>启发式设计原则    </p>
<ul>
<li><p>提高模块独立性</p>
</li>
<li><p>模块作用域在其控制域之内</p>
</li>
<li><p>降低模块接口复杂性</p>
</li>
</ul>
</li>
<li><p><strong>关键路径</strong>指的是花费时间最长的事件和活动的序列。<br>相关概念说明：<br>①最早开始时间：某段工程开始点之前最长的输入流之和<br>②最晚开始：关键路径-开始点到最后整个工程最后结束点的距离<br>③最早结束：某段工程结束点之前最长的输入流之和<br>④最晚结束：关键路径-该结束点到整个工程最后结束点的距离</p>
<p>1.关键路径：从开始到结束得所有路径中，所<strong>花费时间最长</strong>的一条为关键路径。<br>注意：在关键路径上的任务的松弛时间为0<br>最早开始时间：在关键路径上，从开始到该任务的最早执行的时间<br>最晚开始时间：关键路径的总时间-反向得出该任务的时间<br>2.松弛时间（最多延迟执行的时间）<br>第一种求法：最晚开始时间-最早开始时间<br>第二种求法：<strong>关键路径的总时间-包含该任务的关键路径花的时间</strong></p>
</li>
<li><p>软件项目成本估算模型 <strong>COCOM01I</strong> 中，体系结构阶段模型基于<strong>源代码的行数</strong>进行估算。</p>
</li>
<li></li>
<li><p>语法树 <strong>后缀式(逆波兰式）</strong>  原语法按中序排列构造，再按后序遍历得出</p>
</li>
<li><p>C/C++语言 预处理、编译、汇编、链接</p>
</li>
<li><p>进程 资源  能否化简即为判断有无<strong>死锁</strong></p>
</li>
<li><p>页式存储  根据<strong>页面大小</strong>计算高位和页内地址，<strong>高位通过表转换</strong> 拼接页内地址得到变换后的物理地址</p>
</li>
<li><p>索引文件结构 </p>
</li>
<li><p>根据题干可得：</p>
<p>其中0<del>4号节点为<strong>直接索引</strong>，对应逻辑块号为0</del>4。<br>其中5~6号节点为<strong>一级间接索引</strong>方式，对应逻辑块号从5开始。本题第一空选择B选项。<br>每个索引盘大小为1KB，地址项大小为4B，故每个索引盘有（1KB/4B）=256个索引。<br>一级间接索引有2个盘块，共有512个索引，对应512个逻辑盘块。<br>其中7号节点为二级间接索引，共有256 * 256=65536个索引，对应65536个逻辑盘块。<br><strong>单个文件最大</strong>为：(5+512+65536)*1KB=66053KB。</p>
</li>
<li><p>PV操作中信号量的分析 </p>
<p>PV信息量的取值表示资源数，最大值为初始可用资源5；<br>当信号量取值小于0时，可表示排队进程数，此时n个进程，<strong>最大排队数为n-5</strong>，信号量最小取值为-（n-5）。本题选择D选项。</p>
</li>
<li><p><strong>喷泉模型</strong> 是面向对象的开发方法的软件过程模型，不包括开发活动之间存在明显界限</p>
</li>
<li><p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/mnHbDC3dJp.png" alt="img"></p>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/%E5%86%85%E8%81%9A.png" alt="截屏2022-05-09 22.57.53"></p>
</li>
<li><p>面向对象的概念</p>
<ul>
<li>多态</li>
</ul>
<p>参数多态：应用广泛、最纯的多态。<br>包含多态：同样的操作可用于一个类型及其子类型。包含多态一般需要进行运行时的类型检查。包含多态在许多语言中都存在，最常见的例子就是子类型化，即一个类型是另外一个类型的子类型。<br>强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。<br>过载多态：同一个名（操作符﹑函数名）在不同的上下文中有不同的类型。 目前软设考查比较多的是过载多态。</p>
<ul>
<li>封装</li>
<li>继承</li>
</ul>
</li>
<li><p><strong>UML类图</strong> 面向对象的     </p>
<p>抽象类没有直接对象。因为A标识为{abstract}，即抽象类，抽象类不能直接进行实例化，即没有直接对象，只能有非直接对象，即子类的对象。</p>
</li>
</ol>
<ul>
<li><p>对象图：展现了某一个时刻一组对象以及它们之间的关系。</p>
</li>
<li><p>类图：展现了一组对象、接口、协作和它们之间的关系。</p>
</li>
<li><p>用例图：展现了一组用例、参与者以及它们之间的关系。</p>
</li>
<li><p>序列图：是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</p>
</li>
<li><p>多重度：图示表示的是1个A可以对应多个B，1个B只能对应1个A 。</p>
<p><strong>UML对象图</strong></p>
<p>重点：对象图是类图的实例，几乎使用与类图完全相同的标识。他们的不同点在于对象图显示类的多个对象实例，而不是实际的类。一个对象图是类图的一个实例。由于对象存在生命周期，因此对象图只能在系统某一时间段存在。 一般<strong>对象图的对象名会有：标识</strong>，且一般<strong>不会出现多重度</strong>。</p>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/%E7%B1%BB%E5%9B%BE-%E5%AF%B9%E8%B1%A1%E5%9B%BE.png" alt="截屏2022-05-09 23.19.33"></p>
<p><strong>UML状态图</strong></p>
<p>状态图展现了一个状态机，它由状态、转换、事件和活动组成，通常包括简单状态和组合状态、转换（事件和动作）。</p>
<p>由于状态可以是单一的，也可以是嵌套的（嵌套在另一个状态中的状态称为子状态，含有子状态的状态称为组合状态），所以活动可以在状态内执行，也可以在状态迁移时执行，A选项说法是正确的。</p>
<p>转换（迁移）是两个状态之间的一种关系，表示对象将在源状态执行一定的事件或动作，并在某个特定事件发生而且某个特定的监护条件满足时离开当前状态而进入目标状态，事件触发没有特定监护条件的迁移，对象也会离开当前状态，B选项正确。</p>
<p>转换（迁移）是从源状态和目的状态之间的一种关系，可以包含触发事件、监护条件、状态（源状态和目的状态）、动作，C选项说法不准确，本题选择C选项。</p>
<p>当某个事件发生后，对象的状态将发生变化，事件可以触发迁移，D选项说法是正确的。</p>
</li>
</ul>
<ol start="25">
<li>设计模式：Builder关键字，是生成器模式。</li>
</ol>
<p>生成器（构建器）模式的意图是：将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示。</p>
<ul>
<li>Builder：抽象建造者，为创建一个Product对象各个部件指定抽象接口，把产品的生产过程分解为不同的步骤，从而使具体建造者在具体的建造步骤上具有更多弹性，从而创造出不同表示的产品。</li>
<li>ConcreteBuilder：具体建造者，实现Builder接口，构造和装配产品的各个部件定义并明确它所创建的表示，提供一个返回这个产品的接口。</li>
<li>Director：指挥者，构建一个使用Builder接口的对象。即对应本题waiter。</li>
<li>Product：产品角色，被构建的复杂对象，具体产品建造者，创建该产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口。</li>
</ul>
<ol start="26">
<li><p>CFG (上 下文无关文法)</p>
<p>形式文法描述形式语言的基本想法是，从一个特殊的初始符号出发，不断的应用一些产生式规则，从而生成出一个字串的集合。产生式规则指定了<strong>某些符号组合如何被另外一些符号组合替换</strong>。</p>
<p>（id 表示单个字母表示的 变量）</p>
<p>P：E→E+T|E-T|T</p>
<p>T→T*F|F</p>
<p>F→-F|id</p>
<p>首先E能推导出T推导出F推导出id 即字母 a</p>
<p>E推导出E-T推导出E+T-T</p>
<p>F推导-F推导出-id得出-b</p>
<p>T推导F推导id得出c</p>
<p>a+-b-c</p>
</li>
<li><p>关于冲突的概念：<br>属性冲突。同一属性可能会存在于不同的分E-R图，由于设计人员不同或是出发点不同，对属性的类型、取值范围和数据单位等可能会不一致<br>命名冲突。相同意义的属性在不同的分E-R图中有着不同的命名，或是名词相同的属性在不同的分E-R图中代表着不同的意义。<br>结构冲突。同一实体在不同的分E-R图中有不同的属性，同一对象在某一分E-R图中被抽象为实体，而在另一分E-R图中又被抽象为属性，需要统一。本题厲于结构冲突，选择C选项。<br>没有实体冲突的说法。</p>
</li>
<li><p>(2020.44) 根据函数依赖，首先找到入度为o的属性集合A，又根据A一 BC，这里根据amstrong公理中的分解规则，可以得到A-B， A一C，同时存在B一D，此时有传递两数依赖A一D，可以通过A遍历全图，因此候选键为A。本题选择C</p>
</li>
<li><p>最优二叉树 （哈夫曼树）</p>
</li>
</ol>
<p>权值越大的叶子离根结点越近，Huffman (哈夫曼)树中<strong>不存在只有一个子树的结点</strong>，Huffman (哈夫曼)树中的结点总数一定为<strong>奇数</strong>。</p>
<ol start="30">
<li><p>二分查找</p>
<p><strong>顺序存储，元素排列有序</strong>。</p>
</li>
<li><p>图的遍历  广度优先 深度优先</p>
</li>
<li><p>快速排序的实现。  找一个当标准值，从后往前找比标准小的，从前往后找比标准大的 交换 ，再在替换的位置里面继续寻找替换，最后递归上述。</p>
</li>
<li><p>DHCP协议 无效的IP：169.254.X.X  (win)  0.0.0.0 (linux)</p>
</li>
<li><p>URL格式  协议://主机名.域名.域名后缀或者IP地址:端口/目录/文件名</p>
</li>
<li></li>
</ol>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/2020%E5%B9%B4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88/%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="截屏2022-05-09 21.44.50"></p>
<ol start="36">
<li><p>敏捷开发方法scrum</p>
<p>1）我们⾸先需要确定⼀个<strong>Product Backlog</strong>（产品代办事项清单）（按优先顺序排列的⼀个产品需求列表），这个是由Product Owner 负责的；</p>
<p>Scrum Team根据<strong>Product Backlog</strong>列表，做⼯作量的预估和安排；</p>
<p>2）有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出⼀个Story作为本次迭代完<br>成的⽬标，这个⽬标的时间周期是1~4个星期，然后把这个Story进⾏细化，形成⼀个Sprint Backlog；</p>
<p>3）Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更⼩的任务；</p>
<p>4）在Scrum Team完成计划会议上选出的<strong>Sprint Backlog</strong>过程中，需要进⾏ Daily Scrum Meeting（每⽇站⽴会议），每次会议控制<br>在15分钟左右，今天⼲了什么、明天要⼲什么、有什么困难 ，更新⾃⼰的 Sprint burn down（燃尽图）；</p>
<p>5）当⼀次<strong>Sprint</strong>（冲刺迭代）完成，这时，我们要进⾏ Srpint Review Meeting（演⽰会议），每个成员⽤Demo演⽰⾃⼰负责的任务，让产品负责<br>⼈评估是否完成；</p>
<p>6）最后就是 Sprint Retrospective Meeting（回顾会议），整个团队沟通上个Sprint执⾏中的问题和改进点，总结并讨论改进的地⽅，<br>放⼊下⼀轮Sprint的产品需求</p>
</li>
</ol>
<ol start="37">
<li><p><strong>McCabe</strong></p>
<p>在程序控制流程图中，节点是程序中代码的最小单元，边代表节点间的程序流。一个有<strong>e条边（不包含自己回到自己的）</strong>和n个<strong>节点</strong>的流程图F，其环路复杂度为</p>
<p><strong><u>V（G） =e－n+2</u>。</strong></p>
<p>（1）流图中的区域数等于环形复杂度。<br>（2）流图G的环形复杂度V(G)=<strong>E-N+2</strong>，其中，E是流图中边的条数，N是结点数。<br>（3）流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目。</p>
<p>环路复杂度越高，程序中的控制路径越复杂。mccabe指出，典型的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97">程序模块</a>的圈复杂度为10。</p>
</li>
<li><p><strong>E-R图</strong></p>
</li>
<li><p><strong>设计模式</strong></p>
<p>将抽象部分与其实现部分分离，使它们都可以独立的变化，为桥接模式，桥接模式是结构型对象模式。</p>
</li>
<li><p><strong>关系代数表达式</strong>   笛卡尔积  投影 选择  自然连接</p>
</li>
<li><p>邻接矩阵 行列数都为结点个数   邻接节点</p>
</li>
<li><p>排序算法</p>
</li>
<li><p>贪心算法  分数背包</p>
</li>
<li><p>霍夫曼编码  霍夫曼树</p>
</li>
</ol>
]]></content>
      <categories>
        <category>cs基础</category>
        <category>软考</category>
        <category>真题</category>
      </categories>
      <tags>
        <tag>软考中级</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年软件设计师知识点整理</title>
    <url>/2022/05/14/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="2020年软件设计师知识点"><a href="#2020年软件设计师知识点" class="headerlink" title="2020年软件设计师知识点"></a>2020年软件设计师知识点</h1><hr>
<h2 id="系统可靠性分析和设计"><a href="#系统可靠性分析和设计" class="headerlink" title="系统可靠性分析和设计"></a>系统可靠性分析和设计</h2><h3 id="1-串联系统"><a href="#1-串联系统" class="headerlink" title="1.串联系统"></a>1.串联系统</h3><p>可靠性R=R1 * R2 *……*Rn，各子系统可靠度相乘。</p>
<p>失效率 （近似）  总失效率=各子系统失效率相加</p>
<h3 id="2-并联系统"><a href="#2-并联系统" class="headerlink" title="2.并联系统"></a>2.并联系统</h3><p>可靠性 R=1- （1-R1）*（1-R2）*…*(1-Rn)   ，并联计算各子系统失效率，全部失效才真正失效，1-失效率</p>
<p>失效率 = 1- 可靠性</p>
<h3 id="3-模冗余系统和混合系统"><a href="#3-模冗余系统和混合系统" class="headerlink" title="3.模冗余系统和混合系统"></a>3.模冗余系统和混合系统</h3><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>检错和纠错</p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><table>
<thead>
<tr>
<th>描述</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>定点整数补码和移码范围</td>
<td>**-2^(n-1) ~ 2^(n-1) -1 **   （最小数再加1则为原码 反码的表示范围）</td>
</tr>
<tr>
<td>定点小数补码和移码范围</td>
<td>** -1 ~ 1-2^(-(n-1)) **          （原码 反码的表示范围:-(1-2^(-(n-1)) ~ 1-2^(-(n-1))</td>
</tr>
<tr>
<td>对称加密</td>
<td>DES 3DES RC4 RC5 IDEA AES</td>
</tr>
<tr>
<td>非对称加密   （公开密钥加密算法  ）</td>
<td>RSA，Rabin(RSA的特例)， DSA， ECC ，EIGamal</td>
</tr>
<tr>
<td>补码能表示的数的个数</td>
<td>2^n</td>
</tr>
<tr>
<td>浮点数表示</td>
<td>尾数 x 基数^指数</td>
</tr>
<tr>
<td>流水线理论公式</td>
<td>t1+..+tk+(n-1)*△t        （△t 为流水线中最长执行时间）</td>
</tr>
<tr>
<td>流水线实践公式</td>
<td>k△t+(n-1)*△t          （k为流水线的步骤数）</td>
</tr>
<tr>
<td>流水线吞吐率TP</td>
<td>指令条数/流水线执行时间</td>
</tr>
<tr>
<td>流水线最大吞吐率</td>
<td>1/△t</td>
</tr>
<tr>
<td>Cache+主存储器系统的平均周期</td>
<td><strong>h*t1+(1-h)*t2</strong></td>
</tr>
<tr>
<td>存储芯片片数</td>
<td>总容量/每片容量</td>
</tr>
<tr>
<td>系统可用性</td>
<td>MTTF/(MTTR+MTTF) * 100%    （MTTF平均失效前时间，MTTR平均修复时间）</td>
</tr>
<tr>
<td>系统可靠性</td>
<td>MTTF/(1+MTTF)</td>
</tr>
<tr>
<td>串联系统可靠性</td>
<td>R1*R2…*Rn</td>
</tr>
<tr>
<td>并联系统可靠性</td>
<td>1-(1-R1)<em>(1-R2)…</em>(1-Rn)</td>
</tr>
<tr>
<td>海明检验码</td>
<td>2^r &gt;= r+m+1   r:校验位  m：数据位</td>
</tr>
<tr>
<td>MIPS</td>
<td>指令条数/(执行时间<em>10^6)主频/CPI主频</em>IPC</td>
</tr>
<tr>
<td>系统不死锁最小资源</td>
<td>n &gt;= (w-1)*m+1</td>
</tr>
<tr>
<td>逻辑地址</td>
<td>页号+页内地址</td>
</tr>
<tr>
<td>物理地址</td>
<td>页帧号+页内地址</td>
</tr>
<tr>
<td>文件物理块所在位示图的位置</td>
<td>(n+1)/字长，向上取整</td>
</tr>
<tr>
<td>端口号</td>
<td><strong>TCP类型</strong>: POP3 110 ， SMTP 25 ，FTP 20/21 ，Telnet 23， HTTP 80 ，HTTPS 443     <strong>UDP类型</strong>:DHCP 67 ，TFTP 69 ，SNMP 161 ，DNS 53</td>
</tr>
<tr>
<td>摘要算法</td>
<td>MD5 128位    SHA 160位</td>
</tr>
<tr>
<td>网络安全保障</td>
<td>应用层：PGP HTTPS SSL表示层：SSL会话层：SSL传输层：TLS SET网络层：防火墙 IPSec数据链路层：链路加密 PPTP L2TP物理层：隔离 屏蔽</td>
</tr>
<tr>
<td>风险曝光度</td>
<td>风险出现率*风险损失</td>
</tr>
<tr>
<td>时间复杂度排序</td>
<td>O(1)&lt;O(log₂n)&lt;O(n)&lt;O(nlog₂n)&lt;O(n²)&lt;O(n³)&lt;O(2^n)</td>
</tr>
<tr>
<td>有无主程序开发小组，沟通路径</td>
<td>有主程序员 m= n -1  无程序员组：完全联通无向边图的边数 m = n *(n -1) /2</td>
</tr>
<tr>
<td>第一范式(1NF)：</td>
<td>关系模式S中的所有属性都是不可再分的基本数据项</td>
</tr>
<tr>
<td>第二范式(2NF)：</td>
<td>在第一范式的基础上，消除了非主属性对码的部分函数依赖</td>
</tr>
<tr>
<td><a href="https://so.csdn.net/so/search?q=%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F&spm=1001.2101.3001.7020">第三范式</a>(3NF):</td>
<td>在第二范式的基础上，进一步消除了非主属性对码的传递函数依赖</td>
</tr>
<tr>
<td>BC范式(BCNF):</td>
<td>在第三范式的基础上，进一步消除了主属性对码的部分函数依赖和传递函数依赖</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)</td>
</tr>
<tr>
<td>有/无主程序员沟通路径</td>
<td>n-1（有主）       n*(n-1)/2（无主）</td>
</tr>
<tr>
<td>声音频率 ｜ 20Hz - 20KHz</td>
<td></td>
</tr>
<tr>
<td>色彩空间</td>
<td>RGB显示器 YUV（YCBR）电视 CMY印刷 HSV 艺术</td>
</tr>
</tbody></table>
<p><img src="/2022/05/14/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/Users\sxyyl\Documents\GitHub_posts\软考\20170406122131723.jpg" alt="20170406122131723"></p>
<h2 id="内聚与耦合"><a href="#内聚与耦合" class="headerlink" title="内聚与耦合"></a>内聚与耦合</h2><h3 id="内聚（从弱到强）"><a href="#内聚（从弱到强）" class="headerlink" title="内聚（从弱到强）"></a>内聚（从弱到强）</h3><ul>
<li><p>偶然内聚（巧合内聚）一个模块内的各处理元素之间没有任何联系，只是偶然地被凑到一起。这种模块也称为巧合内聚，内聚程度最低。</p>
</li>
<li><p>逻辑内聚：这种模块把几种<strong>相关的功能组合</strong>在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能 。相关的功能也就是逻辑上的功能放在一起。如表述，我和全世界的人，比较松</p>
</li>
<li><p>时间内聚：把需要<strong>同时执行的动作</strong>组合在一起形成的模块称为时间内聚模块。仅是时间上相关的动作，如一边看书，一边听音乐，可以描述了件事情了，但还不是必须在一块执行的动作。</p>
</li>
<li><p>过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。简单的说就是如果一个模块内的处理元素是相关的，而且必须以<strong>特定次序执行</strong>则称为过程内聚。两个功能同属于一个过程中，有了在一起的理由。<br>例如某要完成登录的功能，前一个功能判断网络状态，后一个执行登录操作，显然是按照特定次序执行的。</p>
</li>
<li><p>通信内聚：指模块内所有处理元素都在<strong>同一个数据结构上操作</strong>或所有处理功能都<strong>通过公用数据</strong>而发生关联（有时称之为信息内聚）。即指模块内各个组成部分都使用相同的数据结构或产生相同的数据结构。两个模块需要交换数据（通信）了，才能完成某一个功能。这样在一起的 理由更充分了一些。</p>
</li>
<li><p>顺序内聚：一个模块中各个处理元素和同一个功能密切相关，而且这些处理<strong>必须顺序执行</strong>，通常前一个处理元素的输出是后一个处理元素的输入。顺序虽然也代表着过程，但有本质的区别，还是体现在数据的关联上，顺序强调的是前一个输出是后一个的输入。不仅强调数据交流（通信）还限制顺序，在一起的理由就更充分了。<br>例如某要完成获取订单信息的功能，前一个功能获取用户信息，后一个执行计算均价操作，显然该模块内两部分紧密关联。<br>顺序内聚的内聚度比较高，但缺点是不如功能内聚易于维护。</p>
</li>
<li><p>功能内聚：模块内所有元素的各个组成部分全部都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。即模块仅包括为完成某个功能所必须的所有成分，这些成分紧密联系、缺一不可。就是为了单一的功能，不可再拆分了，必须在一起了。</p>
<h3 id="耦合（从强到弱）"><a href="#耦合（从强到弱）" class="headerlink" title="耦合（从强到弱）"></a>耦合（从强到弱）</h3></li>
<li><p>内容耦合：一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。<br>若在程序中出现下列情况之一，则说明两个模块之间发生了内容耦合：</p>
</li>
</ul>
<ol>
<li>一个模块直接访问另一个模块的内部数据。</li>
<li>一个模块不通过正常入口而直接转入到另一个模块的内部。</li>
<li>两个模块有一部分代码重叠（该部分代码具有一定的独立功能）。</li>
<li>一个模块有多个入口。</li>
</ol>
<p>内容耦合可能在汇编语言中出现。大多数高级语言都已设计成不允许出现内容耦合。这种耦合的耦合性最强，模块独立性最弱。</p>
<p>其中一个模块访问另一个模块的内部，也就是信赖另一个模块的内容</p>
<ul>
<li>公共耦合：一组模块都访问同一个<strong>全局数据结构</strong>，则称之为公共耦合。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。如果模块只是向公共数据环境输入数据，或是只从公共数据环境取出数据，这属于比较松散的公共耦合；如果模块既向公共数据环境输入数据又从公共数据环境取出数据，这属于较紧密的公共耦合。<br>公共耦合会引起以下问题：一个模块通过公共的数据与另一个模块关联，有共用的大量数据，那么还是不独立。</li>
</ul>
<ol>
<li>无法控制各个模块对公共数据的存取，严重影响了软件模块的可靠性和适应性。</li>
<li>使软件的可维护性变差。若一个模块修改了公共数据，则会影响相关模块。</li>
<li>降低了软件的可理解性。不容易清楚知道哪些数据被哪些模块所共享，排错困难。</li>
</ol>
<p>一般地，仅当模块间共享的数据很多且通过参数传递很不方便时，才使用公共耦合。</p>
<ul>
<li><p>外部耦合：一组模块都访问同一<strong>全局简单变量</strong>，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。模块间通过外部的简单变量，少量的共用数据产生关联，独立性好点了。</p>
</li>
<li><p>控制耦合：模块之间传递的不是数据信息，而是<strong>控制信息</strong>例如标志、开关量等，一个模块控制了另一个模块的功能。模块间通过控制信号，肯定是外部的了，并且是开关量，共用数据更少了。独立性更好了。</p>
</li>
<li><p>标记耦合：调用模块和被调用模块之间<strong>传递数据结构</strong>而不是简单数据，同时也称作特征耦合。表就和的模块间传递的不是简单变量，而是像高级语言中的数据名、记录名和文件名等数据结果，这些名字即为标记，其实传递的是地址。标记理解为地址的话，地址里的内容可不一定是固定的，所以模块间的关系，基本开始脱离数据这么紧密的关系了，开始独立了。</p>
</li>
<li><p>数据耦合：调用模块和被调用模块之间只传递<strong>简单的数据项参数</strong>。相当于高级语言中的值传递。只是传递了个数据，如1，不用于共用数据了才行了，更加独立了。</p>
</li>
<li><p>非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。</p>
</li>
</ul>
<hr>
<p> 二叉树</p>
<ul>
<li>反向构造二叉树，<br>对比前序，中序遍历，前序第一个是根节点， 中序中的相同的字母分为左右两边，继续往下循环</li>
<li>树转二叉树<br>孩子节点-左子树节点     兄弟节点-树的右子节点  （从上到下，从左到右）</li>
<li>哈夫曼树</li>
</ul>
<ol>
<li><p>在权值中拿出最小两个，相加生成父节点，再将父节点放入原权值组中 循环上述操作构造成树</p>
</li>
<li><p>带权路径长度=全部叶子节点权值*路径长度</p>
</li>
<li><p>树左节点为0，右子节点为1</p>
</li>
</ol>
<hr>
<p>软考中涉及到的主要开发模型：</p>
<ol>
<li>原型开发模型（快速原型模型、演化模型、增量模型）</li>
</ol>
<ul>
<li>1）快速原型：<br><br>   解释：其用途是获知用户的真正需求，一旦需求确定了，原型即被抛弃。主要用于需求分析阶段。是一种“抛弃式”的原型化方法。<br><br>   特征：简化项目管理、尽快建立初步需求、加强用户参与和决策。<br></li>
<li>2）演化模型：<br><br>   解释：应用于真个软件开发过程，是从最初模型逐步演化为最终软件产品的渐进过程。是一种“渐进式”的原型化方法。<br></li>
<li>3）增量模型（渐增式）<br><br>   解释：主要用于设计阶段，把软件产品划分为一系列的增量构件，分别进行设计、编程、集成和测试。新的增量构件不得破坏已经开发出来的产品。</li>
</ul>
<ol start="2">
<li>瀑布模型<br><pre><code>解释：瀑布模型严格遵循软件生命周期各阶段的固定顺序：计划、分析、设计、编程、测试和维护，上一阶段完成后才能进入下一阶段，真个模型就像是一个飞流直下的瀑布。
      优点：以文档作为驱动，强迫开发人员采用规范的方法，严格规定了各阶段必须提交的文档；要求每一阶段结束后都要进行严格的评审。与它最相适应的开发方法是结构化方法。
      缺点：不适用户需求的改动。
</code></pre>
</li>
<li>螺旋模型<br><pre><code>解释：综合了瀑布模型和原型模型中的演化模型的优点，还增加了风险分析。螺旋线第一圈的开始点可能是一个概念项目。从第二圈开始，一个新产品开发项目就开始了，新产品的演化沿着螺旋线进行若干次迭代，一直转到软件生命期结束。
</code></pre>
</li>
<li>喷泉模型<br><pre><code> 解释：主要用于描述面向对象的开发过程。喷泉一词体现了面向对象开发过程的迭代和无间隙特征。
</code></pre>
</li>
<li>迭代软件开发技术<pre><code>  Rational统一开发流程RUP是一个通用的软件流程框架，它是一个以框架为中心，用例驱动的迭代化软件开发流程。RUP是从千个软件项目的实践经验中总结出来的，对于实际的项目具有很强的指导意义，是软件开发行业事实上的行业标准。在RUP中，我们把软件开发生命周期划分为四个阶段，每个阶段的结束标志就是一个主要的里程碑。
            这四个阶段是为了达到以下阶段性的目标里程碑：
             先启（Inception）：确定项目开发的目标和范围。
             精化（Elaboration）：确定系统架构和系统功能
             构建（Construction）：实现剩余的系统功能
             产品化（Transition）：完成软件的产品化工作，将系统移交给客户
   真题再现：&lt;br/&gt;
   1.（2012年下）某开发小组欲开发一个规模较大、需求较明确的项目。开发小组对项目领域熟悉且该项目与小组开发过的某一项目相似，则适宜采用瀑布开发模型。&lt;br/&gt;
   2.（2012年上）假设某软件公司与客户签订合同开发一个软件系统，系统的功能有较清晰的定义，且客户对交付时间有严格要求，则该系统的开发最适宜采用瀑布模型。&lt;br/&gt;
   3.（2011年下）若全面采用新技术开发一个大学记账系统，以替换原有的系统，则宜选择采用瀑布模型进行开发。&lt;br/&gt;
   4.（2011年上）为了有效地捕获系统需求，应采用原型模型&lt;br/&gt;
   5.（2010年上）统一过程（UP）定义了初启阶段、精化阶段、构建阶段、移交阶段，每个阶段以达到某个里程碑时结束，其中，精化阶段的里程碑时生命周期架构。
</code></pre>
</li>
</ol>
<h2 id="下午题目"><a href="#下午题目" class="headerlink" title="下午题目"></a>下午题目</h2><h3 id="查找缺失数据流方法"><a href="#查找缺失数据流方法" class="headerlink" title="查找缺失数据流方法"></a>查找缺失数据流方法</h3><ul>
<li>1.父图子图 对比</li>
<li>2.确定每个加工查看是否有输入输出</li>
<li>3.读试题描述和图做对比，查看是否有缺失。（每句话都要仔细看）</li>
</ul>
<h3 id="分解加工时，常见的三种错误"><a href="#分解加工时，常见的三种错误" class="headerlink" title="分解加工时，常见的三种错误"></a>分解加工时，常见的三种错误</h3><ul>
<li>1.黑洞 有输入无输出</li>
<li>2.白洞 无输入有输出</li>
<li>3.灰洞 输入不足以产生输出</li>
</ul>
<h3 id="添加缺失"><a href="#添加缺失" class="headerlink" title="添加缺失"></a>添加缺失</h3><p>1.将***作为<strong>外部实体</strong>，添加从<strong>加工</strong>“ ***” 到“ ***” 的<strong>数据流</strong>“***”</p>
<h3 id="结构化语言"><a href="#结构化语言" class="headerlink" title="结构化语言"></a>结构化语言</h3><p>伪代码<br>1）从题干中抽取“动词 + 名词” 或者 “名词 + 动词”，而不是直接COPY整个句子。<br><br>2）从题干内容中提炼出IF，WHILE：比如2021上半年1题中，车辆入场和出场是想对的概念，因此是IF；比如2020下半年1题中，图像采集是一个WHILE过程。<br><br>3）利用伪代码（参考latex代码格式，参考Latex写伪代码）书写，常见语法包括：while(…) do {xxx} end while，if(…) then {xxx} end if  <br></p>
<h3 id="用例和用例之间的关系"><a href="#用例和用例之间的关系" class="headerlink" title="用例和用例之间的关系"></a>用例和用例之间的关系</h3><p>1.包含   系统用例较多，不同用例之前存在共同行为，可以将这些共同的行为提取出来，单独组成一个用例，当其他用例适用这个用例时，他们就构成了包含关系<br><br>2.扩展  当用例执行过程中，可能会出现一些特殊情况，也可能再不同的分支行为中选择执行，这时可将异常行为与可选分支抽象微一个单独的扩展用例，一个用例可能有多个扩展用例<br><br>3.泛化</p>
<h3 id="类图中各个图形和线条的意义"><a href="#类图中各个图形和线条的意义" class="headerlink" title="类图中各个图形和线条的意义"></a>类图中各个图形和线条的意义</h3><p><a href="https://blog.csdn.net/weixin_43512504/article/details/124522865">各种uml图</a><br>1.用例图<br>2.类图<br>3.对象图<br>4.活动图<br>5.状态图<br>6序列图（时序图）<br>7.协作图（通信图）<br>8.构建图<br>9.部署图<br>10.组件图</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>软考中常见算法类型：分治法、回溯法、贪心法、动态规划法。</p>
<h3 id="1-分治法"><a href="#1-分治法" class="headerlink" title="1. 分治法"></a>1. 分治法</h3><p>将一个问题<strong>拆分为若干个小规模的子问题</strong>，通常用递归的思想求解子问题，子问题相互独立但与原问题相同，再将子问题的解合并得到原问题的解。（自下向上）</p>
<h3 id="2-回溯法"><a href="#2-回溯法" class="headerlink" title="2. 回溯法"></a>2. 回溯法</h3><p>搜索问题的所有解或任一解，在搜索过程中发现<strong>不满足求解条件则回溯</strong>，尝试别的路径。</p>
<h3 id="3-贪心法"><a href="#3-贪心法" class="headerlink" title="3. 贪心法"></a>3. 贪心法</h3><p>不考虑整体，只在当前做出最优的选择，求得<strong>局部最优解</strong>。（自顶向下）</p>
<h3 id="4-动态规划法"><a href="#4-动态规划法" class="headerlink" title="4. 动态规划法"></a>4. 动态规划法</h3><p>划分子问题为<strong>最优的子策略</strong>，并把子问题的解使用数组存储，利用<strong>查表</strong>查出子问题结果构造最终问题结果。与分治法不同的是子问题不独立，相同子问题可能会被求解多次。（自底向上/自下而上）<br><br><a href="https://blog.csdn.net/weixin_43512504/article/details/124573164">软考常见算法例题</a></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-创建性模式"><a href="#1-创建性模式" class="headerlink" title="1.创建性模式"></a>1.创建性模式</h3><p><strong>抽象工厂模式</strong>（Abstract Factory）:提供一个接口，可以创建一系列相关或相互依赖的对象，而<strong>无需指定它们具体的类</strong>。（一个接口创建相关对象，无需具体的类）<br><br>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</p>
<p><strong>构建器模式</strong>（Builder）：将一个复杂类的表示与其构造相分离，使得<strong>相同的构建</strong>过程能<strong>够得出不同的表示</strong>。（相同是构造，不同的表示）</p>
<p>工厂方法模式（Factory Method）：定义一个创建对象的接口，但由<strong>子类决定需要实例化哪一个类</strong>。工厂方法使得子类实例化的过程推迟。（接口，子类决定实例化具体类）</p>
<p>原型模式（Prototype）：用原型实例指定创建对象的类型，并且通过<strong>拷贝这个原型</strong>来创建新的对象。（只有一个实例）</p>
<p>单例模式（Singleton）:保证一个类只有一个实例，并提供一个访问它的全局访问点。（只有一个实例）</p>
<h3 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2.结构型模式"></a>2.结构型模式</h3><p>适配器模式（Adapter）：将一个类的<strong>接口转换</strong>成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作。（实现兼容）</p>
<p><strong>桥接模式</strong>（Bridge）：将类的<strong>抽象部分和它的实现部分</strong>分离开来，使它们可以独立地变化。（抽象和实现分离开）</p>
<p>组合模式（Composite）：将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。（整体—部分）</p>
<p>装饰模式（Decorator）：动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活。（动态添加）</p>
<p>外观模式（Facade）:定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用。（为子系统提供一致的外观）</p>
<p>享元模式（Flyweight）：提供支持<strong>大量细粒度对象共享</strong>的有效方法。（共享）</p>
<p>代理模式（Proxy）：为其他对象提供一种代理以控制这个对象的访问。（提供代理）</p>
<h3 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3.行为型模式"></a>3.行为型模式</h3><p>职责链模式（Chain of Responsibility）：通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。（将对象链接起来，在链中传递请求）</p>
<p>命令模式（Command）：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。（参数化）</p>
<p>解释器模式（Interpreter）：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子。（有一个解释器来表示文法句子）</p>
<p>迭代器模式（Iterator）：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。（不需要暴露对象的内部）</p>
<p><strong>中介者模式</strong>（Mediator）：用一个中介对象来封装一系列的对象交互。它使各<strong>对象不需要显式地相互调用</strong>，从而达到低耦合，还可以独立地改变对象间的交互。（<strong>使用中介来调用</strong>）</p>
<p>备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。（<strong>可以恢复到之前的状态</strong>）</p>
<p><strong>观察者模式</strong>（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。（<strong>一个变，其他也变</strong>）</p>
<p><strong>状态模式</strong>（State）：允许一个对象在其内部<strong>状态改变时改变它的行为</strong>。（状态改变时改变它的行为）</p>
<p>策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们之间<strong>可互相替换</strong>，从而让算法可以独立于使用它的用户而变化。（互相替换）</p>
<p>模板方法模式（Template Method）：定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得<strong>子类可以不改变一个算法的结构即可重新定义算法</strong>的某些特定步骤。（子类父类）</p>
<p>访问者模式（Visitor）：表示一个作用于<strong>某对象结构中的各元素的操作</strong>，使得在不改变各元素的类的前提下定义作用于这些元素的新操作,需要对一个对象数据结构中的对象进行很多不同的并且不相关的操作。（不改变各元素定义这些元素的新操作）</p>
]]></content>
      <categories>
        <category>cs基础</category>
        <category>软考</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>软考中级</tag>
      </tags>
  </entry>
  <entry>
    <title>shell中常见的字符串操作</title>
    <url>/2022/04/15/shell/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>shell中定位字符的方式，包括常见的分割：按位置分隔，按指定的字符串截取，按照指定要求（如指定后缀）分割。</p>
<span id="more"></span>
<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h2 id="一、按位置分隔"><a href="#一、按位置分隔" class="headerlink" title="一、按位置分隔"></a>一、按位置分隔</h2><p>Linux shell <strong>截取</strong>字符变量的<strong>前8位</strong>，有方法如下：</p>
<ul>
<li><p>1.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr substr “$a” 1 8</span><br></pre></td></tr></table></figure></li>
<li><p>2.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $a|awk ‘&#123;print substr(,1,8)&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>3.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $a|cut -c1-8</span><br></pre></td></tr></table></figure></li>
<li><p>4.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr $a : ‘\(.\\).*&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>5.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $a|dd bs=1 count=8 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="二、按指定的字符串截取"><a href="#二、按指定的字符串截取" class="headerlink" title="二、按指定的字符串截取"></a>二、按指定的字符串截取</h2><h3 id="1-第一种方法"><a href="#1-第一种方法" class="headerlink" title="1. 第一种方法:"></a>1. 第一种方法:</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;varible<span class="comment">##*string&#125; #从左向右截取最后一个string后的字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;varible<span class="comment">#*string&#125; #从左向右截取第一个string后的字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;varible%%string*&#125; <span class="comment">#从右向左截取最后一个string后的字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;varible%string*&#125; <span class="comment">#从右向左截取第一个string后的字符串</span></span></span><br></pre></td></tr></table></figure>
<p>“*”只是一个通配符可以不要</p>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> MYVAR=foodforthought.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;MYVAR##*fo&#125;</span></span></span><br><span class="line"></span><br><span class="line">rthought.jpg</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;MYVAR#*fo&#125;</span></span></span><br><span class="line"></span><br><span class="line">odforthought.jpg</span><br></pre></td></tr></table></figure>

<h3 id="2-第二种方法："><a href="#2-第二种方法：" class="headerlink" title="2. 第二种方法："></a>2. 第二种方法：</h3><p>${varible:n1:n2}:截取变量varible从n1到n2之间的字符串。</p>
<p>可以根据特定字符偏移和长度，使用另一种形式的变量扩展，来选择特定子字符串。试着在 bash 中输入以下行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> EXCLAIM=cowabunga</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;EXCLAIM:0:3&#125;</span></span></span><br><span class="line"></span><br><span class="line">cow</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;EXCLAIM:3:7&#125;</span></span></span><br><span class="line"></span><br><span class="line">abunga</span><br></pre></td></tr></table></figure>
<p>这种形式的字符串截断非常简便，只需用冒号分开来指定起始字符和子字符串长度。</p>
<h2 id="三、按照指定要求分割："><a href="#三、按照指定要求分割：" class="headerlink" title="三、按照指定要求分割："></a>三、按照指定要求分割：</h2><p>比如获取后缀名</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">al</span> | cut -d “.” -f2</span><br></pre></td></tr></table></figure>
<p>应用心得：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$MYVAR</span>=<span class="string">&quot;12|dadg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;MYVAR##*|&#125;</span>   <span class="comment">#打印分隔符后的字符串</span></span><br><span class="line"></span><br><span class="line">dafa</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;MYVAR%%|*&#125;</span> <span class="comment">#打印分隔符前的字符串</span></span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h2 id="四、批量替换所有文件中的指定字符串"><a href="#四、批量替换所有文件中的指定字符串" class="headerlink" title="四、批量替换所有文件中的指定字符串"></a>四、批量替换所有文件中的指定字符串</h2><p>sed -i “s/原字符串/新字符串/g” <code>grep 原字符串 -rl 所在目录</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sed</span> -i <span class="string">&quot;s/mahuinan/huinanma/g&quot;</span> <span class="string">&#x27;grep mahuinan -rl /www&#x27;</span></span><br></pre></td></tr></table></figure>

<p>1）只替换第1个子串<br>格式：${变量名/old/new}</p>
<p>2）替换全部子串<br>格式：${变量名//old/new}<br>将phone字符串中的所有8都替换为X:</p>
<h2 id="五、awk-提取两个字符串之间的内容"><a href="#五、awk-提取两个字符串之间的内容" class="headerlink" title="五、awk 提取两个字符串之间的内容"></a>五、awk 提取两个字符串之间的内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/bash</span></span><br><span class="line"></span><br><span class="line">src=$1</span><br><span class="line">dst=$2</span><br><span class="line">cat $&#123;src&#125; | grep -E &quot;&lt;plate&gt;.*&lt;/plate&gt;&quot; | awk &#x27;&#123;t=$0;gsub(/.*&lt;plate&gt;|&lt;\/plate&gt;.*/,&quot;&quot;,t);print t&#125;&#x27; &gt; $&#123;dst&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六、shell下在while循环中使用ssh命令的问题"><a href="#六、shell下在while循环中使用ssh命令的问题" class="headerlink" title="六、shell下在while循环中使用ssh命令的问题"></a>六、shell下在while循环中使用ssh命令的问题</h1><hr>
<p>1 现象描述　　最近使用ssh批量执行命令(已经做了密钥互信了)，脚本读取配置文件中的主机列表(内容为每行一台主机IP地址)，然后执行，可是每次只是执行第一台，就退出循环了。</p>
<p>2 排查思路　　由于脚本比较简单，只是读取主机，然后ssh而已，所以问题应该出现在ssh上</p>
<p>3 确定问题　　搞不通ssh命令为什么会导致shell退出，最后上网搜了一下才找到答案。</p>
<p><code>ssh命令在每次执行时，会读取所有的标准输入中的内容。 </code>　　对于while循环，当按照如下方式使用时：</p>
<p><code>while  read Line    do         </code></p>
<p> echo $Line done  &lt; $filename `　　这里使用重定向，将文件内容输入到while命令，while命令每次使用read从输入中读取一行数据。　　问题就在这里，如果在while循环中调用了ssh命令，<strong>那么ssh就会把当前输入中所有的数据读走，也就是重定向给while命令的数据，都被ssh命令读走了，以至于下次循环的时候，read读到的内容为空，导致循环提前结束。</strong></p>
<p>4 处理结果　　　　</p>
<p>解决这个问题两种方式使用ssh的-n参数：用/dev/null来当ssh的输入，阻止ssh读取本地的标准输入内容。ssh xxxx &lt; /dev/null 重定向shell命令的输入</p>
]]></content>
      <categories>
        <category>unix</category>
        <category>shell</category>
        <category>字符串操作</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell知识点</title>
    <url>/2022/04/15/shell/shell%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="Shell-中数字相加"><a href="#Shell-中数字相加" class="headerlink" title="Shell 中数字相加"></a>Shell 中数字相加</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">c=`expr $&#123;a&#125; + $&#123;b&#125;`</span><br><span class="line">echo &quot;$c&quot;</span><br><span class="line"></span><br><span class="line">let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上</span><br><span class="line"><span class="meta"> $</span><span class="bash"> 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</span></span><br><span class="line"> </span><br><span class="line">let a=5+4</span><br><span class="line">let b=9-3 </span><br><span class="line">echo $a $b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ftp命令"><a href="#ftp命令" class="headerlink" title="ftp命令"></a>ftp命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp ip.ip.ip.ip</span><br><span class="line"><span class="meta">#</span><span class="bash">获取文件</span></span><br><span class="line">mget</span><br><span class="line"><span class="meta">#</span><span class="bash">上传文件</span></span><br><span class="line">mput</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭确认提示</span></span><br><span class="line">prompt</span><br><span class="line"><span class="meta">#</span><span class="bash">删除文件</span></span><br><span class="line">delete xxx.dat</span><br><span class="line"><span class="meta">#</span><span class="bash">批量删除文件 支持通配</span></span><br><span class="line">mdelete *xxx*</span><br></pre></td></tr></table></figure>



<h2 id="awk中输入外部的变量"><a href="#awk中输入外部的变量" class="headerlink" title="awk中输入外部的变量"></a>awk中输入外部的变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">注意 <span class="string">&quot; 和 &#x27;</span></span></span><br><span class="line">grep kdpl_acct_bal load.sh|awk &#x27;&#123;print &quot;&#x27;$FilePath&#x27;&quot;$4&#125;&#x27;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="数字的比较："><a href="#数字的比较：" class="headerlink" title="数字的比较："></a>数字的比较：</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">-<span class="literal">eq</span> 相等（equal）</span><br><span class="line"></span><br><span class="line">-<span class="literal">ne</span> 不等<span class="built_in">（not</span> equal）</span><br><span class="line"></span><br><span class="line">-<span class="literal">gt</span> 大于（greater than）</span><br><span class="line"></span><br><span class="line">-<span class="literal">lt</span> 小于（less than）</span><br><span class="line"></span><br><span class="line">-<span class="literal">ge</span> 大于等于 （greater than <span class="keyword">or</span> equal）</span><br><span class="line"></span><br><span class="line">-<span class="literal">le</span> 小于等于 （less than <span class="keyword">or</span> equal）</span><br><span class="line"></span><br><span class="line">字符串的比较：</span><br><span class="line"></span><br><span class="line">[ <span class="variable">$str1</span> = <span class="variable">$str2</span> ] 等于</span><br><span class="line"></span><br><span class="line">[ <span class="variable">$str1</span> != <span class="variable">$str2</span> ] 不等于</span><br><span class="line"></span><br><span class="line">[ -z <span class="variable">$str</span> ] 空字符串返<span class="built_in">回true</span></span><br><span class="line"></span><br><span class="line">[ -n <span class="variable">$str</span> ] 或者 [ <span class="variable">$str</span> ] 非空字符串返<span class="built_in">回true</span></span><br></pre></td></tr></table></figure>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">grep</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-r 是递归查找</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-n 是显示行号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-R 查找所有文件包含子目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-i 忽略大小写</span></span><br><span class="line">grep -rn &quot;hello,world!&quot; *</span><br></pre></td></tr></table></figure>


<h2 id="清文件，腾空间相关"><a href="#清文件，腾空间相关" class="headerlink" title="清文件，腾空间相关"></a>清文件，腾空间相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看空间：</span></span><br><span class="line">df -h</span><br><span class="line">du -sh *   //查看当前所有目录及目录大小</span><br><span class="line">du -h --max-depth=1   //列出当前目录每个目录下的大小兑付-</span><br><span class="line">删除：</span><br><span class="line">/bin/rm -rf ./2016*       bin下执行  不进入回收站</span><br></pre></td></tr></table></figure>

<h2 id="查找包含某段信息的文件名"><a href="#查找包含某段信息的文件名" class="headerlink" title="查找包含某段信息的文件名"></a>查找包含某段信息的文件名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find .|xargs grep -ri &quot;01000000000275&quot; -l </span><br><span class="line">find . -name *.* |xargs grep &quot;2052019052300000000138&quot; -l</span><br><span class="line">ps -ef|grep java //查找进程 java</span><br></pre></td></tr></table></figure>


<h1 id="强杀进程"><a href="#强杀进程" class="headerlink" title="强杀进程"></a>强杀进程</h1><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">ps -ef|<span class="keyword">grep</span> job|<span class="keyword">grep</span> -v <span class="keyword">grep</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|xargs <span class="keyword">kill</span> -<span class="number">9</span></span><br><span class="line">ps -ef|<span class="keyword">grep</span> $ORACLE_SID|<span class="keyword">grep</span> -v <span class="keyword">grep</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|xargs <span class="keyword">kill</span> -<span class="number">9</span></span><br><span class="line">ps -ef|<span class="keyword">grep</span> sqlldr|<span class="keyword">grep</span> -v <span class="keyword">grep</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|xargs <span class="keyword">kill</span> -<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>脚本开头加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment">#检查是否有未绑定变量</span></span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br><span class="line"><span class="comment">#异常退出</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="comment">#退出前的处理 finally</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;echo &quot;exitting&quot;&#x27;</span> <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unix</category>
        <category>shell</category>
        <category>日常使用</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>运算</tag>
        <tag>ftp</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos下docker模式下安装gitlab私有库</title>
    <url>/2021/10/13/%E7%A1%AC%E4%BB%B6&amp;%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Centos%E4%B8%8Bdocker%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%AE%89%E8%A3%85gitlab%E7%A7%81%E6%9C%89%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p>主机信息：阿里云ECS</p>
<p>CPU&amp;内存：1核2 GiB </p>
<p>磁盘：100G</p>
<p>操作系统：CentOS 8.4 64位</p>
</blockquote>
<h3 id="1-gitlab镜像拉取"><a href="#1-gitlab镜像拉取" class="headerlink" title="1.gitlab镜像拉取"></a>1.gitlab镜像拉取</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gitlab-ce为稳定版本，后面不填写版本则默认pull最新latest版本</span></span><br><span class="line"><span class="variable">$ </span>docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>

<h3 id="2-运行gitlab镜像"><a href="#2-运行gitlab镜像" class="headerlink" title="2.运行gitlab镜像"></a>2.运行gitlab镜像</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ docker run -d  -p <span class="number">443</span>:<span class="number">443</span> -p <span class="number">80</span>:<span class="number">80</span> -p <span class="number">222</span>:<span class="number">22</span> --name gitlab --restart always -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/<span class="keyword">var</span>/log/gitlab -v /root/gitlab/data:/<span class="keyword">var</span>/opt/gitlab gitlab/gitlab-ce</span><br><span class="line"><span class="meta"># -d：后台运行</span></span><br><span class="line"><span class="meta"># -p：将容器内部端口向外映射</span></span><br><span class="line"><span class="meta"># --name：命名容器名称</span></span><br><span class="line"><span class="meta"># -v：将容器内数据文件夹或者日志、配置等文件夹挂载到宿主机指定目录</span></span><br></pre></td></tr></table></figure>

<p>以上操作完似乎就可以使用了，/root/gitlab/config 中有root用户的初始密码。</p>
<h3 id="3-然而"><a href="#3-然而" class="headerlink" title="3.然而"></a>3.然而</h3><p>运行后主机死翘翘了，内存太低，直接100%，ssh都登不上了。</p>
<p>不慌，阿里巴巴控制台强制重启，然后进去把docker中的gitlab停了。</p>
<h3 id="4-低配置主机添加swap空间"><a href="#4-低配置主机添加swap空间" class="headerlink" title="4.低配置主机添加swap空间"></a>4.低配置主机添加swap空间</h3><p>使用磁盘当内存，速度慢但还勉强能用。</p>
<h4 id="一-添加SWAP空间"><a href="#一-添加SWAP空间" class="headerlink" title="一.添加SWAP空间"></a>一.添加SWAP空间</h4><p>使用dd命令创建名为swapfile 的swap交换文件（文件名和目录任意）:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1.  dd  <span class="attribute">if</span>=/dev/zero  <span class="attribute">of</span>=/var/swapfile  <span class="attribute">bs</span>=1024  <span class="attribute">count</span>=2097152  </span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">   dd  <span class="attribute">if</span>=/dev/zero  <span class="attribute">of</span>=/var/swapfile  <span class="attribute">bs</span>=1024  <span class="attribute">count</span>=2048k</span><br><span class="line">[root@aliyun ~]# dd  <span class="attribute">if</span>=/dev/zero  <span class="attribute">of</span>=/var/swapfile  <span class="attribute">bs</span>=1024  <span class="attribute">count</span>=2048k</span><br><span class="line">记录了2097152+0 的读入</span><br><span class="line">记录了2097152+0 的写出</span><br><span class="line">2147483648字节(2.1 GB)已复制，31.7458 秒，67.6 MB/秒</span><br></pre></td></tr></table></figure>

<blockquote>
<p>科普：if(即输入文件,input file)，of(即输出文件,output file)。dev/zero是Linux的一种特殊字符设备(输入设备)，可以用来创建一个指定长度用于初始化的空文件，如临时交换文件，该设备无穷尽地提供0，可以提供任何你需要的数目。 bs=1024 ：单位数据块（block）同时读入/输出的块字节大小为1024 个字节即1KB，bs(即block size)。count=2048000 ：数据块（block）数量为2048000 ，即2048000个1KB。可以计算swap分区的容量为：1KB <em>2097152=1KB *1024(k)*1024</em>2=2097152=2G。（dd命令里的单位M表示1024*1024,k表示1024）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回车后，会执行2g的读写操作，系统会卡一段时间，耐心等待执行结果。</span><br></pre></td></tr></table></figure>

<p>执行完毕，对交换文件格式化并转换为swap分区：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  mkswap  <span class="regexp">/var/</span>swapfile  </span><br><span class="line">[root@aliyun ~]# mkswap <span class="regexp">/var/</span>swapfile</span><br><span class="line">正在设置交换空间版本 <span class="number">1</span>，大小 = <span class="number">2097148</span> KiB</span><br><span class="line">无标签，UUID=f88182d5-<span class="number">1155</span>-<span class="number">4</span>cf4-<span class="number">8</span>cb9-<span class="number">5</span>db460d9ac4e</span><br></pre></td></tr></table></figure>

<p>挂载并激活分区：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  swapon   <span class="regexp">/var/</span>swapfile  </span><br><span class="line">[root@aliyun ~]# swapon <span class="regexp">/var/</span>swapfile</span><br><span class="line">swapon: <span class="regexp">/var/</span>swapfile：不安全的权限 <span class="number">0644</span>，建议使用 <span class="number">0600</span>。</span><br></pre></td></tr></table></figure>

<p>执行以上命令可能会出现：“不安全的权限 0644，建议使用 0600”类似提示，不要紧张，实际上已经激活了，可以忽略提示，也可以听从系统的建议修改下权限：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  chmod -R <span class="number">0600</span> <span class="regexp">/var/</span>swapfile  </span><br></pre></td></tr></table></figure>

<p>这时候可以用 free –h 或 swapon –s命令查看新swap分区是否正常添加并激活使用。</p>
<p>修改 fstab 配置，设置开机自动挂载该分区：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  vim    <span class="regexp">/etc/</span>fstab  </span><br></pre></td></tr></table></figure>

<p>在fstab文件末尾追加如下内容后:wq!保存即可：<br>/var/swapfile swap swap defaults 0 0<br>或直接对fstab进行echo追加:</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  echo  <span class="string">&quot;/var/swapfile   swap  swap  defaults  0  0&quot;</span> &gt;&gt;  <span class="regexp">/etc/</span>fstab  </span><br></pre></td></tr></table></figure>

<h4 id="二-删除某swap分区"><a href="#二-删除某swap分区" class="headerlink" title="二. 删除某swap分区"></a>二. 删除某swap分区</h4><p>先停止正在使用swap分区：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  swapoff  <span class="regexp">/var/</span>swapfile  </span><br></pre></td></tr></table></figure>

<p>删除swap分区文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  rm -rf   <span class="regexp">/var/</span>swapfile  </span><br></pre></td></tr></table></figure>

<p>删除或注释掉我们之前在fstab文件里追加的开机自动挂载配置内容：<br>/var/swapfile swap swap defaults 0 0</p>
<h1 id="————————————————–"><a href="#————————————————–" class="headerlink" title="————————————————–"></a>————————————————–</h1><h4 id="三-更改Swap配置（进阶级"><a href="#三-更改Swap配置（进阶级" class="headerlink" title="三. 更改Swap配置（进阶级)"></a>三. 更改Swap配置（进阶级)</h4><blockquote>
<p>swappiness值（0-100），系统对swap分区的依赖程度，越高则越倾向于使用swap分区。<br>当然，高度依赖swap会造成物理内存远未使用完，就使用swap分区，我们知道swap分区性能远不如物理内存，这反而降低了系统性能，违背了我们创建swap分区的初衷。<br>我们希望在物理内存即将满荷时再使用swap，这就决定了swappiness值一般为10-60为宜，固态硬盘可以偏高些。<br>查看当前的swappiness数值：</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  cat   <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>swappiness   </span><br></pre></td></tr></table></figure>

<p>修改swappiness值，这里以50为例。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1.  sysctl vm.<span class="attribute">swappiness</span>=50   </span><br></pre></td></tr></table></figure>

<p>若希望vm.swappiness=50永久生效，则需要修改sysctl配置文件，直接echo追加配置内容，重启系统后即可生效：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  echo <span class="string">&quot;vm.swappiness = 50&quot;</span>  &gt;&gt;  <span class="regexp">/etc/</span>sysctl.conf</span><br></pre></td></tr></table></figure>

<h1 id="————————————————–-1"><a href="#————————————————–-1" class="headerlink" title="————————————————–"></a>————————————————–</h1><h4 id="四-增加-扩大-swap分区大小"><a href="#四-增加-扩大-swap分区大小" class="headerlink" title="四. 增加(扩大)swap分区大小"></a>四. 增加(扩大)swap分区大小</h4><ol>
<li>首先我们来查看swap空间的大小</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># free -m</span></span><br><span class="line">             <span class="string">total</span>       <span class="string">used</span>       <span class="string">free</span>     <span class="string">shared</span>    <span class="string">buffers</span>     <span class="string">cached</span></span><br><span class="line"><span class="attr">Mem:</span>          <span class="number">2026       </span><span class="number">1931         </span><span class="number">95</span>          <span class="number">0</span>         <span class="number">15</span>       <span class="number">1789</span></span><br><span class="line"><span class="string">-/+</span> <span class="attr">buffers/cache:</span>        <span class="number">127</span>       <span class="number">1899</span></span><br><span class="line"><span class="attr">Swap:</span>         <span class="number">3074          </span><span class="number">2</span>       <span class="number">3071</span></span><br></pre></td></tr></table></figure>

<ol>
<li>用dd命令创建一个2G大小的文件（1024<em>1024</em>2=2097152）</li>
</ol>
<p>dd if=/dev/zero of=/var/swapfile1 bs=1024 count=2097152</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# dd <span class="attribute">if</span>=/dev/zero <span class="attribute">of</span>=/var/swapfile1 <span class="attribute">bs</span>=1024 <span class="attribute">count</span>=2097152</span><br><span class="line">记录了2097152+0 的读入</span><br><span class="line">记录了2097152+0 的写出</span><br><span class="line">2147483648字节(2.1 GB)已复制，48.2387 秒，44.5 MB/秒</span><br></pre></td></tr></table></figure>

<ol>
<li>将该文件创建为linux swap</li>
</ol>
<p>mkswap /var/swapfile1</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# mkswap /var/swapfile1</span><br><span class="line">正在设置交换空间版本 1，大小 = 2097148 KiB</span><br><span class="line">无标签，UUID=43c47001<span class="string">-58</span>a3<span class="string">-43</span>ec<span class="string">-8510</span>-bc8b2ad2ff51</span><br></pre></td></tr></table></figure>

<ol>
<li>激活该文件</li>
</ol>
<p>swapon /var/swapfile1</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# swapon <span class="regexp">/var/</span>swapfile1</span><br><span class="line">swapon: <span class="regexp">/var/</span>swapfile1：不安全的权限 <span class="number">0644</span>，建议使用 <span class="number">0600</span>。</span><br></pre></td></tr></table></figure>

<ol>
<li><p>至此添加swap空间成功，但此时只要系统一重启就会丢失这个swap空间，所以我们要设置一下/etc/fstab文件，<br>在文件的末尾加上/var/swapfile1 swap swap defaults 0 0</p>
</li>
<li><p>查看大小 free -h</p>
</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]<span class="comment"># free -h</span></span><br><span class="line">              total        used        free      <span class="keyword">shared </span> <span class="keyword">buff/cache </span>  available</span><br><span class="line"><span class="symbol">Mem:</span>           <span class="number">1</span>.<span class="number">8</span>G        <span class="number">1</span>.<span class="number">1</span>G         <span class="number">73</span>M         <span class="number">22</span>M        <span class="number">606</span>M        <span class="number">496</span>M</span><br><span class="line"><span class="keyword">Swap: </span>         <span class="number">4</span>.<span class="number">0</span>G        <span class="number">1</span>.<span class="number">0</span>G        <span class="number">3</span>.<span class="number">0</span>G</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>环境安装</category>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式之Raft算法总结</title>
    <url>/2021/10/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRaft%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>Raft 协议是一个分布式共识(consensus)算法。</p>
<p>为了达到易于理解的目标，raft做了很多努力，其中最主要是两件事情：</p>
<ul>
<li>问题分解</li>
<li>状态简化（而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry））</li>
</ul>
<h3 id="1-问题分解"><a href="#1-问题分解" class="headerlink" title="1 问题分解"></a>1 问题分解</h3><p>Raft 协议将 consensus problem 划分为下面的几个子问题, 分别提出对应的解决方案：</p>
<ul>
<li>Leader Election</li>
<li>Log Eeplication</li>
<li>Safety</li>
</ul>
<p>Raft 算法首先从集群所有节点中选举出一个 <strong>Leader</strong>, 其余节点称为 <strong>Follower</strong>, 由 Leader 来负责管理日志. Leader 负责处理用户的请求, 并将之转化为日志, 并复制到其他的节点上. 当 Leader 将日志复制到大多数节点时, 就能将之应用(apply)到状态机, 并将之 <em>commit</em>, 最后将结果返回给用户.</p>
<p>为了保证日志条目(log entry)的有序性, 算法将时间划分为不同的 <em>term</em>, term 是一个连续的单调递增的整数. 当节点中发生 Leader 选举时, term 加一, 当节点观察到比自身更大的 term 时, 切换到该 term. 同时, 每条日志具有一个 <em>index</em> 来唯一标记, index 同样单调递增, 新的日志的 index 大于旧的日志的 index. 算法中用 term 和 index 来标记日志.</p>
<p>原文链接：<a href="https://www.cnblogs.com/xybaby/p/10124083.html">https://www.cnblogs.com/xybaby/p/10124083.html</a></p>
]]></content>
      <categories>
        <category>基础概念</category>
        <category>分布式，Raft算法总结</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Macbook外接显示器需要注意的设置</title>
    <url>/2021/09/07/%E7%A1%AC%E4%BB%B6&amp;%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/MacBook%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>设备：MacBook Pro2018 A1989<br>系统：BigSur11.2.3<br>外接的显示器：Dell P2319H</p>
<h2 id="颜色问题"><a href="#颜色问题" class="headerlink" title="颜色问题"></a>颜色问题</h2><p>mac 会将外接显示器识别为TV，会用 YCbCr 色域来输出,我们需要使用脚本来为外接显示器生成强制RGB渲染的颜色描述文件，然后替换掉系统原有颜色描述文件，来使显示器用RGB模式显示。</p>
<span id="more"></span>
<p> 一、关闭系统保护</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">进入恢复模式，按下 <span class="keyword">Options</span> 开机，然后再按 Command + R；</span><br><span class="line">在恢复模式下的命令行输入：csrutil authenticated-root <span class="keyword">disable</span>，</span><br><span class="line">然后再重启；</span><br></pre></td></tr></table></figure>


<p>  二、生成DisplayVendorID文件夹</p>
<p>  下载 patch-edid.rb 这个文件到 mac 的Download 文件夹中。</p>
<pre><code> 打开终端，cd Downloads
</code></pre>
<p>​<br>       ruby patch-edid.rb</p>
<p>​<br>       运行patch-edid.rb脚本后，会产生一个DisplayVendorID-1xxx文件，xxx<br>       是编号，每台机器都有区别</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">重启后，打开终端，命令行输入</span><br><span class="line">sudo mount -o nobrowse -t apfs <span class="regexp">/dev/</span>disk1s5 <span class="regexp">/Users/</span>seven<span class="regexp">/Downloads/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>disk1s5 为 系统盘的设备名，打开磁盘工具，选择系统盘可以看到，如下图：<br>注意最后的 s 和之后的内容要截取掉，比如我的系统盘设备名为 disk1s5s1，则 diskNsM 为 disk1s5。</p>
<p>四、替换<br>由于挂载到了下载文件夹，挂载好后，进入下载文件夹，就会进入到系统根目录了，我们把配置文件夹复制到相应的系统目录/System/Library/Displays/Contents/Resources/Overrides。 (替换掉这个 DisplayVendorID-5e3 文件夹 )<br>五、重新启用系统保护<br>然后需要重建系统 snapshot，使用到的命令为</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo bless --folder <span class="regexp">/Users/</span>seven<span class="regexp">/Downloads/</span>System<span class="regexp">/Library/</span>CoreServices --bootefi --create-snapshot</span><br></pre></td></tr></table></figure>

<p>六、重新启用系统保护</p>
<pre><code>在第一步中，我们禁用了系统保护，这是很危险的。完成第三步操作后，可以参照第一步的做法，将csrutil disable改为csrutil enable即可。
</code></pre>
<p>重启生效    </p>
<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>苹果只有在4k或以上的显示器中才会默认开启HiDPI，可以下载RDM软件解决</p>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/shennongminblog/article/details/76361751">https://blog.csdn.net/shennongminblog/article/details/76361751</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/81151642">https://zhuanlan.zhihu.com/p/81151642</a></li>
<li><a href="https://www.jianshu.com/p/e81792941358">https://www.jianshu.com/p/e81792941358</a></li>
<li><a href="https://www.douban.com/note/799863659/">https://www.douban.com/note/799863659/</a></li>
<li><a href="https://www.douban.com/group/topic/116080001/">https://www.douban.com/group/topic/116080001/</a></li>
<li><a href="https://github.com/xzhih/one-key-hidpi/blob/master/README-zh.md">https://github.com/xzhih/one-key-hidpi/blob/master/README-zh.md</a></li>
</ul>
<p>附：<br>LR和PS色彩空间可设置为proRGB，导出时转换为sRGB</p>
<ul>
<li><a href="http://www.360doc.com/content/17/1230/11/636843_717618369.shtml">http://www.360doc.com/content/17/1230/11/636843_717618369.shtml</a></li>
<li><a href="https://www.bilibili.com/video/av459133097/">https://www.bilibili.com/video/av459133097/</a></li>
</ul>
<p>20210902更新：<br>一切都是浮云，直接换成DP接口转typec的线，原生支持。</p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos下docker模式下安装nextcloud私有云盘服务</title>
    <url>/2021/09/07/%E7%A1%AC%E4%BB%B6&amp;%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Centos%E4%B8%8Bdocker%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%AE%89%E8%A3%85nextcloud%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>主机信息：阿里云ECS</p>
<p>CPU&amp;内存：1核2 GiB </p>
<p>磁盘：100G</p>
<p>操作系统：CentOS 8.4 64位</p>
</blockquote>
<h2 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1.docker安装"></a>1.docker安装</h2><p>使用官方安装脚本自动安装<br>安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p> 启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>



<p>查看docker相关版本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">版本信息</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta">#</span><span class="bash">查找nextcloud版本</span></span><br><span class="line">docker search nextcloud</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-拉取nextcloud官方镜像"><a href="#2-拉取nextcloud官方镜像" class="headerlink" title="2.拉取nextcloud官方镜像"></a>2.拉取nextcloud官方镜像</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull docker nextcloud</span></span><br></pre></td></tr></table></figure>



<p>接下来可以启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name nextcloud -p 8888:80 -v /root/nextcloud:/data nextcloud</span><br></pre></td></tr></table></figure>

<p>#docker run –name nextcloud -p 8080:80  -v /data/nextcloud:/var/www/html/data -d nextcloud</p>
<blockquote>
<p>注意在阿里云控制台 》配置安全组规则》入方方向开放端口</p>
</blockquote>
]]></content>
      <categories>
        <category>环境安装</category>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nextcloud阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>PMP备考系列_7-9章笔记</title>
    <url>/2021/09/07/pmp/PMP7-9/</url>
    <content><![CDATA[<h1 id="7-项目成本管理"><a href="#7-项目成本管理" class="headerlink" title="7 项目成本管理"></a>7 项目成本管理</h1><p>项目成本管理过程包括：</p>
<h2 id="7-1-规划成本管理"><a href="#7-1-规划成本管理" class="headerlink" title="7.1 规划成本管理"></a><strong>7.1 规划成本管理</strong></h2><p>— 确定如何估算、预算、管理、监督和控制项目成本的过程。</p>
<ul>
<li>绩效测量规则。需要规定用于绩效测量的挣值管理（EVM）规则。例如，成本管理计划应该：<ul>
<li>定义 WBS 中用于绩效测量的控制账户； </li>
<li>确定拟用的 EVM 技术（如加权里程碑法、固定公式法、完成百分比法等）；</li>
<li> 规定跟踪方法，以及用于计算项目完工估算（EAC）的 EVM 公式，该公式计算出的结果可用 于验证通过自下而上方法得出的完工估算。</li>
</ul>
</li>
</ul>
<h2 id="7-2-估算成本"><a href="#7-2-估算成本" class="headerlink" title="7.2 估算成本"></a>7.2 估算成本</h2><p> — 对完成项目活动所需货币资源进行近似估算的过程。 </p>
<p>进行成本估算，应该考虑将向项目收费的全部资源，包括（但不限于）人工、材料、设备、 服务、设施，以及一些特殊的成本种类，如通货膨胀补贴、融资成本或<strong>应急成本</strong>。</p>
<h4 id="7-2-2-2-类比估算"><a href="#7-2-2-2-类比估算" class="headerlink" title="7.2.2.2 类比估算"></a>7.2.2.2 类比估算</h4><p> 见 6.4.2.2 节。成本类比估算使用以往类似项目的参数值或属性来估算。项目的参数值和属性包 括（但不限于）范围、成本、预算、持续时间和规模指标（如尺寸、重量），类比估算以这些项目 参数值或属性为基础来估算当前项目的同类参数或指标。  </p>
<h4 id="7-2-2-3-参数估算"><a href="#7-2-2-3-参数估算" class="headerlink" title="7.2.2.3 参数估算"></a>7.2.2.3 参数估算</h4><p>见 6.4.2.3 节。参数估算是指利用历史数据之间的统计关系和其他变量（如建筑施工中的平方英 尺），来进行项目工作的成本估算，参数估算的准确性取决于参数模型的成熟度和基础数据的可靠 性。参数估算可以针对整个项目或项目中的某个部分，并可与其他估算方法联合使用。</p>
<h4 id="7-2-2-4-自下而上估算"><a href="#7-2-2-4-自下而上估算" class="headerlink" title="7.2.2.4 自下而上估算"></a>7.2.2.4 自下而上估算</h4><p>见 6.4.2.5 节。自下而上估算是对工作组成部分进行估算的一种方法。首先对单个工作包或活动的 成本进行最具体、细致的估算，然后把这些细节性成本向上汇总或“滚动”到更高层次，用于后续 报告和跟踪。自下而上估算的准确性及其本身所需的成本，通常取决于单个活动或工作包的规模或 其他属性。 </p>
<h4 id="7-2-2-5-三点估算"><a href="#7-2-2-5-三点估算" class="headerlink" title="7.2.2.5 三点估算"></a>7.2.2.5 三点估算</h4><p>见 6.4.2.4 节。通过考虑估算中的不确定性与风险，使用三种估算值来界定活动成本的近似区间， 可以提高单点成本估算的准确性： uu 最可能成本（cM）。对所需进行的工作和相关费用进行比较现实的估算，所得到的活动成本。 uu 最乐观成本（cO）。基于活动的最好情况所得到的成本。 uu 最悲观成本（cP）。基于活动的最差情况所得到的成本。</p>
<p>基于活动成本在三种估算值区间内的假定分布情况，使用公式来计算预期成本（cE）。两种常用 的公式是三角分布和贝塔分布，其计算公式分别为： </p>
<ul>
<li><p>三角分布。cE = (cO + cM + cP) / 3 </p>
</li>
<li><p> <strong>贝塔分布</strong>（默认使用）。cE = (cO + 4cM + cP) / 6 </p>
</li>
</ul>
<p>  基于三点的假定分布计算出期望成本，并说明期望成本的不确定区间</p>
<h2 id="7-3-制定预算"><a href="#7-3-制定预算" class="headerlink" title="7.3 制定预算"></a><strong>7.3 制定预算</strong></h2><p>— 汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准的过程。 </p>
<h2 id="7-4-控制成本"><a href="#7-4-控制成本" class="headerlink" title="7.4 控制成本"></a><strong>7.4 控制成本</strong></h2><p> — 监督项目状态，以更新项目成本和管理成本基准变更的过程。</p>
<p>对成本的影响力在项目早期最大，因此尽早定义范围就至关重要。</p>
<blockquote>
<p> 项目成本管理的<strong>核心概念</strong>。</p>
</blockquote>
<p>项目成本管理重点关注完成项目活动所需资源的成本，但同时也应考虑项目决策对项目产品、 服务或成果的使用成本、维护成本和支持成本的影响。</p>
<blockquote>
<p> 项目成本管理的趋势和新兴实践</p>
</blockquote>
<p>在项目成本管理的实践中，通过对<strong>挣值管理 (EVM)<strong>的扩展，引入</strong>挣得进度 (ES)</strong> 这一概念。</p>
<h2 id="挣值管理（Earned-Value-Management-EVM）"><a href="#挣值管理（Earned-Value-Management-EVM）" class="headerlink" title="挣值管理（Earned Value Management, EVM）"></a>挣值管理（Earned Value Management, EVM）</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>1.<strong>计划价值（Planned Value, PV）</strong>，截止到某时间点计划要完成工作量的价值，也就是计划要做多少事；</p>
<p><strong>2.挣值（Earned Value, EV）</strong>，截止到某时间点实际已经完成工作量的价值，也就是实际做了多少事；</p>
<p><strong>3.实际成本（Actual Cost, AC）</strong>，截止到某时间点实际已经发生的成本，也就是实际花了多少钱；</p>
<p><strong>4.完工预算（Budget At Completion, BAC）</strong>，对完成该项目的计划预算，也就是完成整个项目计划多少预算；</p>
<blockquote>
<p>例：假设我们现在要做一个项目，就是砌一堵长度为100米的围墙，为了方便计算我们假设总的预算是100元每米，共100*100=10000元，我们还计划项目工时10天（每天砌墙10米）来完成这个项目。</p>
<p>本来第四天工作结束计划完成40米，计划价值PV=4000。</p>
<p>实际第四天工作结束实际才完成了30米，挣值EV=3000。</p>
<p>第四天结束实际却花了5000元，实际成本AC=5000。</p>
<p>总的预算10000元，完工预算BAC=10000。</p>
</blockquote>
<h3 id="绩效指标"><a href="#绩效指标" class="headerlink" title="绩效指标"></a>绩效指标</h3><p>5.<strong>成本偏差（Cost Variance, CV）</strong>，截止到某时点发生的实际成本与计划成本的偏差，<strong>CV=EV(挣值)-AC(实际成本)</strong></p>
<p>6.<strong>进度偏差（Schedule Variance, SV）</strong>，截止到某时点的实际进度与计划进度的偏差，<strong>SV=EV(挣值)-PV(计划价值)</strong></p>
<p>7.<strong>成本绩效指数（Cost Performance Index, CPI）</strong>，截止到某时点衡量成本绩效的一种指标，也就是实际每花一元钱，完成做了多少钱的事（花钱的效率），<strong>CPI=EV(挣值)/AC(实际成本)</strong></p>
<p>8.<strong>进度绩效指数（Schedule Performance Index, SPI）</strong>，截止到某时点衡量进度绩效的一种指标，也就是实际完成的工作量与计划完成工作量之比，**SPI=EV(挣值)/PV(计划价值)**。</p>
<blockquote>
<p>成本偏差CV = EV - AC=3000-5000=-2000，说明现在成本超支了2000。</p>
<p>进度偏差SV = EV - PV=3000-4000=-1000,意思是相比计划我们的进度落后1000元的工作量。</p>
<p><strong>成本绩效指数CPI = EV / AC=3000/5000=0.6</strong>，意思是前面4天我们实际花了5000元，但是只做了3000元的工作，相当于前面4天我们每花1元钱，只做了0.6元的事，此概念计算要掌握。</p>
<p>SPI=EV/PV=3000/4000=0.75，说明当前只完成了计划任务量的75%的工作。</p>
</blockquote>
<h3 id="预测指标"><a href="#预测指标" class="headerlink" title="预测指标"></a>预测指标</h3><ol start="9">
<li><strong>完工尚需估算（Estimate To Completion, ETC）</strong><ul>
<li>如果还是以当前的成本绩效完成剩余的工作，则 <strong>ETC=(BAC-EV)/CPI</strong>，也就是剩余的工作量除以成本绩效指数；</li>
<li>如果以计划的成本绩效完成剩余的工作，则<strong>ETC=BAC-EV</strong>，也就是剩余的工作量，实际上也是用第一种情况那个公式(<strong>CPI=1</strong>)；</li>
<li>如果进度绩效指标SPI也会影响完成剩余工作的成本，意思是如果严格规定我们必须要在计划的截止时间之前完成项目，那么可能就还需要额外的成本来赶工进度，这个时候就需要同时考虑CPI和SPI对于剩余工作的影响，一般计算公式则为**ETC=(BAC-EV)/(CPI*SPI)*<em>，也就是剩余的工作量除以成本绩效指数与进度绩效指数的乘积；其中CPI</em>SPI又叫“关键比率”(Critical Ratio, CR);</li>
</ul>
</li>
</ol>
<p>10.<strong>完工估算（Estimate At Completion, EAC）</strong>，在某个时点，预测完成整个项目需要的成本，当然就是实际已经花掉的成本加上前面那个完工尚需估算ETC，<strong>EAC=AC+ETC</strong>；如果剩余工作还是<strong>以当前成本绩效指数</strong>来完成，那么也可以这么计算<strong>EAC=BAC/CPI</strong>，这个公式也好理解，其实就是整个项目工作量除以成本绩效指数；完工估算EAC实际上就是预测项目完工时候的实际成本AC。</p>
<p>11.<strong>完工尚需绩效指数（To-Complete Performance Index, TCPI）</strong>，在某个时点，预测如果要在计划的预算内完成项目，则未来的工作必须要达到的绩效水平。计算公式TCPI=(BAC-EV)/(BAC-AC)，也就是剩余的工作量除以剩余的钱的数量；</p>
<p>12.<strong>完工偏差（Variance At Completion, VAC）</strong>，在某个时点，预测项目在完工的时候将会出现的总的项目的成本偏差。计算公式VAC=BAC-EAC，也就是项目开始时原计划的预算减去现在预测的总个项目将会花的成本。完工偏差VAC实际上就是预测项目完工时的成本偏差CV。</p>
<blockquote>
<p>第一种情况：后续部分工作CPI和前面4天工作的CPI保持一致。</p>
<p>完工尚需估算ETC = （10000 - 3000）/ 0.6 = 11667，现在只完成了30米，那么剩下当然就是还需要砌70米了，转化成钱的数量70*100=7000元这就是剩余的工作量。</p>
<p>完工成本估算就是5000+11667=16667。CPI一直保持稳定不管前面4天还是后面工作一直都是0.6，所以也可以用总的项目预算（总的工作量）除以CPI得出，也就是10000/0.6=16667。</p>
<p>那么后面工作的成本绩效必须得是多少才行，这个就是TCPI。第四天结束后总共10000元的工作量，完成了3000元剩余7000元的工作量，实际花了5000元（预算就还剩10000-5000=5000元），也就是未来如果预算不增加我们需要以剩下5000元的预算来完成剩下7000元的工作，那么需要的成本绩效指数就是TCPI = 7000/5000=1.4。</p>
<p>我们前面已经算出来ETC=11667，EAC=16667，这个情况下完工偏差VAC=BAC-EAC=10000-16667=-6667</p>
</blockquote>
]]></content>
      <categories>
        <category>PMP</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title>PMP备考系列_4-6章笔记</title>
    <url>/2021/09/07/pmp/PMP4-6/</url>
    <content><![CDATA[<h1 id="4-项目整合管理"><a href="#4-项目整合管理" class="headerlink" title="4.项目整合管理"></a>4.项目整合管理</h1><p>项目整合管理包括对隶属于项目管理过程组的各种过程和项目管理活动进行识别、定义、组合、统一和协调的各个过程。<br><br>在项目管理中，整合兼具统一、合并、沟通和建立联系的性质，这些行动<br>应该贯穿项目始终。<br></p>
<blockquote>
<p>项目整合管理的核心概念</p>
</blockquote>
<ul>
<li>项目整合管理由项目经理负责。</li>
<li><strong>项目整合管理的责任不能被授权或转移</strong>。只能由项目经理负责整<br>合所有其他知识领域的成果，并掌握项目总体情况。</li>
<li>项目经理必须对整个项目承担最终责任。</li>
</ul>
<span id="more"></span>
<blockquote>
<p>项目整合管理的发展趋势和新兴实践</p>
</blockquote>
<ul>
<li>项目整合管理知识领域要求整合所有其他知识领域的成果。</li>
</ul>
<blockquote>
<p>在敏捷或适应型环境中需要考虑的因素</p>
</blockquote>
<ul>
<li>迭代和敏捷方法能够促进团队成员以相关领域专家的身份参与整合管理。团队成员自行决定计划<br>及其组件的整合方式</li>
<li>在适应型环境下，《整合管理的核心概念》中所述的对项目经理的期望保持不变，但把对具体产品的规划和交付授权给团队来控制。(服务型项目经理)</li>
</ul>
<h2 id="4-1制定项目章程"><a href="#4-1制定项目章程" class="headerlink" title="4.1制定项目章程"></a>4.1制定项目章程</h2><ul>
<li><strong>定义</strong>：是编写一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件的过程。</li>
<li><strong>作用</strong> ：明确项目与组织战略目标之间的直接联系，确立项目的正式地位，并展示组织对项目的承诺。</li>
</ul>
<p>项目章程一旦被批准，就标志着项目的正式启动。在项目中，应尽早确认并任命项目经理，最好在制定项目章程时就任命，且总应在规划开始之前任命。项目章程可由发起人编制，或者由项目经理与发起机构合作编制。<br><br>项目章程授权项目经理规划、执行和控制项目。<br><br>尽早任命项目经理，发起人合作编制项目章程 授权项目经理。<br><br>项目启动者或发起人应该具有一定的职权，能为项目获取资金并提供资源。<br><br>不要把项目章程看作合同，因为其中未承诺报酬或金钱或用于交换的对价。<br></p>
<ul>
<li>项目由项目以外的机构启动。</li>
<li>项目启动者有职权为项目获取资金提供资源。</li>
<li>项目章程不是合同<h3 id="4-1-1-制定项目章程：输入"><a href="#4-1-1-制定项目章程：输入" class="headerlink" title="4.1.1 制定项目章程：输入"></a>4.1.1 制定项目章程：输入</h3><h4 id="4-1-1-1-商业文件"><a href="#4-1-1-1-商业文件" class="headerlink" title="4.1.1.1 商业文件"></a>4.1.1.1 商业文件</h4></li>
<li>商业文件需要定期审核<br></li>
</ul>
<p><strong>商业论证</strong>从商业视角描述必要的信息，并且据此决定项目的期望结果是否值得所需投资。高于项目级别的经理和高管们通常使用该文件作为<strong>决策的依据</strong>。一般情况下，商业论证会包含<strong>商业需求和成本效益分析</strong></p>
<h4 id="4-1-1-2-协议"><a href="#4-1-1-2-协议" class="headerlink" title="4.1.1.2 协议"></a>4.1.1.2 协议</h4><p>协议用于定义启动项目的初衷。</p>
<h3 id="4-1-2-制定项目章程：工具与技术"><a href="#4-1-2-制定项目章程：工具与技术" class="headerlink" title="4.1.2 制定项目章程：工具与技术"></a>4.1.2 制定项目章程：工具与技术</h3><h4 id="4-1-2-1-专家判断"><a href="#4-1-2-1-专家判断" class="headerlink" title="4.1.2.1 专家判断"></a>4.1.2.1 专家判断</h4><ul>
<li>人人都可以是专家<h4 id="4-1-2-2-数据收集"><a href="#4-1-2-2-数据收集" class="headerlink" title="4.1.2.2 数据收集"></a>4.1.2.2 数据收集</h4></li>
<li><strong>头脑风暴</strong>。本技术用于在短时间内获得大量创意，适用于团队环境，需要引导者进行引导。头脑风暴由两个部分构成：创意产生和创意分析（<strong>收集信息时不要分析</strong>）。</li>
</ul>
<h2 id="4-2制定项目管理计划"><a href="#4-2制定项目管理计划" class="headerlink" title="4.2制定项目管理计划"></a>4.2制定项目管理计划</h2><p><strong>定义</strong>：是定义、准备和协调项目计划的所有组成部分，并把它们整合为一份综合项目管理计划的过程。<br><br><strong>作用</strong>：生成一份综合文件，用于确定所有项目工作的基础及其执行方式，<strong>它仅开展一次或仅在项目的预定义点开展</strong>。<br><br>项目管理计划<strong>确定</strong>项目的<strong>执行、监控和收尾方式</strong>。<br><br>项目管理计划应<strong>基准化</strong>，即，至少应规定项目的<strong>范围、时间和成本</strong>方面的基准，以便据此考核项目执行情况和管理项目绩效。在确定基准之前，可能要对项目管理计划进行<strong>多次更新</strong>，且这些更新无需遵循正式流程。</p>
<h3 id="4-2-1-制定项目管理计划：输入"><a href="#4-2-1-制定项目管理计划：输入" class="headerlink" title="4.2.1 制定项目管理计划：输入"></a>4.2.1 制定项目管理计划：输入</h3><h4 id="4-2-1-1-项目章程"><a href="#4-2-1-1-项目章程" class="headerlink" title="4.2.1.1 项目章程"></a>4.2.1.1 项目章程</h4><ul>
<li>项目章程=初始项目规划的起始点。<h4 id="4-2-2-4-会议"><a href="#4-2-2-4-会议" class="headerlink" title="4.2.2.4 会议"></a>4.2.2.4 会议</h4></li>
</ul>
<p><strong>项目开工会议</strong>通常意味着规划阶段结束和执行阶段开始。</p>
<h3 id="4-2-3-制定项目管理计划：输出"><a href="#4-2-3-制定项目管理计划：输出" class="headerlink" title="4.2.3 制定项目管理计划：输出"></a>4.2.3 制定项目管理计划：输出</h3><h4 id="4-2-3-1-项目管理计划"><a href="#4-2-3-1-项目管理计划" class="headerlink" title="4.2.3.1 项目管理计划"></a>4.2.3.1 项目管理计划</h4><p>项目管理计划是说明项目执行、监控和收尾方式的一份文件，它整合并综合了所有子管理计划和基准，以及管理项目所需的其他信息。<br><img src="/2021/09/07/pmp/PMP4-6/4.2.jpg" alt="制定项目管理计划"></p>
<h2 id="4-3-指导与管理项目工作"><a href="#4-3-指导与管理项目工作" class="headerlink" title="4.3 指导与管理项目工作"></a>4.3 指导与管理项目工作</h2><p>指导与管理项目工作是为实现项目目标而<strong>领导和执行项目管理计划</strong>中所确定的工作，并实施<strong>已批准变更</strong>的过程。<br><br>本过程的主要<strong>作用</strong>是，对项目工作和可交付成果开展<strong>综合管理</strong>，以<strong>提高</strong>项目<strong>成功的可能性</strong>。<br><img src="/2021/09/07/pmp/PMP4-6/4-6.jpg" alt="制定项目管理计划"></p>
<ul>
<li>指导与管理项目工作包括执行计划的项目活动，以完成项目可交付成果并达成既定目标。</li>
<li>指导与管理项目工作还要求回顾所有项目变更的影响，并实施已批准的<strong>变更，包括纠正措施、预防措施和（或）缺陷补救</strong>。<br></li>
</ul>
<p><strong>收集工作绩效数据</strong>并传达给合适的控制过程做进一步分析。</p>
<h4 id="4-3-1-3-批准的变更请求"><a href="#4-3-1-3-批准的变更请求" class="headerlink" title="4.3.1.3 批准的变更请求"></a>4.3.1.3 批准的变更请求</h4><p>批准的变更请求是实施整体变更控制过程的输出，包括经项目经理审查和批准的变更请求，必要时可经变更**控制委员会 **(CCB) 审查和批准。</p>
<h3 id="4-3-3-指导与管理项目工作：输出"><a href="#4-3-3-指导与管理项目工作：输出" class="headerlink" title="4.3.3 指导与管理项目工作：输出"></a>4.3.3 指导与管理项目工作：输出</h3><h4 id="4-3-3-1-可交付成果"><a href="#4-3-3-1-可交付成果" class="headerlink" title="4.3.3.1 可交付成果"></a>4.3.3.1 可交付成果</h4><p>可交付成果是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、成果或服务能力。</p>
<h4 id="4-3-3-2-工作绩效数据"><a href="#4-3-3-2-工作绩效数据" class="headerlink" title="4.3.3.2 工作绩效数据"></a>4.3.3.2 工作绩效数据</h4><p>工作绩效数据是在执行项目工作的过程中，从每个正在执行的活动中收集到的原始观察结果和测量值。</p>
<h4 id="4-3-3-4-变更请求"><a href="#4-3-3-4-变更请求" class="headerlink" title="4.3.3.4 变更请求"></a>4.3.3.4 变更请求</h4><p>变更请求是关于修改任何文件、可交付成果或基准的正式提议。</p>
<h2 id="4-4-管理项目知识"><a href="#4-4-管理项目知识" class="headerlink" title="4.4 管理项目知识"></a>4.4 管理项目知识</h2><ul>
<li><p><strong>定义</strong>：管理项目知识是使用现有知识并生成新知识，以实现项目目标，并且帮助组织学习的过程。</p>
</li>
<li><p>本过程的主要<strong>作用</strong>是，利用已有的组织知识来创造或改进项目成果，并且使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。</p>
</li>
<li><p>知识通常分为“<strong>显性知识</strong>”（易使用文字、图片和数字进行编撰的知识）和“<strong>隐性知识</strong>”（个体知识以及难以明确表达的知识，如信念、洞察力、经验和“诀窍”）两种。</p>
</li>
<li><p>关键活动是<strong>知识分享</strong>和<strong>知识集成</strong>（不同领域的知识、情境知识和项目管理知识）。</p>
<ul>
<li>显性知识缺乏情景易于分享。</li>
<li>隐性知识蕴含情景很难编撰。<ul>
<li>所以，知识管理最重要的环节就是营造一种相互信任的氛围，激励人<br>们分享知识或关注他人的知识。</li>
</ul>
</li>
</ul>
</li>
<li><p>在实践中，联合使用知识管理工具和技术（用于人际互动）以及信息<br>管理工具和技术（用于编撰显性知识）来分享知识</p>
</li>
</ul>
<h4 id="4-4-2-3-信息管理"><a href="#4-4-2-3-信息管理" class="headerlink" title="4.4.2.3 信息管理"></a>4.4.2.3 信息管理</h4><p>知识和信息管理工具与技术应与项目过程和过程责任人相对应。</p>
<h3 id="4-4-3-管理项目知识：输出"><a href="#4-4-3-管理项目知识：输出" class="headerlink" title="4.4.3 管理项目知识：输出"></a>4.4.3 管理项目知识：输出</h3><h4 id="4-4-3-1-经验教训登记册"><a href="#4-4-3-1-经验教训登记册" class="headerlink" title="4.4.3.1 经验教训登记册"></a>4.4.3.1 经验教训登记册</h4><p>经验教训登记册可以包含情况的类别和描述，经验教训登记册还可包括与情况相关的影响、建议和行动方案。</p>
<h2 id="4-5-监控项目工作"><a href="#4-5-监控项目工作" class="headerlink" title="4.5 监控项目工作"></a>4.5 监控项目工作</h2><ul>
<li>监控项目工作是跟踪、审查和报告整体项目进展，以实现项目管理计划中确定的绩效目标的过程。</li>
<li>本过程的主要作用是，<strong>让相关方了解项目的当前状态并认可</strong>为处理绩效问题而采取的行动，以及通过成本和进度预测，<strong>让相关方了解未来项目状态</strong>。<h3 id="4-5-1-监控项目工作：输入"><a href="#4-5-1-监控项目工作：输入" class="headerlink" title="4.5.1 监控项目工作：输入"></a>4.5.1 监控项目工作：输入</h3><h4 id="4-5-1-3-工作绩效信息"><a href="#4-5-1-3-工作绩效信息" class="headerlink" title="4.5.1.3 工作绩效信息"></a>4.5.1.3 工作绩效信息</h4>在工作<strong>执行过程</strong>中<strong>收集工作绩效数据</strong>，再交由<strong>控制过程做进一步分析</strong>。<br><br>项目期间通过控制过程收集绩效数据，与计划和其他变量比较，为工作绩效提供背景。<br><h3 id="4-5-3-监控项目工作：输出"><a href="#4-5-3-监控项目工作：输出" class="headerlink" title="4.5.3 监控项目工作：输出"></a>4.5.3 监控项目工作：输出</h3><h4 id="4-5-3-1-工作绩效报告"><a href="#4-5-3-1-工作绩效报告" class="headerlink" title="4.5.3.1 工作绩效报告"></a>4.5.3.1 工作绩效报告</h4></li>
<li>基于工作绩效信息，以实体或电子形式编制工作绩效报告，以制定决策、采取行动或引起关注。</li>
<li>工作绩效报告的示例包括状态报告和进展报告。</li>
</ul>
<h2 id="4-6-实施整体变更控制"><a href="#4-6-实施整体变更控制" class="headerlink" title="4.6 实施整体变更控制"></a>4.6 实施整体变更控制</h2><ul>
<li>实施整体变更控制是审查所有变更请求、批准变更，管理对可交付成果、项目文件和项目管理计划的变更，并对变更处理结果进行沟通的过程。</li>
<li>主要作用是确保对项目中已记录在案的变更做综合评审。</li>
<li>实施整体变更控制过程贯穿项目始终，项目经理对此承担最终责任。</li>
<li>一旦确定了项目基准，就必须通过本过程来处理变更请求。</li>
<li>在批准变更之前，可能需要了解变更对进度的影响和对成本的影响。</li>
<li><strong>变更控制委员会（CCB）</strong>CCB是一个正式组成的团体，负责审查、评价、批准、推迟或否决项目变更，以及记录和传达变更处理决定</li>
</ul>
<h2 id="4-7-结束项目或阶段"><a href="#4-7-结束项目或阶段" class="headerlink" title="4.7 结束项目或阶段"></a>4.7 结束项目或阶段</h2><ul>
<li><p>结束项目或阶段是终结项目、阶段或合同的所有活动的过程。本过程的主要作用是，存档项目或阶段信息，完成计划的工作，释放组织团队资源以展开新的工作。</p>
<hr>
</li>
</ul>
<h1 id="5-项目范围管理"><a href="#5-项目范围管理" class="headerlink" title="5.项目范围管理"></a>5.项目范围管理</h1><p>项目范围管理包括确保项目<strong>做且只做所需</strong>的全部工作，以成功完成项目的各个过程。管理项目范围主要在于定义和控制哪些工作应该包括在项目内，哪些不应该包括在项目内。</p>
<blockquote>
<p>项目范围管理的核心概念<br><img src="/2021/09/07/pmp/PMP4-6/5-1.jpg" alt="制定项目管理计划"></p>
</blockquote>
<ul>
<li><strong>产品范围</strong>。某项产品、服务或成果所具有的特征和功能。<strong>决定了项目范围</strong>。</li>
<li><strong>项目范围</strong>。为交付具有规定特性与功能的产品、服务或成果而必须完成的工作。项目范围有时也包括产品范围。<strong>服务于产品范围</strong></li>
<li>预测型：项目开始对可交付成果定义，通过实施整体变更控制过程进行更新。</li>
<li>适应型：每次迭代开始定义可交付成果。</li>
<li>在每次迭代中，都会重复开展三个过程：收集需求、定义范围和创建 WBS。相反，在预测型项目中，这些过程在项目开始时开展，并在必要时<strong>通过实施整体变更控制过程进行更新</strong>。</li>
<li>在预测型项目中，经过批准的项目范围说明书、工作分解结构（WBS）和相应的 WBS 词典构成项目范围基准。</li>
<li>而采用适应型生命周期的项目，则使用未完项（包括产品需<br>求和用户故事）反映当前需求.</li>
<li>项目范围的完成情况是根据<strong>项目管理计划来衡量</strong>的，而产品范围的完成情况是根据<strong>产品需求来衡量的</strong>。</li>
<li>确认范围是正式验收已完成的项目可交付成果的过程。<br>控制质量过程-&gt; 核实的可交付成果 -&gt; 确认范围过程 -&gt; 验收的可交付成果<br></li>
</ul>
<p><img src="/2021/09/07/pmp/PMP4-6/5-2.jpg" alt="预测型和适应型生命周期之管理范围的对比"></p>
<p>如果项目已配备商业分析师，那么，与需求管理相关的活动便是该角色的职责。而项目经理则负责确保这些活动在项目管理计划有所安排，并且在预算内按时完成，同时能够创造价值。<br><br>项目经理与商业分析师之间应该是伙伴式合作关系。</p>
<h2 id="5-1-规划范围管理"><a href="#5-1-规划范围管理" class="headerlink" title="5.1 规划范围管理"></a>5.1 规划范围管理</h2><ul>
<li>定义：规划范围管理是为记录如何定义、确认和控制项目范围及产品范围，而创建范围管理计划的过程。</li>
<li>作用： 在整个项目期间对如何管理范围提供指南和方向。<br><br>范围管理计划是项目或项目集管理计划的组成部分，描述将如何定义、制定、监督、控制和确认项目范围。</li>
</ul>
<h2 id="5-2-收集需求"><a href="#5-2-收集需求" class="headerlink" title="5.2 收集需求"></a>5.2 收集需求</h2><p>收集需求是为实现目标而确定、记录并管理相关方的需要和需求的过程。</p>
<p>需求将成为工作分解结 构（WBS）的基础，也将成为成本、进度、质量和采购规划的基础。</p>
<h3 id="5-2-2-收集需求：工具与技术"><a href="#5-2-2-收集需求：工具与技术" class="headerlink" title="5.2.2 收集需求：工具与技术"></a>5.2.2 收集需求：工具与技术</h3><h4 id="5-2-2-2-数据收集"><a href="#5-2-2-2-数据收集" class="headerlink" title="5.2.2.2 数据收集"></a>5.2.2.2 数据收集</h4><ul>
<li><p><strong>头脑风暴</strong>- 多种创意</p>
</li>
<li><p><strong>访谈</strong>- 访谈也可用于获取机密信息。</p>
</li>
<li><p><strong>问卷调查</strong> 问卷调查方法 非常适用于以下情况：受众多样化，需要快速完成调查，受访者地理位置分散，并且适合开 展统计分析。</p>
</li>
<li><p><strong>标杆对照</strong> 标杆对照所采用的可 比组织可以是内部的，也可以是外部的。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="5-2-2-3-数据分析"><a href="#5-2-2-3-数据分析" class="headerlink" title="5.2.2.3 数据分析"></a>5.2.2.3 数据分析</h4></li>
</ul>
<p>文件分析包括审核和评 估任何相关的文件信息。</p>
<h4 id="5-2-2-6-人际关系与团队技能"><a href="#5-2-2-6-人际关系与团队技能" class="headerlink" title="5.2.2.6 人际关系与团队技能"></a>5.2.2.6 人际关系与团队技能</h4><ul>
<li><p>名义小组技术：名义小组技术是一种结构化的头脑风暴形式</p>
</li>
<li><p>观察和交谈：当产品使用者<strong>难以或不愿清晰说明他们的需求</strong>时，就特别需要通过观察来了解他们的 工作细节。</p>
</li>
<li><p>引导：引导与主题研讨会结合使用。</p>
</li>
<li><h4 id="5-2-2-7-系统交互图"><a href="#5-2-2-7-系统交互图" class="headerlink" title="5.2.2.7 系统交互图"></a>5.2.2.7 系统交互图</h4></li>
</ul>
<p>系统交互图是范围模型的一个例子，<strong>它是对产品范围的可视化描绘</strong>。</p>
<h4 id="5-2-2-8-原型法"><a href="#5-2-2-8-原型法" class="headerlink" title="5.2.2.8 原型法"></a>5.2.2.8 原型法</h4><p>原型法是指在实际制造预期产品之前，先造出该产品的模型，并据此征求对需求的早期反馈。</p>
<p>故事板是一种原型技术，通过一系列的图像或图示来展示顺序或导航路径。</p>
<h3 id="5-2-3-收集需求：输出"><a href="#5-2-3-收集需求：输出" class="headerlink" title="5.2.3 收集需求：输出"></a>5.2.3 收集需求：输出</h3><h4 id="5-2-3-1-需求文件"><a href="#5-2-3-1-需求文件" class="headerlink" title="5.2.3.1 需求文件"></a>5.2.3.1 需求文件</h4><p>需求文件描述各种单一需求将如何满足与项目相关的业务需求。</p>
<p>只有明确的（可测量和可测试的）、可跟踪的、完整 的、相互协调的，且主要相关方愿意认可的需求，才能作为基准。</p>
<h4 id="5-2-3-2-需求跟踪矩阵"><a href="#5-2-3-2-需求跟踪矩阵" class="headerlink" title="5.2.3.2 需求跟踪矩阵"></a>5.2.3.2 需求跟踪矩阵</h4><p>需求跟踪矩阵是把产品需求从其来源连接到能满足需求的可交付成果的一种表格。</p>
<h2 id="5-3-定义范围"><a href="#5-3-定义范围" class="headerlink" title="5.3 定义范围"></a>5.3 定义范围</h2><p>定义范围是制定项目和产品详细描述的过程。本过程的主要作用是，描述产品、服务或成果的边界和验收标准。</p>
<p>应根据项目启动过程中记载的主要可交付成果、假设条件和制约因素来编制详细的项目范围说明书。</p>
<h3 id="5-3-2-定义范围：工具与技术"><a href="#5-3-2-定义范围：工具与技术" class="headerlink" title="5.3.2 定义范围：工具与技术"></a>5.3.2 定义范围：工具与技术</h3><h4 id="5-3-2-3-决策"><a href="#5-3-2-3-决策" class="headerlink" title="5.3.2.3 决策"></a>5.3.2.3 决策</h4><p>见 5.1.2.2 节。可用于本过程的决策技术包括（但不限于）多标准决策分析。</p>
<h4 id="5-3-2-5-产品分析"><a href="#5-3-2-5-产品分析" class="headerlink" title="5.3.2.5 产品分析"></a>5.3.2.5 产品分析</h4><p>每个应用领域都有一种或几种普遍公认的方法，用以把高层级的产品或服务描述转变为有意义的 可交付成果。</p>
<h3 id="5-3-3-定义范围：输出"><a href="#5-3-3-定义范围：输出" class="headerlink" title="5.3.3 定义范围：输出"></a>5.3.3 定义范围：输出</h3><h4 id="5-3-3-1-项目范围说明书"><a href="#5-3-3-1-项目范围说明书" class="headerlink" title="5.3.3.1 项目范围说明书"></a>5.3.3.1 项目范围说明书</h4><p>作用：项目范围说明书使项目团队能进行更详细的规划，在执行过程中指导项目团队的工作，并为评价变 更请求或额外工作是否超过项目边界提供基准。</p>
<h2 id="5-4-创建-WBS"><a href="#5-4-创建-WBS" class="headerlink" title="5.4 创建 WBS"></a>5.4 创建 WBS</h2><p>创建工作分解结构（WBS）是把项目可交付成果和项目工作分解成较小、更易于管理的组件的过程。</p>
<p>WBS 最低层的组成部分称为工作包，其中包括计划的工作。工作包对相关活动进行归类，以便对 工作安排进度、进行估算、开展监督与控制。<strong>在“工作分解结构”这个词语中，“工作”是指作为 活动结果的工作产品或可交付成果，而不是活动本身</strong>。</p>
<h3 id="5-4-2-创建-WBS：工具与技术"><a href="#5-4-2-创建-WBS：工具与技术" class="headerlink" title="5.4.2 创建 WBS：工具与技术"></a>5.4.2 创建 WBS：工具与技术</h3><h4 id="5-4-2-2-分解"><a href="#5-4-2-2-分解" class="headerlink" title="5.4.2.2 分解"></a>5.4.2.2 分解</h4><p>如果采用敏捷方法，可以将长篇故事分解成用户故事。</p>
<p>要在未来远期才完成的可交付成果或组件，当前可能无法分解。项目管理团队因而通常需要等 待对该可交付成果或组成部分达成一致意见，才能够制定出 WBS 中的相应细节。这种技术有时称做 滚动式规划。</p>
<h2 id="5-5-确认范围"><a href="#5-5-确认范围" class="headerlink" title="5.5 确认范围"></a>5.5 确认范围</h2><ul>
<li>定义：确认范围是正式验收已完成的项目可交付成果的过程。</li>
</ul>
<h2 id="5-6-控制范围"><a href="#5-6-控制范围" class="headerlink" title="5.6 控制范围"></a>5.6 控制范围</h2><hr>
<h1 id="6-项目进度管理"><a href="#6-项目进度管理" class="headerlink" title="6.项目进度管理"></a>6.项目进度管理</h1><blockquote>
<p>项目进度管理的核心概念</p>
<p>项目进度计划提供详尽的计划，说明项目如何以及何时交付项目范围中定义的产品、服务和成 果，是一种用于沟通和管理相关方期望的工具，为<strong>绩效报告</strong>提供了<strong>依据</strong>。</p>
</blockquote>
<h2 id="6-1规划进度管理"><a href="#6-1规划进度管理" class="headerlink" title="6.1规划进度管理"></a>6.1规划进度管理</h2><p>定义：规划进度管理是为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档的过程。</p>
<p>主要作用：为如何在整个项目期间管理项目进度提供指南和方向。</p>
<p>本过程仅开展一次 或仅在项目的预定义点开展。</p>
<h2 id="6-2-定义活动"><a href="#6-2-定义活动" class="headerlink" title="6.2 定义活动"></a>6.2 定义活动</h2><p>定义活动是识别和记录为完成项目可交付成果而须采取的具体行动的过程。</p>
<p>本过程的主要作用 是，将工作包分解为进度活动，作为对项目工作进行进度估算、规划、执行、监督和控制的基础。 </p>
<p>本过程需要在整个项目期间开展。</p>
<h4 id="6-2-3-2-活动属性"><a href="#6-2-3-2-活动属性" class="headerlink" title="6.2.3.2 活动属性"></a>6.2.3.2 活动属性</h4><p>活动属性是指每项活动所具有的多重属性，用来扩充对活动的描述，活动属性随时间演进。</p>
<h2 id="6-3-排列活动顺序"><a href="#6-3-排列活动顺序" class="headerlink" title="6.3 排列活动顺序"></a>6.3 排列活动顺序</h2><p>主要作用是定义工作之间的 逻辑顺序，以便在既定的所有项目制约因素下获得<strong>最高的效率</strong>。</p>
<h2 id="6-4-估算活动持续时间"><a href="#6-4-估算活动持续时间" class="headerlink" title="6.4 估算活动持续时间"></a>6.4 估算活动持续时间</h2><blockquote>
<p>估算持续时间时需要考虑的其他因素:</p>
<ul>
<li> 收益递减规律</li>
<li> 资源数量</li>
<li> 技术进步</li>
<li>员工激励。项目经理还需要了解<strong>“学生综合征”（即拖延症）和帕金森定律</strong>，前者指出，人们 只有在最后一刻，即快到期限时才会全力以赴；后者指出，只要还有时间，工作就会不断扩 展，直到用完所有的时间。</li>
</ul>
</blockquote>
<h3 id="6-4-2-估算活动持续时间：工具与技术"><a href="#6-4-2-估算活动持续时间：工具与技术" class="headerlink" title="6.4.2 估算活动持续时间：工具与技术"></a>6.4.2 估算活动持续时间：工具与技术</h3><h4 id="6-4-2-2-类比估算"><a href="#6-4-2-2-类比估算" class="headerlink" title="6.4.2.2 类比估算"></a>6.4.2.2 类比估算</h4><p>类比估算是一种使用相似活动或项目的历史数据，来估算当前活动或项目的持续时间或成本的技术。</p>
<p><strong>在项目详细信息不足</strong>时，就经常使用类比估算来估算项目持续时间。</p>
<h4 id="6-4-2-3-参数估算"><a href="#6-4-2-3-参数估算" class="headerlink" title="6.4.2.3 参数估算"></a>6.4.2.3 参数估算</h4><p>参数估算是一种<strong>基于历史数据和项目参数</strong>，使用某种算法来计算成本或持续时间的估算技术。</p>
<p>参数估算的准确性取决于<strong>参数模型的成熟度和基础数据</strong>的可靠性。且参数进度估算可以针对整个 项目或项目中的某个部分，并可以与其他估算方法联合使用。</p>
<h4 id="6-4-2-4-三点估算"><a href="#6-4-2-4-三点估算" class="headerlink" title="6.4.2.4 三点估算"></a>6.4.2.4 三点估算</h4><ul>
<li><p> 最可能时间 (tM)</p>
</li>
<li><p>最乐观时间 (tO)</p>
</li>
<li><p>最悲观时间 (tP)</p>
<p>基于持续时间在三种估算值区间内的假定分布情况，可计算期望持续时间 tE。</p>
<p>一个常用公式为三 角分布：<strong>tE = (tO + tM + tP) / 3</strong></p>
<p><strong>贝塔分布</strong>：<strong>cE = (cO + 4cM + cP) / 6</strong> （7.2.2.5中成本估算中提及，<strong>默认使用贝塔分布</strong>）。</p>
</li>
</ul>
<h4 id="6-4-2-5-自下而上估算"><a href="#6-4-2-5-自下而上估算" class="headerlink" title="6.4.2.5 自下而上估算"></a>6.4.2.5 自下而上估算</h4><p>自下而上估算是一种估算项目持续时间或成本的方法，通过从下到上逐层汇总 WBS 组成部分的估 算而得到项目估算。如果无法以合理的可信度对活动持续时间进行估算，则应将活动中的工作进一 步细化，然后估算具体的持续时间，接着再汇总这些资源需求估算，得到每个活动的持续时间。</p>
<h4 id="6-4-2-6-数据分析"><a href="#6-4-2-6-数据分析" class="headerlink" title="6.4.2.6 数据分析"></a>6.4.2.6 数据分析</h4><ul>
<li>储备分析。<strong>应急储备是包含在进度基准</strong>中的一段持续时间。管理储备是为管理控制的目的而特别留出的项目预算，，用来应对项目范围中不可预见的工作。<strong>管理储备</strong>用来应对会影响项目的“未知-未 知”风险，<strong>它不包括在进度基准</strong>中，但属于项目总持续时间的一部分。</li>
</ul>
<h2 id="6-5-制定进度计划"><a href="#6-5-制定进度计划" class="headerlink" title="6.5 制定进度计划"></a>6.5 制定进度计划</h2><h3 id="6-5-2-制定进度计划：工具与技术"><a href="#6-5-2-制定进度计划：工具与技术" class="headerlink" title="6.5.2 制定进度计划：工具与技术"></a>6.5.2 制定进度计划：工具与技术</h3><h4 id="6-5-2-1-进度网络分析"><a href="#6-5-2-1-进度网络分析" class="headerlink" title="6.5.2.1 进度网络分析"></a>6.5.2.1 进度网络分析</h4><p>例如关键路径法（见  6.5.2.2 节）、资源优化技术（见 6.5.2.3 节）和建模技术（见 6.5.2.4 节）。</p>
<h4 id="6-5-2-2-关键路径法"><a href="#6-5-2-2-关键路径法" class="headerlink" title="6.5.2.2 关键路径法"></a>6.5.2.2 关键路径法</h4><p>关键路径法用于在进度模型中估算项目最短工期，确定逻辑网络路径的进度灵活性大小。这种进 度网络分析技术在<strong>不考虑任何资源限制</strong>的情况下，沿进度网络路径使用顺推与逆推法，计算出所有 活动的最早开始、最早结束、最晚开始和最晚法完成日期。</p>
<p><strong>自由浮动时间</strong>就是指在<strong>不延误任何紧后活动</strong>最早开始日期或不违反进度制约因素的前提下，某 进度活动可以推迟的时间量。</p>
<h2 id="6-6-控制进度"><a href="#6-6-控制进度" class="headerlink" title="6.6 控制进度"></a>6.6 控制进度</h2>]]></content>
      <categories>
        <category>PMP</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础提升_线程池</title>
    <url>/2021/09/07/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。<br><br>而线程池不允许使用Executors去创建，而要通过<strong>ThreadPoolExecutor</strong>方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活【消耗内存等】；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险，所以阿里巴巴java开发规范线程池首选ThreadPoolExcutor。<br></p>
<p>话虽如此但常见的Executor框架还是要有所了解。</p>
<span id="more"></span>
<h2 id="常见线程池以及使用"><a href="#常见线程池以及使用" class="headerlink" title="常见线程池以及使用"></a>常见线程池以及使用</h2><h3 id="1-newCacheThreadPool"><a href="#1-newCacheThreadPool" class="headerlink" title="1.newCacheThreadPool"></a>1.newCacheThreadPool</h3><p>Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个可缓存线程池</span></span><br><span class="line">        ExecutorService cachedThreadPool = <span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">CachedThreadPool()</span>;</span><br><span class="line">         cachedThreadPool.execute(<span class="literal">()</span> -&gt;&#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 打印正在执行的缓存线程信息</span></span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span></span><br><span class="line">                            + <span class="string">&quot;正在被执行&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2.newFixedThreadPool"></a>2.newFixedThreadPool</h3><p> Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。</p>
<h3 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3.newScheduledThreadPool"></a>3.newScheduledThreadPool</h3><p>Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行</p>
<h3 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4.newSingleThreadExecutor"></a>4.newSingleThreadExecutor</h3><p>Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="创建方式和主要参数解释"><a href="#创建方式和主要参数解释" class="headerlink" title="创建方式和主要参数解释"></a>创建方式和主要参数解释</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static final ThreadPoolExecutor THREADPOOL = <span class="keyword">new</span> <span class="constructor">ThreadPoolExecutor(<span class="params">int</span> <span class="params">corePoolSize</span>, <span class="params">int</span> <span class="params">maximumPoolSize</span>,<span class="params">long</span> <span class="params">keepAliveTime</span>, TimeUnit <span class="params">unit</span>,BlockingQueue&lt;Runnable&gt; <span class="params">workQueue</span>,RejectedExecutionHandler <span class="params">handler</span>)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>corePoolSize： 线程池维护线程的最少数量 （core : 核心）</li>
<li>maximumPoolSize： 线程池维护线程的最大数量</li>
<li>keepAliveTime：线程池维护线程所允许的空闲时间</li>
<li>unit：线程池维护线程所允许的空闲时间的单位</li>
<li>workQueue：线程池所使用的缓冲队列</li>
<li>handler：线程池对拒绝任务的处理策略</li>
</ol>
<h3 id="内部执行流程解释"><a href="#内部执行流程解释" class="headerlink" title="内部执行流程解释"></a>内部执行流程解释</h3><p>通过 execute(Runnable)方法被添加到线程池，任务就是一个 Runnable类型的对象，任务的执行方法就是 Runnable类型对象的run()方法。<br><br>当一个任务通过execute(Runnable)方法欲添加到线程池时：<br><br>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。<br><br>如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。<br><br>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。<br><br>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。<br><br>也就是：处理任务的优先级为：<br><br>核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。<br><br> 当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。<br></p>
<ul>
<li><p>unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。</p>
</li>
<li><p>workQueue常用的是：java.util.concurrent.ArrayBlockingQueue</p>
</li>
<li><p>handler有四个选择：<br><br>ThreadPoolExecutor.AbortPolicy()：抛出java.util.concurrent.RejectedExecutionException异常<br><br>ThreadPoolExecutor.CallerRunsPolicy(): 重试添加当前的任务，他会自动重复调用execute()方法<br><br>ThreadPoolExecutor.DiscardOldestPolicy(): 抛弃旧的任务<br><br>ThreadPoolExecutor.DiscardPolicy(): 抛弃当前的任务<br></p>
</li>
</ul>
<h3 id="如何配置线程池"><a href="#如何配置线程池" class="headerlink" title="如何配置线程池"></a>如何配置线程池</h3><ul>
<li><p>CPU密集型任务<br><br>尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。</p>
</li>
<li><p>IO密集型任务<br><br>可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。</p>
</li>
<li><p>混合型任务<br><br>可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。<br>因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。<br>因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p>
</li>
</ul>
<h3 id="execute-和submit-方法"><a href="#execute-和submit-方法" class="headerlink" title="execute()和submit()方法"></a>execute()和submit()方法</h3><p>1、execute()，执行一个任务，没有返回值。<br>2、submit()，提交一个线程任务，有返回值。<br>submit(Callable<T> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用（IntentService中有体现）。</T></p>
<p>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null。</p>
<p>Future.get方法会使取结果的线程进入阻塞状态，知道线程执行完成之后，唤醒取结果的线程，然后返回结果。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多线程</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2021/08/19/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>作用：</p>
<ol>
<li><strong>异步</strong>、</li>
<li><strong>削峰</strong>、</li>
<li><strong>解耦</strong></li>
</ol>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>比如一个流程下需要正常的业务处理，中间需要发送短信，扣减优惠卷等，可以生产消息进入队列，由短信系统，优惠卷系统异步处理，减少主业务逻辑链路，提升效率。</p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>异步，使用线程，线程池去做不是一样的么<br>线程，线程池代码需要固定，后续如果光是短信平台要改东西，主流程还要发布。消息队列可以实现解耦。</p>
<h2 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h2><p>服务器，Redis，MySQL各自的承受能力都不一样，你直接全部流量照单全收肯定有问题啊，直接就打挂了。</p>
<span id="more"></span>

<h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><p>系统重试等原因造成<br>解决方法：</p>
<ol>
<li>接口幂等 无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.请求的是相同的流水号的话，判断处理过的话 直接返回成功就行了。</li>
</ol>
<h1 id="消息顺序消费"><a href="#消息顺序消费" class="headerlink" title="消息顺序消费"></a>消息顺序消费</h1><p>要保证顺序消费，需要确保整个流程中有序：生产者生产有序，放入消息中间件中有序，消费者消费时有序。</p>
<p>一个topic下有多个队列，为了保证发送有序，RocketMQ提供了<strong>MessageQueueSelector</strong>队列选择机制<br>我们可使用<strong>Hash取模法</strong>，让同一个订单发送到<strong>同一个队列</strong>中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了<strong>发送有序</strong>。<br><strong>RocketMQ的topic内的队列机制</strong>,可以保证存储满足FIFO（First Input First Output 简单说就是指先进先出）。</p>
<p>剩下的只需要消费者顺序消费即可。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列_Rocketmq</title>
    <url>/2021/08/19/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8BRocketmq/</url>
    <content><![CDATA[<h1 id="主流消息队列选型"><a href="#主流消息队列选型" class="headerlink" title="主流消息队列选型"></a>主流消息队列选型</h1><table>
<thead>
<tr>
<th>维度</th>
<th>Kafka</th>
<th>RocketMQ</th>
<th>RabbitMQ</th>
<th>ActiveMQ</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>10万级</td>
<td>10万级</td>
<td>万级</td>
<td>万级</td>
</tr>
<tr>
<td>开发语言</td>
<td>Scala</td>
<td>Java</td>
<td>Erlang</td>
<td>Java</td>
</tr>
<tr>
<td>高可用</td>
<td>分布式架构</td>
<td>分布式架构</td>
<td>主从架构</td>
<td>主从架构</td>
</tr>
<tr>
<td>性能</td>
<td>ms级</td>
<td>ms级</td>
<td>us级</td>
<td>ms级</td>
</tr>
<tr>
<td>功能</td>
<td>只支持主要的MQ功能</td>
<td>顺序消息、事务消息等功能完善</td>
<td>并发强、性能好、延时低</td>
<td>成熟的社区产品、文档丰富</td>
</tr>
</tbody></table>
<ol>
<li>rocketmq主要为java开发，语言适配性好，</li>
<li>性能好，社区成熟。 </li>
<li>支持顺序消息，事务消息。</li>
<li>支持分布式架构</li>
</ol>
<span id="more"></span>

<h1 id="ROCKETMQ特点"><a href="#ROCKETMQ特点" class="headerlink" title="ROCKETMQ特点"></a>ROCKETMQ特点</h1><ol>
<li>支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型</li>
<li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li>
<li>支持拉（pull）和推（push）两种消息模式（其实push也是用轮询形式的pull实现）</li>
<li>单一队列百万消息的堆积能力</li>
<li>支持多种消息协议，如 JMS、MQTT 等</li>
<li>分布式高可用的部署架构,满足至少一次消息传递语义</li>
<li>提供 docker 镜像用于隔离测试和云集群部署</li>
<li>提供配置、指标和监控等功能丰富的 Dashboard</li>
</ol>
<h1 id="集群分布式原理"><a href="#集群分布式原理" class="headerlink" title="集群分布式原理"></a>集群分布式原理</h1><p>RocketMQ由<strong>NameServer</strong>注册中心集群、<strong>Producer</strong>生产者集群、<strong>Consumer</strong>消费者集群和若干<strong>Broker</strong>（RocketMQ进程）组成，它的架构原理是这样的：</p>
<ol>
<li>Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li>
<li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li>
<li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li>
</ol>
<h1 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h1><p>消息丢失分为3个点</p>
<ol>
<li><p><strong>生产者丢失</strong>，即消息没发送出去，也没有<strong>重试机制</strong>来确保发送<br><br> 解决方案：</p>
<ol>
<li>同步发送(几乎不会用) </li>
<li>异步发送时采用<strong>异步有回调</strong>的方式 （可以再加个本地消息表，MQ回调通知消息发送结果，对应更新数据库MQ发送状态，JOB轮询超过一定时间（时间根据业务配置）还未发送成功的消息去重试）</li>
</ol>
</li>
<li><p><strong>mq丢失</strong>，即mq未及时刷盘，然后宕机了，导致内存中未处理的消息丢了<br><br> RocketMQ分为同步刷盘和异步刷盘两种方式，可以通过<strong>设置为同步刷盘</strong>的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息。(对性能有损耗，需要根据具体业务逻辑设置)</p>
</li>
<li><p><strong>消费者丢失</strong>（消费者刚收到消息，此时服务器宕机，MQ认为消费者已经消费，不会重复发送消息，消息丢失。）</p>
</li>
</ol>
<p>  <strong>RocketMQ默认是需要消费者回复ack确认</strong>，而kafka需要手动开启配置关闭自动offset。<br><br>  消费方不返回ack确认，重发的机制根据MQ类型的不同发送时间间隔、次数都不尽相同，如果重试超过次数之后会进入死信队列，需要手工来处理了。（Kafka没有这些）  重发的机制可能需要<strong>业务代码支持幂等</strong>操作。</p>
<h1 id="顺序消息问题"><a href="#顺序消息问题" class="headerlink" title="顺序消息问题"></a>顺序消息问题</h1><p>RocketMQ发送消息的时候，消息发送默认是会采用轮询的方式发送到不通的queue（分区）。<br><br>而消费端消费的时候，是会分配到多个queue的，多个queue是同时拉取提交消费。<br><br>但是<strong>同一条queue里面，RocketMQ的确是能保证FIFO</strong>的。那么要做到顺序消息，应该怎么实现呢——把消息确保投递到同一条queue。<br><br>可以在生产者投递时指定<strong>MessageQueueSelector</strong>,比如使用取模运算，让相同模的投递到同一条queue。<br><br>接下来就要保证消费是顺序的就可以了，可以使用<strong>MessageListenerOrderly</strong></p>
<blockquote>
<p>rocketmq的顺序消息需要满足2点：<br>1.Producer端保证发送消息有序，且发送到同一个队列。<br>2.consumer端保证消费同一个队列。</p>
</blockquote>
<h2 id="如何保证消息不被重复消费"><a href="#如何保证消息不被重复消费" class="headerlink" title="如何保证消息不被重复消费"></a>如何保证消息不被重复消费</h2><p>分析：这个问题其实换一种问法就是，如何保证消息队列的<strong>幂等性</strong>？这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。</p>
<p>回答：先来说一下为什么会造成重复消费？<br>其实无论是哪种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。RocketMQ返回一个CONSUME_SUCCESS成功标志,简单说一下，就是<strong>每一个消息都有一个offset</strong>，让消息队列知道自己已经消费过了。</p>
<p><strong>那造成重复消费的原因？</strong>，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</p>
<p>如何解决？这个问题针对业务场景来答，分以下三种情况：</p>
<p>（1）比如，你拿到这个消息做数据库的insert操作，那就容易了，给这个消息做一个<strong>唯一的主键</strong>，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p>
<p>（2）再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算<strong>幂等</strong>操作。</p>
<p>（3）如果上面两种情况还不行，上大招。准备一个第三方介质，来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis.那消费者开始消费前，先去redis中查询有没有消费记录即可。</p>
<h1 id="Master和Slave之间是怎么同步数据的呢？"><a href="#Master和Slave之间是怎么同步数据的呢？" class="headerlink" title="Master和Slave之间是怎么同步数据的呢？"></a>Master和Slave之间是怎么同步数据的呢？</h1><p>而消息在master和slave之间的同步是根据raft协议来进行的：<br></p>
<ol>
<li>在broker收到消息后，会被标记为uncommitted状态</li>
<li>然后会把消息发送给所有的slave</li>
<li>slave在收到消息之后返回ack响应给master</li>
<li>master在收到超过半数的ack之后，把消息标记为committed</li>
<li>发送committed消息给所有slave，slave也修改状态为committed</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>Rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo框架总述</title>
    <url>/2021/08/19/%E6%A1%86%E6%9E%B6/dubbo/dubbo%E6%A1%86%E6%9E%B6%E6%80%BB%E8%BF%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>spring框架总述</title>
    <url>/2021/08/19/%E6%A1%86%E6%9E%B6/spring/spring/spring%E6%A1%86%E6%9E%B6%E6%80%BB%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-spring是什么"><a href="#1-spring是什么" class="headerlink" title="1.spring是什么"></a>1.spring是什么</h1><p>Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发<br>的复杂性而创建的。Spring 的核心是控制反转（<strong>IoC</strong>）和面向切面编程（<strong>AOP</strong>）。<br></p>
<hr>
<h2 id="2-IOC控制反转"><a href="#2-IOC控制反转" class="headerlink" title="2.IOC控制反转"></a>2.IOC控制反转</h2><p>控制反转（IoC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代<br>码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对<br>象控制权的转移，从程序代码本身反转到了外部容器。通过容器实现对象的创建，属性赋值，<br>依赖的管理。<br><br>spring对于IOC思想的具体实现就是：<strong>DI</strong>（依赖注入：DI(Dependency Injection)，程序代码不做定位查询，这些工作由容器自行完成。）</p>
<h3 id="DI具体用法和实现"><a href="#DI具体用法和实现" class="headerlink" title="DI具体用法和实现"></a>DI具体用法和实现</h3><h4 id="ApplicationContext-接口（容器）"><a href="#ApplicationContext-接口（容器）" class="headerlink" title="ApplicationContext 接口（容器）"></a>ApplicationContext 接口（容器）</h4><p>ApplicationContext 用于加载 Spring 的配置文件，在程序中充当“容器”的角色。其实现<br>类有：<strong>ClassPathXmlApplicationContext</strong>(常用)，FileSystemXmlApplicationContext。<br></p>
<ul>
<li>若 Spring 配置文件存放在项目的类路径下，则使用 ClassPathXmlApplicationContext 实现<br>类进行加载。</li>
<li>ApplicationContext 容器，会在容器对象初始化时，将其中的所有对象一次性全部装配好。<br>以后代码中若要使用到这些对象，只需从内存中直接获取即可。执行效率较高。但占用内存。<span id="more"></span></li>
</ul>
<h2 id="SpringIOC加载流程"><a href="#SpringIOC加载流程" class="headerlink" title="SpringIOC加载流程"></a>SpringIOC加载流程</h2><p><a href="https://javadoop.com/post/spring-ioc">IOC原理详解</a></p>
<p><img src="/2021/08/19/%E6%A1%86%E6%9E%B6/spring/spring/spring%E6%A1%86%E6%9E%B6%E6%80%BB%E8%BF%B0/spring-IOC.jpg" alt="spring-IOC"></p>
<p>其实总结起来IOC 总体来说有两处地方最重要：<strong>一个是创建 Bean 容器，一个是初始化 Bean</strong>。</p>
<ol>
<li><p>IOC是在Spring启动后<strong>初始化环境和上下文对象</strong>完成后开始执行的</p>
</li>
<li><p>首先是<strong>创建BeanFactory</strong>，并将它的<strong>引用交给ApplicationContext</strong>，<strong>解析xml</strong>中配置的<strong>Bean</strong>，将他们<strong>封装成BeanDefinition对象，并放入HashMap</strong>中</p>
</li>
</ol>
<blockquote>
<p>BeanDefinition对象中封装了IOC初始化需要用到的所有信息，例如全限定名，是否懒加载，注入的属性，作用域等等。</p>
</blockquote>
<ol start="3">
<li><p>准备BeanFactory对象，为他设置类加载器，以及设置一些Spring环境中的特殊类，在注入时直接可以返回，防止重复创建；手动添加了几个BeanFactoryPostProcessor后置处理器（注册监听器、Aware接口的回调）</p>
</li>
<li><p>BeanFactory对象创建完成，开始执行后置处理器，除了Spring中定义好的以外，可能还会有用户或者框架定义的BeanFactoryPostProcessor，如MyBatis专门用于注册Mapper接口的处理器。</p>
</li>
<li><p>至此Bean的初始化完成（还未实例化），注册BeanPostProcessor，执行Bean初始化完成的前置处理，这里也是可以自己拓展的点。</p>
</li>
<li><p>这里还会有一些国际化、事件监听器的注册处理不细说了。</p>
</li>
<li><p>接着进入重头戏，<strong>Bean的实例化</strong>。</p>
</li>
</ol>
<blockquote>
<ol>
<li>进行实例化前会有一系列的判断，懒加载、抽象类、AOP的切面类等等这些不会被实例化。</li>
<li><strong>处理FactoryBean</strong>，它和普通Bean不同的是，它的实现类是一个工厂类，Spring会调用定义的工厂类实例化对象，例如MyBatis的Mapper就是自定义了工厂类动态代理的生成对象。</li>
<li><strong>处理普通Bean</strong>，根据<strong>BeanDefinition对象</strong>中的全限定类名<strong>反射</strong>创建，然后注入它的属性，引用对象则为递归创建（循环引用问题，Spring都是按照先实例化后注入属性，实例化后会放入缓存中，如果遇到循环引用则会从缓存当中取出来，防止出现死循环）</li>
</ol>
</blockquote>
<ol start="8">
<li><p>Bean实例化全部完成后，调用BeanPostProcessor中的后置处理方法，这里可拓展。</p>
</li>
<li><p>发布Bean实例化完成事件，观察者模式的应用，监听器再做其他操作。</p>
</li>
</ol>
<h4 id="注入分类"><a href="#注入分类" class="headerlink" title="注入分类:"></a>注入分类:<br></h4><p>bean 实例在调用无参构造器创建对象后，就要对 bean 对象的属性进行初始化。初始化<br>是由容器自动完成的，称为注入。<br>根据注入方式的不同，常用的有两类：<strong>set 注入、构造注入</strong>。</p>
<ul>
<li>Set注入：其实就是直接设置要的值<ul>
<li>简单类型（设置property标签，通过value=”设置”）</li>
<li>引用类型 （设置property标签，通过ref=”设置”）</li>
</ul>
</li>
<li>构造注入：在构造调用者实例的同时，完成被调用者的实例化。即使用构造器设置依赖关系。<ul>
<li>设置<constructor-arg>标签 name=”指定参数名称” value=”设置” 。（可选index）</constructor-arg></li>
</ul>
</li>
</ul>
<h5 id="引用类型属性自动注入"><a href="#引用类型属性自动注入" class="headerlink" title="引用类型属性自动注入"></a>引用类型属性自动注入</h5><p>对于引用类型属性的注入，也可不在配置文件中显示的注入。可以通过为<bean>标签<br>设置 autowire 属性值，为引用类型属性进行隐式自动注入（默认是不自动注入引用类型属<br>性）。根据自动注入判断标准的不同，可以分为两种：<br><br>byName：根据名称自动注入<br><br>byType： 根据类型自动注入<br><br>直接在bean标签内加上   autowire=”byName”</bean></p>
<h4 id="为应用指定多个-Spring-配置文件"><a href="#为应用指定多个-Spring-配置文件" class="headerlink" title="为应用指定多个 Spring 配置文件"></a>为应用指定多个 Spring 配置文件</h4><p>在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变<br>得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将<br>Spring 配置文件分解成多个配置文件。<br>包含关系的配置文件：<br><br>多个配置文件中有一个总文件，总配置文件将各其它子文件通过<import>引入。在 Java<br>代码中只需要使用总配置文件对容器进行初始化即可。<br><br>也可使用通配符*。但，此时要求父配置文件名不能满足*所能匹配的格式，否则将出现<br>循环递归包含。<br></import></p>
<h3 id="基于注解的-DI"><a href="#基于注解的-DI" class="headerlink" title="基于注解的 DI"></a>基于注解的 DI</h3><p>对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 bean 实例。<br><br>Spring 中使用注解，需要在 Spring 配置文件中<strong>配置组件扫描器</strong>，用于在指定的基本包中扫描注解。<br>指定多个包的三种方式：<br><br>1)使用多个 context:component-scan 指定不同的包路<br><br>2)指定 base-package 的值使用分隔符<br><br>3)base-package 是指定到父包名<br></p>
<h5 id="注解方式声明bean"><a href="#注解方式声明bean" class="headerlink" title="注解方式声明bean"></a>注解方式声明bean</h5><ul>
<li>定义 Bean 的注解@Component</li>
<li>@Repository 用于对 DAO 实现类进行注解</li>
<li>@Service 用于对 Service 实现类进行注解</li>
<li>@Controller 用于对 Controller 实现类进行注解<br></li>
</ul>
<p>这三个注解与@Component 都可以创建对象，但这三个注解还有其他的含义：<br></p>
<p>@Service创建业务层对象，业务层对象可以加入事务功能，<br><br>@Controller 注解创建的对象可以作为处理器接收用户的请求。<br><br>@Repository，@Service，@Controller 是对@Component 注解的细化，标注不同层的对象。即持久层对象，业务层对象，控制层对象。<br></p>
<h3 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a><code>@Component</code> 和 <code>@Bean</code> 的区别</h3><ol>
<li>作用对象不同：**@Component <strong>注解作用于</strong>类<strong>，而 <strong>@Bean</strong> 注解作用于</strong>方法**、</li>
<li>@Component 通常是通过路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我们需要用它的时候还给我。</li>
<li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。</li>
</ol>
<h5 id="简单类型属性注入-Value"><a href="#简单类型属性注入-Value" class="headerlink" title="简单类型属性注入@Value"></a>简单类型属性注入@Value</h5><p>需要在属性上使用注解@Value，该注解的 value 属性用于指定要注入的值。<br>使用该注解完成属性注入时，类中无需 setter。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    @Value(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h4><h5 id="byType-自动注入-Autowired"><a href="#byType-自动注入-Autowired" class="headerlink" title="byType 自动注入@Autowired"></a>byType 自动注入@Autowired</h5><p>该注解<strong>默认使用按类型</strong>自动装配 Bean</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">	<span class="comment">/******/</span></span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> School school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="byName-自动注入-Autowired-与-Qualifier"><a href="#byName-自动注入-Autowired-与-Qualifier" class="headerlink" title="byName 自动注入@Autowired 与@Qualifier"></a>byName 自动注入@Autowired 与@Qualifier</h5><p>需要在引用属性上联合使用注解@Autowired 与@Qualifier。@Qualifier 的 value 属性用<br>于指定要匹配的 Bean 的 id 值。类中无需 set 方法，也可加到 set 方法上。<br><br>@Autowired 还有一个属性 required，默认值为 true，表示当匹配失败后，会终止程序运<br>行。若将其值设置为 false，则匹配失败，将被忽略，未匹配的属性值为 null。<br></p>
<h4 id="JDK-注解-Resource-自动注入"><a href="#JDK-注解-Resource-自动注入" class="headerlink" title="JDK 注解@Resource 自动注入"></a>JDK 注解@Resource 自动注入</h4><p>Spring提供了对 jdk中@Resource注解的支持。@Resource 注解既可以按名称匹配Bean，<br>也可以按类型匹配 Bean。默认是按名称注入。使用该注解，要求 JDK 必须是 6 及以上版本。<br>@Resource 可在属性上，也可在 set 方法上。<br></p>
<p><strong>@Resource</strong> 注解若不带任何参数，采用<strong>默认按名称的方式</strong>注入，按名称不能注入 bean，<br>则会按照类型进行 Bean 的匹配注入。</p>
<hr>
<h2 id="3-AOP面向切面编程"><a href="#3-AOP面向切面编程" class="headerlink" title="3.AOP面向切面编程"></a>3.AOP面向切面编程</h2><p>AOP（Aspect Orient Programming），面向切面编程。面向切面编程是从动态角度考虑程<br>序运行过程。<br><br>AOP 底层，就是采用动态代理模式实现的。采用了两种代理：</p>
<p><strong>JDK 的动态代理，与 CGLIB的动态代理。</strong><br></p>
<p>JDK动态代理，<strong>必须要实现接口</strong><br>    - 创建目标类<br>    - 创建<strong>InvocationHandler</strong>接口的实现类重写<strong>Invoke</strong>，在这个类实现给目标方法增加功能<br>    - 使用JDK中的类<strong>proxy</strong>，创建代理对象，实现创建对象的能力，在使用代理对象调用方法</p>
<p>CGLIB的动态代理，是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类，原理是继承，通过继承目标类生成代理类，只<strong>要求目标类不是final修饰</strong>的就行</p>
<h3 id="Aop术语"><a href="#Aop术语" class="headerlink" title="Aop术语"></a>Aop术语</h3><ol>
<li>切面（Aspect）<br><br> 切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面<br> 是通知（Advice）。实际就是对主业务逻辑的一种增强。</li>
<li>连接点（JoinPoint）<br><br> 连接点指可以被切面织入的具体方法。通常业务接口中的方法均为连接点。</li>
<li>切入点（Pointcut）<br><br> 切入点指声明的一个或多个连接点的集合。通过切入点指定一组方法。<br><br> 被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不<br> 能被增强的。我们通常使用明确的类和方法名称，或者是使用正则表达式定义所匹配的类和方法名称来指定切点。</li>
<li>目标对象（Target）<br><br> 目 标 对 象 指 将 要 被 增 强 的 对 象 。 即 包 含 主 业 务 逻 辑 的 类 的 对 象 。 上 例 中 的<br> StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，<br> 不被增强，也就无所谓目标不目标了。</li>
<li>通知（Advice）<br> 通知表示切面的执行时间，Advice 也叫增强。上例中的 MyInvocationHandler 就可以理<br> 解为是一种通知。换个角度来说，通知定义了增强代码切入到目标代码的时间点，是目标方<br> 法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。<br><br> <strong>切入点定义切入的位置，通知定义切入的时间</strong>。</li>
</ol>
<h4 id="AOP的主要实践-aspectj"><a href="#AOP的主要实践-aspectj" class="headerlink" title="AOP的主要实践 aspectj"></a>AOP的主要实践 aspectj</h4><p> aspectj有两种实现方式：<br><br> 1.使用xml配置<br> 2.使用注解（常用5个：@Before，@AfterReturning，**@Around**，@AfterThrowing，@After）</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
        <category>IOC&amp;AOP</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>Aop</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/2021/08/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/ZooKeeper/</url>
    <content><![CDATA[<h1 id="Zookeeper基础概念"><a href="#Zookeeper基础概念" class="headerlink" title="Zookeeper基础概念"></a>Zookeeper基础概念</h1><p>ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p>
<p>客户端的读请求可以被集群中的任意一台机器处理，<strong>如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理</strong>。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p>
<p>有序性是zookeeper中非常重要的一个特性，所有的更新都是<strong>全局有序</strong>的，每个更新都有一个<strong>唯一的时间戳</strong>，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。</p>
<h2 id="ZooKeeper提供了什么？"><a href="#ZooKeeper提供了什么？" class="headerlink" title="ZooKeeper提供了什么？"></a>ZooKeeper提供了什么？</h2><p>区别于Eureka专用于注册中心的功能，zookeeper主要提供的能力是</p>
<ul>
<li>文件系统</li>
<li>通知机制</li>
</ul>
<h2 id="Zookeeper文件系统"><a href="#Zookeeper文件系统" class="headerlink" title="Zookeeper文件系统"></a>Zookeeper文件系统</h2><ul>
<li>Zookeeper提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</li>
<li>Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，<strong>这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M</strong>。</li>
</ul>
<h2 id="ZAB协议？"><a href="#ZAB协议？" class="headerlink" title="ZAB协议？"></a>ZAB协议？</h2><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。</p>
<p>ZAB协议包括两种基本的模式：<strong>崩溃恢复和消息广播</strong>。</p>
<p>当整个zookeeper集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与Leader服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的Leader服务器，然后集群中Follower服务器开始与新的Leader服务器进行数据同步，当集群中超过半数机器与该Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p>
<h2 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h2><ul>
<li>PERSISTENT-持久节点<br>除非手动删除，否则节点一直存在于Zookeeper上</li>
<li>EPHEMERAL-临时节点<br>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</li>
<li>PERSISTENT_SEQUENTIAL-持久顺序节点<br>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li>
<li>EPHEMERAL_SEQUENTIAL-临时顺序节点<br>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li>
</ul>
<h2 id="Zookeeper-Watcher-机制-–-数据变更通知"><a href="#Zookeeper-Watcher-机制-–-数据变更通知" class="headerlink" title="Zookeeper Watcher 机制 – 数据变更通知"></a>Zookeeper Watcher 机制 – 数据变更通知</h2><p>Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。</p>
<p>工作机制：</p>
<ul>
<li>客户端注册watcher</li>
<li>服务端处理watcher</li>
<li>客户端回调watcher</li>
</ul>
<h2 id="Watcher特性总结："><a href="#Watcher特性总结：" class="headerlink" title="Watcher特性总结："></a>Watcher特性总结：</h2><ol>
<li>一次性<br>无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</li>
<li>客户端串行执行<br>客户端Watcher回调的过程是一个串行同步的过程。</li>
<li>轻量<ul>
<li>Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</li>
<li>客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。</li>
</ul>
</li>
<li>watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。</li>
<li>注册watcher getData、exists、getChildren</li>
<li>触发watcher create、delete、setData</li>
<li>当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。</li>
</ol>
<h2 id="ZooKeeper实现分布式锁原理"><a href="#ZooKeeper实现分布式锁原理" class="headerlink" title="ZooKeeper实现分布式锁原理"></a>ZooKeeper实现分布式锁原理</h2><p>其实如果有客户端C、客户端D等N个客户端争抢一个zk分布式锁，原理都是类似的。</p>
<ul>
<li>大家都是上来直接创建一个锁节点下的一个接一个的临时顺序节点</li>
<li>如果自己不是第一个节点，就对自己上一个节点加监听器</li>
<li>只要上一个节点释放锁，自己就排到前面去了，相当于是一个排队机制。</li>
</ul>
<p>而且用临时顺序节点的另外一个用意就是，如果某个客户端创建临时顺序节点之后，不小心自己宕机了也没关系，zk感知到那个客户端宕机，会自动删除对应的临时顺序节点，相当于自动释放锁，或者是自动取消自己的排队。</p>
]]></content>
      <categories>
        <category>基础概念</category>
        <category>分布式</category>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>ZooKeeper高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础_java1.8新特性</title>
    <url>/2021/08/19/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80_java1.8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h1><p>Lambda 允许把函数作为一个方法的参数（<strong>函数作为参数传递到方法中</strong>）。</p>
<h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><p>lambda 表达式的语法格式如下：</p>
<p>(parameters) -&gt; expression或(parameters) -&gt;{statements; }</p>
<h1 id="2-Java-8-方法引用"><a href="#2-Java-8-方法引用" class="headerlink" title="2.Java 8 方法引用"></a>2.Java 8 方法引用</h1><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>方法引用使用一对冒号 :: 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List names = <span class="keyword">new</span> ArrayList();</span><br><span class="line">names.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Baidu&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Sina&quot;</span>);</span><br><span class="line">names.forEach(System.out::println);</span><br></pre></td></tr></table></figure>





<h1 id="3-默认方法"><a href="#3-默认方法" class="headerlink" title="3.默认方法"></a>3.默认方法</h1><p>默认方法就是一个在接口里面有了一个实现的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一辆车!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-新工具"><a href="#4-新工具" class="headerlink" title="4.新工具"></a>4.新工具</h1><p>新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p>
<h1 id="5-Stream-API"><a href="#5-Stream-API" class="headerlink" title="5.Stream API"></a>5.Stream API</h1><h2 id="5-1概念理解"><a href="#5-1概念理解" class="headerlink" title="5.1概念理解"></a>5.1概念理解</h2><p>新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p>
<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream使用一种<strong>类似用SQL语句</strong>从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。</p>
<p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>这种风格<strong>将要处理的元素集合看作一种流</strong>，流在管道中传输，并且可以在管道的节点上进行处理，比如<strong>筛选，排序，聚合</strong>等。</p>
<p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<h2 id="5-2生成流"><a href="#5-2生成流" class="headerlink" title="5.2生成流"></a>5.2生成流</h2><p>在Java 8中,集合接口有两个方法来生成流：</p>
<p>stream() −为集合创建串行流。</p>
<p>parallelStream() − 为集合创建并行流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args) &#123;``  ``List&lt;String&gt; strings = Arrays.asList(``<span class="string">&quot;abc&quot;</span>``, ``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;bc&quot;</span>``, ``<span class="string">&quot;efg&quot;</span>``, ``<span class="string">&quot;abcd&quot;</span>``, ``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;jkl&quot;</span>``);``  ``List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());``&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-3-forEach"><a href="#5-3-forEach" class="headerlink" title="5.3  forEach"></a>5.3  forEach</h3><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = ``<span class="keyword">new</span>` `Random();``random.ints().limit(``<span class="number">10</span>``).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-4-map"><a href="#5-4-map" class="headerlink" title="5.4 map"></a>5.4 map</h3><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(``<span class="number">3</span>``, ``<span class="number">2</span>``, ``<span class="number">2</span>``, ``<span class="number">3</span>``, ``<span class="number">7</span>``, ``<span class="number">3</span>``, ``<span class="number">5</span>``);``<span class="comment">// 获取对应的平方数``List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());</span></span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-5-filter"><a href="#5-5-filter" class="headerlink" title="5.5 filter"></a>5.5 filter</h3><p>filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(``<span class="string">&quot;abc&quot;</span>``, ``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;bc&quot;</span>``, ``<span class="string">&quot;efg&quot;</span>``, ``<span class="string">&quot;abcd&quot;</span>``,``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;jkl&quot;</span>``);``<span class="comment">// 获取空字符串的数量``int` `count = (``int``) strings.stream().filter(string -&gt; string.isEmpty()).count();</span></span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-6-limit"><a href="#5-6-limit" class="headerlink" title="5.6 limit"></a>5.6 limit</h3><p>limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = ``<span class="keyword">new</span>` `Random();``random.ints().limit(``<span class="number">10</span>``).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-7-sorted"><a href="#5-7-sorted" class="headerlink" title="5.7 sorted"></a>5.7 sorted</h3><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = ``<span class="keyword">new</span>` `Random();``random.ints().limit(``<span class="number">10</span>``).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-8-并行（parallel）程序"><a href="#5-8-并行（parallel）程序" class="headerlink" title="5.8 并行（parallel）程序"></a>5.8 并行（parallel）程序</h3><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用parallelStream 来输出空字符串的数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(``<span class="string">&quot;abc&quot;</span>``, ``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;bc&quot;</span>``, ``<span class="string">&quot;efg&quot;</span>``, ``<span class="string">&quot;abcd&quot;</span>``, ``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;jkl&quot;</span>``);``<span class="comment">// 获取空字符串的数量``int` `count = (``int``) strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span></span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>我们可以很容易的在顺序运行和并行直接切换。</p>
<h3 id="5-9-Collectors"><a href="#5-9-Collectors" class="headerlink" title="5.9 Collectors"></a>5.9 Collectors</h3><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(``<span class="string">&quot;abc&quot;</span>``, ``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;bc&quot;</span>``, ``<span class="string">&quot;efg&quot;</span>``, ``<span class="string">&quot;abcd&quot;</span>``, ``<span class="string">&quot;&quot;</span>``, ``<span class="string">&quot;jkl&quot;</span>``);``List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());``System.out.println(``<span class="string">&quot;筛选列表: &quot;</span>` `+ filtered);``String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(``<span class="string">&quot;, &quot;</span>``));``System.out.println(``<span class="string">&quot;合并字符串: &quot;</span>` `+ mergedString);</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-10-统计"><a href="#5-10-统计" class="headerlink" title="5.10 统计"></a>5.10 统计</h3><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(``<span class="number">3</span>``, ``<span class="number">2</span>``, ``<span class="number">2</span>``, ``<span class="number">3</span>``, ``<span class="number">7</span>``, ``<span class="number">3</span>``, ``<span class="number">5</span>``);``IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();``System.out.println(``<span class="string">&quot;列表中最大的数 : &quot;</span>` `+ stats.getMax());``System.out.println(``<span class="string">&quot;列表中最小的数 : &quot;</span>` `+ stats.getMin());``System.out.println(``<span class="string">&quot;所有数之和 : &quot;</span>` `+ stats.getSum());``System.out.println(``<span class="string">&quot;平均数 : &quot;</span>` `+ stats.getAverage());</span><br></pre></td></tr></table></figure>





<h1 id="6-Date-Time-API"><a href="#6-Date-Time-API" class="headerlink" title="6.Date Time API"></a>6.Date Time API</h1><p>加强对日期与时间的处理。</p>
<h1 id="7-Optional-类"><a href="#7-Optional-类" class="headerlink" title="7.Optional 类"></a>7.Optional 类</h1><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional 类的引入很好的解决空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer value1 = <span class="keyword">null</span>;</span><br><span class="line">Integer value2 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// Optional.ofNullable - 允许传递为 null 参数</span></span><br><span class="line">Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line"><span class="comment">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span></span><br><span class="line">Optional&lt;Integer&gt; b = Optional.of(value2);</span><br></pre></td></tr></table></figure>



<h1 id="8-Nashorn-JavaScript-引擎"><a href="#8-Nashorn-JavaScript-引擎" class="headerlink" title="8.Nashorn JavaScript 引擎"></a>8.Nashorn JavaScript 引擎</h1><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p>
<p>参考：<a href="https://www.cnblogs.com/liuxiaozhi23/p/10880147.html">java8新特性详解及示例代码</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>jdk1.8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java1.8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础提升_多线程</title>
    <url>/2021/08/19/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ol>
<li>继承Thread类<ul>
<li>start()方法是一个 native 方法,它将启动一个新线程，并执行 run()方法。</li>
</ul>
</li>
<li>实现runnable接口，<ul>
<li>当一个类已经有继承了，此时可通过实现runnable接口来创建线程</li>
</ul>
</li>
<li>采用线程池，实现callable接口（有返回）,ExecutorService<ul>
<li><strong>有返回值</strong>的任务必须实现 Callable 接口。执行Callable 任务后，可以获取一个<strong>Future 的对象</strong>，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</li>
</ul>
</li>
</ol>
<h2 id="多线程中的主要问题"><a href="#多线程中的主要问题" class="headerlink" title="多线程中的主要问题"></a>多线程中的主要问题</h2><ol>
<li>可见性问题<br> volatile修饰，保证了多线程之间的内存可见性</li>
<li>原子性问题<br> AtomicInteger（Java中有那么一些类，是以Atomic开头的。这一系列的类我们称之为原子操作类。以最简单的类AtomicInteger为例。它相当于一个int变量，我们执行Int的 i++ 的时候并不是一个原子操作。而使用AtomicInteger的incrementAndGet却能保证原子操作）</li>
<li>有序性问题<br> volatile 防止指令重排序</li>
<li>死锁的问题</li>
</ol>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><ol>
<li><p>修饰一个<strong>代码块</strong>，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </p>
</li>
<li><p>修饰一个<strong>方法</strong>，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </p>
</li>
<li><p>修改一个<strong>静态的方法</strong>，其作用的范围是整个静态方法，作用的对象是这个==类的所有对象==； </p>
</li>
<li><p>修改一个<strong>类</strong>，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>
<span id="more"></span>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3></li>
<li><p>修饰代码块时：<br>synchronized是JVM层面的，同步语句块的实现使用的是<strong>monitorenter 和 monitorexit</strong>指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个<strong>Java对象的对象头</strong>中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因)</p>
</li>
<li><p>synchronized 修饰方法时：<br>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
</li>
</ol>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>作用：保证变量的可见性然后还有一个作用是防止指令重排序。</p>
<h3 id="synchronized关键字和volatile关键字比较"><a href="#synchronized关键字和volatile关键字比较" class="headerlink" title="synchronized关键字和volatile关键字比较"></a>synchronized关键字和volatile关键字比较</h3><ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是<strong>volatile关键字只能用于变量</strong>而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。<h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3>wait和notify这两个方法是一对，wait方法阻塞当前线程，而notify是唤醒被wait方法阻塞的线程。<br></li>
</ul>
<ol>
<li><p>wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</p>
</li>
<li><p>wait()使当前线程阻塞，前提是 必须先获得锁，一般配合synchronized 关键字使用，即，一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法。</p>
</li>
<li><p> 由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。<br><br>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。<br>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。<br>也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁</p>
</li>
<li><p>wait() 需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒。</p>
</li>
<li><p>notify 和wait 的顺序不能错，如果A线程先执行notify方法，B线程在执行wait方法，那么B线程是无法被唤醒的。</p>
</li>
<li><p>notify 和 notifyAll的区别<br>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程（<strong>不确定唤醒哪个</strong>），选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p>
</li>
<li><p>在多线程中要测试某个条件的变化，使用if 还是while？<br>　　要注意，notify唤醒沉睡的线程后，线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑；显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while进行等待，</p>
</li>
</ol>
<h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p>join() 定义在Thread.java中。<br>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。<br>注意：如果线程被生成了，但还未被起动，调用它的 join() 方法是没有作用的，将直接继续向下执行</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="type">Son</span> s = <span class="keyword">new</span> <span class="type">Son</span>();</span><br><span class="line">        s.start();</span><br><span class="line">        s.join();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子线程</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h2><p>作用：</p>
<ol>
<li>每个线程独立的变量 </li>
<li>可以贯穿整个线程的全局变量，避免参数传递</li>
</ol>
<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>如果我想共享线程的ThreadLocal数据怎么办？使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值，我们在主线程中创建一个InheritableThreadLocal的实例，然后在子线程中得到这个InheritableThreadLocal实例设置的值。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link Java基础提升_线程池 Java基础提升_线程池 %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化和集群高可用</title>
    <url>/2021/08/17/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ul>
<li>RDB做镜像全量持久化<br><br>是对 Redis 中的数据执行周期性的持久化。<br><ul>
<li>优点：<br><br>RDB对Redis的性能影响非常小，是因为在同步数据的时候他只是fork了一个子进程去做持久化的，<br>而且他在数据恢复的时候速度比AOF来的快。适合做快照之类的备份。<br></li>
<li>缺点：<br><br>RDB都是快照文件，生成时间间隔可能比较大（默认5分钟），可能丢失数据,<br>还有就是RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒.</li>
</ul>
</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul>
<li>AOF做增量持久化。<br><br>  AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog。<ul>
<li>优点：<br><br>可能丢失的数据少（1秒），<br><br>AOF日志可读性好，可对有问题的命令做修改.</li>
<li>缺点：<br><br>AOF文件体积较大。<br><br>AOF开启后，Redis支持写的QPS会比RDB支持写的要低</li>
</ul>
</li>
</ul>
<h3 id="总结：RDB和AOF配合使用"><a href="#总结：RDB和AOF配合使用" class="headerlink" title="总结：RDB和AOF配合使用"></a>总结：RDB和AOF配合使用</h3><p>因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<h4 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h4><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。</p>
<p>我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p>
<p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。</p>
<p>通过如下配置可以开启混合持久化(必须先开启aof)：</p>
<blockquote>
<p>#aof-use-rdb-preamble yes</p>
</blockquote>
<p>如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件</p>
<p>而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件</p>
<p>新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</p>
<p>于是在 Redis 重启的时候，可以 先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。</p>
<hr>
<h2 id="Redis集群高可用"><a href="#Redis集群高可用" class="headerlink" title="Redis集群高可用"></a>Redis集群高可用</h2><p>Redis的集群高可用方案常见的有3种：</p>
<ol>
<li>主从同步/复制</li>
<li>哨兵模式</li>
<li>Cluster 集群</li>
</ol>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ol>
<li>从服务器连接主服务器，发送SYNC命令； </li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（从服务器初始化完成）</li>
<li>主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（从服务器初始化完成后的操作）<h4 id="主从复制优缺点："><a href="#主从复制优缺点：" class="headerlink" title="主从复制优缺点："></a>主从复制优缺点：</h4>优点：</li>
</ol>
<ul>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离</li>
<li>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成</li>
<li>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。</li>
<li>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。</li>
<li>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据.<br>缺点：</li>
<li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ul>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。</p>
<p>哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。</p>
<ol>
<li>监控主服务器和从服务器是否正常运行。 </li>
<li>主服务器出现故障时自动将从服务器转换为主服务器。<br>哨兵组件的主要作用：</li>
</ol>
<ul>
<li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
</ul>
<p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p>
<h4 id="哨兵的工作方式："><a href="#哨兵的工作方式：" class="headerlink" title="哨兵的工作方式："></a>哨兵的工作方式：</h4><ol>
<li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</li>
<li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态</li>
<li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）</li>
<li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。<br>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。<br>哨兵模式的优缺点</li>
</ol>
<p>优点：</p>
<ul>
<li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li>
<li>主从可以自动切换，系统更健壮，可用性更高。<br><br>缺点：</li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ul>
<h4 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis-Cluster集群"></a>Redis-Cluster集群</h4><p>redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，同时主从模式还是不能很好<strong>解决过多的写</strong>（只有一个master写）所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。</p>
<p> Redis-Cluster采用无中心结构,它的特点如下：</p>
<p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</p>
<p>节点的fail是通过集群中超过半数的节点检测失效时才生效。</p>
<p>客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</p>
<h4 id="Redis-Cluster集群原理："><a href="#Redis-Cluster集群原理：" class="headerlink" title="Redis-Cluster集群原理："></a>Redis-Cluster集群原理：</h4><p>在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p>
<p>为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。</p>
<p>集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用Redis Sentinel。</p>
<p>参考：<a href="https://www.cnblogs.com/cqming/p/11191079.html">https://www.cnblogs.com/cqming/p/11191079.html</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>nosql</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础使用</title>
    <url>/2021/08/17/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis 使用的是客户端-服务器（CS）模型和请求/响应协议的 TCP 服务器。这意味着通常情况下一个请求会遵循以下步骤：</p>
<ol>
<li>客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ol>
<h2 id="Redis快的原因："><a href="#Redis快的原因：" class="headerlink" title="Redis快的原因："></a>Redis快的原因：</h2><p>1.redis是基于内存的，内存的读写速度非常快；</p>
<p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p>
<p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol>
<li>字符串String</li>
</ol>
<ul>
<li>这是最简单的类型，就是普通的 set 和 get，做简单的 KV （KEY-VALUE）缓存</li>
</ul>
<ol start="2">
<li>字典Hash、</li>
<li>列表List、 </li>
</ol>
<ul>
<li>比如可以通过 List存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</li>
</ul>
<ol start="4">
<li>集合Set、</li>
</ol>
<ul>
<li>是无序集合，会自动去重的那种</li>
</ul>
<ol start="5">
<li><p>有序集合SortedSet。</p>
</li>
<li><p><strong>补充</strong>：<br>HyperLogLog(也是set的规则，是用来做基数统计的算法，存储所占空间少，纯计数)<br><br>Geo、Pub/Sub</p>
</li>
<li><p><strong>进阶</strong>：Redis Module，像BloomFilter，RedisSearch，Redis-ML</p>
<span id="more"></span>
<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3></li>
<li><p>keys *   查询所有数据</p>
</li>
<li><p>exists key名   判断key名是否存在</p>
</li>
<li><p>move key名  数据库号（0-15）  移动数据key名到相应的数据库</p>
</li>
<li><p>expire key名 秒  过多少秒key名失效（删除）</p>
</li>
<li><p>ttl key名 查询key名还有多久过期  -1永不过期  -2已过期（或不存在）</p>
</li>
<li><p>type key名  判断key名是什么类型</p>
</li>
</ol>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol>
<li>set （添加）、 get （获取值）、del（删除） 、append（追加） 、strlen （获取长度）<br> 、<strong>SETNX</strong> key value<br> （只有在 key 不存在时设置 key 的值）。</li>
<li>incr （增加1）、decr（减少1） 、incrby（按多少增加） 、decrby （按多少减少）</li>
<li> setrang(命令用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始。)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET key1 &quot;Hello World&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; SETRANGE key1 6 &quot;Redis&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">redis 127.0.0.1:6379&gt; GET key1</span><br><span class="line">&quot;Hello Redis&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="List（单值多value）"><a href="#List（单值多value）" class="headerlink" title="List（单值多value）"></a>List（单值多value）</h3><ol>
<li>lpush （队列左先入栈）、 rpush（队列右先入栈） 、Larange</li>
<li>lpop（左出）、rpop（右出）注意：这里和开始进入的有关系，即：lpush 、rpush</li>
<li>lindex（按照索引下标元素获取值。从上到下）</li>
</ol>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ol>
<li><strong>HSET</strong> key field value(将哈希表 key 中的字段 field 的值设为 value ),<br></li>
</ol>
<p><strong>HGET</strong> key field  获取存储在哈希表中指定字段的值。<br><br><strong>HMSET</strong> key field1 value1 [field2 value2 ]同时将多个 field-value (域-值)对设置到哈希表 key 中,<br><br><strong>HMGET</strong> key field1 [field2] 获取多个给定字段的值<br><br><strong>HGETALL</strong> key 获取在哈希表中指定 key 的所有字段和值<br><br>2.     <strong>HDEL</strong> key field1 [field2] 删除一个或多个哈希表字段<br><br><strong>HVALS</strong> key 获取哈希表中所有值。<br>HGETALL key<br><br>HKEYS key 获取所有哈希表中的字段<br><br>HLEN key 获取哈希表中字段的数量<br></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ol>
<li>SADD key member1 [member2] 向集合添加一个或多个成员<br><br>SREM key member1 [member2] 移除集合中一个或多个成员<br><br>SCARD key 获取集合的成员数<br><h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3>ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数<h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">连接到本机的redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash">中文乱码时加raw</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli --raw</span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行 PING 命令，该命令用于检测 redis 服务是否启动。</span></span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line"><span class="meta">#</span><span class="bash">键命令</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SET runoobkey redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET runoobkey</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; DEL runoobkey</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">hash</span></span></span><br><span class="line">127.0.0.1:6379&gt;  HMSET runoobkey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;  HGETALL runoobkey</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;redis basic commands for caching&quot;</span><br><span class="line">5) &quot;likes&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;visitors&quot;</span><br><span class="line">8) &quot;23000&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="redis在java中的使用"><a href="#redis在java中的使用" class="headerlink" title="redis在java中的使用"></a>redis在java中的使用</h2><h2 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h2><ol>
<li>key :假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</li>
</ol>
<ul>
<li>使用keys指令可以扫出指定模式的key列表。</li>
<li>redis是单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</li>
</ul>
<ol start="2">
<li>Redis分布式锁</li>
</ol>
<ul>
<li>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</li>
<li>set 命令可以合并setnx和expire 保证原子性<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> key <span class="comment">value [EX seconds] [PX milliseconds] [NX</span>|<span class="comment">XX]</span></span><br><span class="line">EX <span class="comment">seconds</span>：设置失效时长，单位秒</span><br><span class="line">PX <span class="comment">milliseconds</span>：设置失效时长，单位毫秒</span><br><span class="line">NX：key不存在时设置value，成功返回OK，失败返回(nil)</span><br><span class="line">XX：key存在时设置value，成功返回OK，失败返回(nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">set</span> <span class="comment">name p7+ ex 100 nx</span></span><br><span class="line">OK</span><br><span class="line">&gt; get <span class="comment">name</span></span><br><span class="line"><span class="string">&quot;p7+&quot;</span></span><br><span class="line">&gt; ttl <span class="comment">name</span></span><br><span class="line">(integer) 94</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>Redis做异步队列</li>
</ol>
<ul>
<li>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep(list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。)一会再重试。</li>
<li>使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。</li>
<li>延时队列 : 使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</li>
</ul>
<p><a href="https://www.runoob.com/redis/redis-tutorial.html">参考链接</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>nosql</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC框架总述</title>
    <url>/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springmvc/springmvc%E6%80%BB%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h1><ul>
<li>M代表模型（Model）<br>模型其实就是数据，dao，bean</li>
<li>V代表视图（View）<br>网页，jsp等用来展示数据的模型</li>
<li>C代表Controller<br>把不同的数据展示在不同的视图上，处理请求的分发，Servlet扮演的就是这样的角色<br><img src="/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springmvc/springmvc%E6%80%BB%E8%BF%B0/model_view_controller.jpg" alt="MVC"></li>
</ul>
<h1 id="SpringMVC的流程"><a href="#SpringMVC的流程" class="headerlink" title="SpringMVC的流程"></a>SpringMVC的流程</h1><ol>
<li><p>用户发送请求至前端控制器DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler；</p>
</li>
<li><p>处理器映射器根据请求url找到具体的处理器Handler，生成处理器对象及处理器拦截器(如果有则生成)，一并返回给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet 调用 HandlerAdapter处理器适配器，请求执行Handler；</p>
</li>
<li><p>HandlerAdapter 经过适配调用 具体处理器进行处理业务逻辑；</p>
</li>
<li><p>Handler执行完成返回ModelAndView；</p>
</li>
<li><p>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</p>
</li>
<li><p>ViewResolver解析后返回具体View；</p>
</li>
<li><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</p>
</li>
<li><p>DispatcherServlet响应用户。</p>
</li>
</ol>
<span id="more"></span>

<h1 id="SpringMVC常用的注解有哪些？"><a href="#SpringMVC常用的注解有哪些？" class="headerlink" title="SpringMVC常用的注解有哪些？"></a>SpringMVC常用的注解有哪些？</h1><p><strong>@RequestMapping</strong>：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p><strong>@RequestBody</strong>：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p><strong>@ResponseBody</strong>：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<h2 id="SpingMvc中的控制器的注解一般用哪个？有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用哪个？有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用哪个？有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用哪个？有没有别的注解可以替代？</h2><p>答：一般用@Controller注解，也可以使用@RestController，@RestController注解相当于@ResponseBody ＋ @Controller，表示是表现层，除此之外，一般不用别的注解代替。</p>
<h2 id="SpringMvc里面拦截器是怎么写的："><a href="#SpringMvc里面拦截器是怎么写的：" class="headerlink" title="SpringMvc里面拦截器是怎么写的："></a>SpringMvc里面拦截器是怎么写的：</h2><p>有两种写法，一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h1><p>Servlet生命周期分为三个阶段：初始化阶段、响应客户请求阶段、终止阶段</p>
<ol>
<li><p>创建Servlet对象，通过服务器反射机制创建Servlet对象，第一次请求时才会创建。（<strong>默认</strong>）</p>
</li>
<li><p>调用Servlet对象的init()方法，初始化Servlet的信息，init()方法只会在创建后被调用一次（<strong>初始化阶段</strong>）</p>
</li>
<li><p>响应请求，调用service()或者是doGet()，doPost()方法来处理请求，这些方法是运行的在多线程状态下的。（<strong>响应客户请求阶段</strong>）</p>
</li>
<li><p> 在长时间没有被调用或者是服务器关闭时，会调用destroy()方法来销毁Servlet对象。（<strong>终止阶段</strong>）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud_五大组件</title>
    <url>/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springcloud/springcloud%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="SpringCloud进阶"><a href="#SpringCloud进阶" class="headerlink" title="SpringCloud进阶"></a>SpringCloud进阶</h2><ul>
<li><input checked disabled type="checkbox"> javase</li>
<li><input checked disabled type="checkbox"> 数据库</li>
<li>[] 前端</li>
<li>[] servlet</li>
<li>[] Http</li>
<li><input checked disabled type="checkbox"> Mybatis</li>
<li><input checked disabled type="checkbox"> Spring</li>
<li>[] SpringMVC</li>
<li>[] SpringBoot</li>
<li><input checked disabled type="checkbox"> Dubbo,zookeeper,分布式基础</li>
<li><input checked disabled type="checkbox"> maven</li>
</ul>
<blockquote>
<p>总结一下SpringCloud结果核心组件:</p>
</blockquote>
<ul>
<li><p>Eureka:个服务启动时,Eureka会将服务注册到EurekaService,并且EurakeClient还可以返回过来从EurekaService拉去注册表,从而知道服务在哪里</p>
</li>
<li><p>Ribbon:服务间发起请求的时候,基于Ribbon服务做到负载均衡,从一个服务的对台机器中选择一台</p>
<blockquote>
<p>目前，在Spring cloud 中服务之间通过restful方式调用有两种方式  </p>
<ul>
<li>restTemplate+Ribbon </li>
<li>feign</li>
</ul>
</blockquote>
</li>
<li><p>Feign:RPC框架，基于fegin的动态代理机制,根据注解和选择机器,拼接Url地址,发起请求,Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。</p>
</li>
<li><p>Hystrix:发起的请求是通过Hystrix的线程池来走,不同的服务走不同的线程池,实现了不同的服务调度隔离,避免服务雪崩的问题</p>
</li>
<li><p>Zuul:如果前端后端移动端调用后台系统,统一走zull网关进入,有zull网关转发请求给对应的服务</p>
</li>
<li><p>Apollo（阿波罗）是携程框架部门研发的配置管理平台，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。<a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1">Apollo配置中心设计</a></p>
</li>
</ul>
<h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>Ribbon 是一个基于 HTTP 和 TCP 客户端的负载均衡器</p>
<p>它可以在客户端配置 ribbonServerList（服务端列表），然后轮询请求以实现均衡负载</p>
<p>它在联合 Eureka 使用时</p>
<p>ribbonServerList 会被 DiscoveryEnabledNIWSServerList 重写，扩展成从 Eureka 注册中心获取服务端列表</p>
<p>同时它也会用 NIWSDiscoveryPing 来取代 IPing，它将职责委托给 Eureka 来确定服务端是否已经启动</p>
<h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><p>Spring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的，所以可以用 Apache 的 HttpClient 或 Spring 的 RestTemplate 去調用,而 Feign 是一個使用起來更加方便的 HTTP 客戶端，它用起來就好像調用本地方法一樣，完全感覺不到是調用的遠程方法</p>
<p>总结起来就是：发布到注册中心的服务方接口，是 HTTP 的，也可以不用 Ribbon 或者 Feign，直接浏览器一样能够访问</p>
<p>只不过 Ribbon 或者 Feign 调用起来要方便一些，最重要的是：它俩都支持软负载均衡</p>
<p>注意：spring-cloud-starter-feign 里面已经包含了 spring-cloud-starter-ribbon（Feign 中也使用了 Ribbon）</p>
<p>从实践上看，采用feign的方式更优雅（feign内部也使用了ribbon做负载均衡）。</p>
<h2 id="Spring-Cloud-和dubbo区别"><a href="#Spring-Cloud-和dubbo区别" class="headerlink" title="Spring Cloud 和dubbo区别?"></a>Spring Cloud 和dubbo区别?</h2><p>其实Dubbo仅仅是一个RPC框架，实现Java程序的远程调用，而Spring Cloud则是实施微服务的一系列套件，包括：服务注册与发现、断路器、服务状态监控、配置管理、智能路由、一次性令牌、全局锁、分布式会话管理、集群状态管理等</p>
<p>（1）服务调用方式 dubbo是RPC，springcloud是 Rest Api</p>
<p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</p>
<p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p>
<h2 id="常见的RPC组件："><a href="#常见的RPC组件：" class="headerlink" title="常见的RPC组件："></a>常见的RPC组件：</h2><ol>
<li>RMI（远程方法调用）</li>
</ol>
<p>JAVA自带的远程方法调用工具，不过有一定的局限性，毕竟是JAVA语言最开始时的设计，后来很多框架的原理都基于RMI。</p>
<ol start="2">
<li><p>Hessian（基于HTTP的远程方法调用）</p>
<p>基于HTTP协议传输，在性能方面还不够完美，负载均衡和失效转移依赖于应用的负载均衡器，Hessian的使用则与RMI类似，区别在于淡化了Registry的角色，通过显示的地址调用，利用HessianProxyFactory根据配置的地址create一个代理对象，另外还要引入Hessian的Jar包。</p>
</li>
<li><p>Dubbo（淘宝开源的基于TCP的RPC框架）</p>
</li>
</ol>
<p>基于Netty的高性能RPC框架，是阿里巴巴开源的，总体原理如下：</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>Ribbon</tag>
        <tag>Feign</tag>
        <tag>Hystrix</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot框架总述</title>
    <url>/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springboot/springboot/</url>
    <content><![CDATA[<h1 id="SpringBoot主要特性"><a href="#SpringBoot主要特性" class="headerlink" title="SpringBoot主要特性"></a>SpringBoot主要特性</h1><p><strong>Spring boot</strong> 简化了使用 Spring 的难度，简省了繁重的配置（版本管理，依赖导入），提供了各种启动器，开发者能快速上手。 </p>
<h2 id="SpringBoot的版本控制"><a href="#SpringBoot的版本控制" class="headerlink" title="SpringBoot的版本控制"></a>SpringBoot的版本控制</h2><p>pom.xml中有父项目</p>
<ul>
<li><p>spring-boot-dependencies：核心依赖在父工程中</p>
</li>
<li><p>我们在写或者应用引入一些springboot的依赖的时候，不需要指定版本，因为有相关版本库。</p>
</li>
</ul>
<h2 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h2><p>SpringBoot 自动配置主要通过 @EnableAutoConfiguration, @Conditional, @EnableConfigurationProperties 或者 @ConfigurationProperties 等几个注解来进行自动配置完成的。</p>
<ul>
<li><p>@EnableAutoConfiguration 开启自动配置，主要作用就是调用 Spring-Core 包里的 loadFactoryNames()，将 autoconfig 包里的已经写好的自动配置加载进来。</p>
</li>
<li><p>@Conditional 条件注解，通过判断类路径下有没有相应配置的 jar 包来确定是否加载和自动配置这个类。</p>
</li>
<li><p>@EnableConfigurationProperties 的作用就是，给自动配置提供具体的配置参数，只需要写在 application.properties 中，就可以通过映射写入配置类的 POJO 属性中。 </p>
<p><img src="/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springboot/springboot/springboot_start.jpg" alt="springboot_start"></p>
<blockquote>
<p>该配置模块的主要使用到了<strong>SpringFactoriesLoader，即Spring工厂加载器</strong>，该对象提供了<strong>loadFactoryNames()<strong>方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即</strong>指定的配置文件META-INF/spring.factories</strong>，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</p>
<p><img src="/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springboot/springboot/Users\sxyyl\Documents\GitHub_posts\spring\springboot\springboot\springboot_EnableAutoConfiguration.jpg" alt="springboot_EnableAutoConfiguration"></p>
</blockquote>
</li>
</ul>
<h2 id="什么是-Spring-Boot-Stater-？"><a href="#什么是-Spring-Boot-Stater-？" class="headerlink" title="什么是 Spring Boot Stater ？"></a>什么是 Spring Boot Stater ？</h2><p>启动器是一套方便的依赖描述符，它可以放在自己的程序中。你可以一站式的获取你所需要的 Spring 和相关技术，而不需要依赖描述符的通过示例代码搜索和复制黏贴的负载。</p>
<span id="more"></span>



<h1 id="springboot启动原理"><a href="#springboot启动原理" class="headerlink" title="springboot启动原理"></a>springboot启动原理</h1><p>我们发现启动流程主要分为<strong>三个部分</strong>，</p>
<ol>
<li><p>进行<strong>SpringApplication的初始化模块</strong>，配置一些基本的环境变量、资源、构造器、监听器；</p>
</li>
<li><p>实现了<strong>应用具体的启动方案</strong>，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块；</p>
</li>
<li><p>是自动化配置模块，</p>
</li>
</ol>
<p><img src="/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springboot/springboot/springboot_start.jpg" alt="springboot_start"></p>
<h3 id="SpringApplication初始化"><a href="#SpringApplication初始化" class="headerlink" title="SpringApplication初始化"></a>SpringApplication初始化</h3><p>初始化流程中最重要的就是通过SpringFactoriesLoader找到spring.factories文件中配置的ApplicationContextInitializer和ApplicationListener两个接口的实现类名称，以便后期构造相应的实例</p>
<ul>
<li>ApplicationContextInitializer的主要目的是在ConfigurableApplicationContext做refresh之前，对ConfigurableApplicationContext实例做进一步的设置或处理。</li>
<li>ApplicationListener的目的就没什么好说的了，它是Spring框架对Java事件监听机制的一种框架实现。Spring Boot提供两种方式来添加自定义监听器通过SpringApplication.addListeners(ApplicationListener<?>... listeners)或者SpringApplication.setListeners(Collection<? extends ApplicationListener<?>&gt; listeners)两个方法来添加一个或者多个自定义监听器。然后还需要在我们直接在自己的jar包的META-INF/spring.factories文件中新增配置即可：</li>
</ul>
<h3 id="Spring-Boot启动流程"><a href="#Spring-Boot启动流程" class="headerlink" title="Spring Boot启动流程"></a>Spring Boot启动流程</h3><p><strong>SpringApplication的run方法</strong>的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p>
<p><img src="/2021/08/17/%E6%A1%86%E6%9E%B6/spring/springboot/springboot/SpringApplication.jpg" alt="SpringApplication"></p>
<p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p>
<ul>
<li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li>
<li>推断并设置main方法的定义类。</li>
</ul>
<p>2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过<strong>SpringFactoriesLoader</strong>可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p>
<p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p>
<p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p>
<p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p>
<p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p>
<p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p>
<p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p>
<p>9） 最核心的一步，将之前通过**@EnableAutoConfiguration**获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p>
<p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p>
<p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p>
<p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p>
<p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p>
<h1 id="springboot-如何内置的tomcat"><a href="#springboot-如何内置的tomcat" class="headerlink" title="springboot 如何内置的tomcat"></a>springboot 如何内置的tomcat</h1><p>大致流程如下</p>
<ol>
<li>通过自动装配默认加载了DispatcherServlet，所有请求都会转发到DispatcherServlet</li>
<li>DispatcherServlet的doService方法中拿到HttpServletRequest和HttpServletResponse对象</li>
<li>从HttpServletRequest可以拿到我们的http头、url请求等信息</li>
<li>根据获取的信息，从ioc容器中找到对应的Controller对应的action，进行反射调用</li>
<li>根据HttpServletResponse返回调用结果给浏览器渲染<br></li>
</ol>
<p>springboot默认创建了一个DispatcherServlet来处理http请求<br>    - 不用再配置DispatcherServlet 简单的说就是默认加载META-INF/spring.factories定义的类，然后我们就可以在spring.factories中找到我们的关键类DispatcherServletAutoConfiguration</p>
<h1 id="springboot常用注解"><a href="#springboot常用注解" class="headerlink" title="springboot常用注解"></a>springboot常用注解</h1><p><strong>@SpringBootApplication</strong> </p>
<p>这个注解是Spring Boot<strong>最核心的注解</strong>，用在 Spring Boot的主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。实际上这个注解是@Configuration,@EnableAutoConfiguration,@ComponentScan三个注解的组合。由于这些注解一般都是一起使用，所以Spring Boot提供了一个统一的注解@SpringBootApplication。</p>
<p><strong>@EnableAutoConfiguration</strong></p>
<p>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p>
<p>如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。</p>
<p><strong>@Configuration</strong></p>
<p>用于定义配置类，指出该类是 Bean 配置的信息源，相当于传统的xml配置文件，一般加在主类上。如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p>
<p><strong>@RestController</strong></p>
<p>用于标注控制层组件(如struts中的action)，表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器；它是@Controller和@ResponseBody的合集。</p>
<p><strong>@Component</strong></p>
<p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring框架_事务管理</title>
    <url>/2021/08/17/%E6%A1%86%E6%9E%B6/spring/spring/spring%E6%A1%86%E6%9E%B6_%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="spring事务管理"><a href="#spring事务管理" class="headerlink" title="spring事务管理"></a>spring事务管理</h1><h2 id="Spring定义了7种传播行为："><a href="#Spring定义了7种传播行为：" class="headerlink" title="Spring定义了7种传播行为："></a>Spring定义了7种传播行为：</h2><ol>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，<br>加入到这个事务中，这是Spring默认的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</li>
</ol>
<h2 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a><strong>Spring事务隔离级别</strong></h2><h2 id="Spring事务隔离级别比数据库事务隔离级别多一个default"><a href="#Spring事务隔离级别比数据库事务隔离级别多一个default" class="headerlink" title="Spring事务隔离级别比数据库事务隔离级别多一个default"></a><strong>Spring事务隔离级别比数据库事务隔离级别多一个default</strong></h2><p><strong>1) DEFAULT （默认）</strong><br>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。</p>
<p><strong>2) READ_UNCOMMITTED （读未提交）</strong><br>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p>
<p><strong>3) READ_COMMITTED （读已提交）</strong><br>保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p>
<p><strong>4) REPEATABLE_READ （可重复读）</strong><br>这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</p>
<p><strong>5) SERIALIZABLE（串行化）</strong><br>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。</p>
<h2 id="事务几种实现方式"><a href="#事务几种实现方式" class="headerlink" title="事务几种实现方式"></a>事务几种实现方式</h2><ol>
<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 TransactionProxyFactoryBean的声明式事务管理</li>
<li>基于 @Transactional 的声明式事务管理</li>
<li>基于Aspectj AOP配置事务</li>
</ol>
<h3 id="基于-TransactionProxyFactoryBean的声明式事务管理"><a href="#基于-TransactionProxyFactoryBean的声明式事务管理" class="headerlink" title="基于 TransactionProxyFactoryBean的声明式事务管理"></a>基于 TransactionProxyFactoryBean的声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myTracnsactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 事务代理工厂 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生成事务代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myTracnsactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;buyStockService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 主要 key 是方法   </span></span><br><span class="line"><span class="comment">                    ISOLATION_DEFAULT  事务的隔离级别</span></span><br><span class="line"><span class="comment">                    PROPAGATION_REQUIRED  传播行为</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;add*&quot;</span>&gt;</span>ISOLATION_DEFAULT,PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- -Exception 表示发生指定异常回滚，+Exception 表示发生指定异常提交 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;buyStock&quot;</span>&gt;</span>ISOLATION_DEFAULT,PROPAGATION_REQUIRED,-BuyStockException<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="基于-Transactional-注解的声明式事务管理"><a href="#基于-Transactional-注解的声明式事务管理" class="headerlink" title="基于 @Transactional 注解的声明式事务管理"></a>基于 @Transactional 注解的声明式事务管理</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> BuyStockServiceImpl implements BuyStockService&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">private</span> StockDao stockDao;</span><br><span class="line">    </span><br><span class="line">    @<span class="constructor">Transactional(<span class="params">isolation</span>=Isolation.DEFAULT,<span class="params">propagation</span>=Propagation.REQUIRED)</span></span><br><span class="line">    @Override</span><br><span class="line">    public void add<span class="constructor">Account(String <span class="params">accountname</span>, <span class="params">double</span> <span class="params">money</span>)</span> &#123;</span><br><span class="line">        accountDao.add<span class="constructor">Account(<span class="params">accountname</span>,<span class="params">money</span>)</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @<span class="constructor">Transactional(<span class="params">isolation</span>=Isolation.DEFAULT,<span class="params">propagation</span>=Propagation.REQUIRED)</span></span><br><span class="line">    @Override</span><br><span class="line">    public void add<span class="constructor">Stock(String <span class="params">stockname</span>, <span class="params">int</span> <span class="params">amount</span>)</span> &#123;</span><br><span class="line">        stockDao.add<span class="constructor">Stock(<span class="params">stockname</span>,<span class="params">amount</span>)</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public <span class="constructor">BuyStockServiceImpl()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @<span class="constructor">Transactional(<span class="params">isolation</span>=Isolation.DEFAULT,<span class="params">propagation</span>=Propagation.REQUIRED,<span class="params">rollbackFor</span>=BuyStockException.<span class="params">class</span>)</span></span><br><span class="line">    @Override</span><br><span class="line">    public void buy<span class="constructor">Stock(String <span class="params">accountname</span>, <span class="params">double</span> <span class="params">money</span>, String <span class="params">stockname</span>, <span class="params">int</span> <span class="params">amount</span>)</span> throws BuyStockException &#123;</span><br><span class="line">        boolean isBuy = <span class="literal">true</span>;</span><br><span class="line">        accountDao.update<span class="constructor">Account(<span class="params">accountname</span>, <span class="params">money</span>, <span class="params">isBuy</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBuy==<span class="literal">true</span>)&#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">BuyStockException(<span class="string">&quot;购买股票发生异常&quot;</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            stockDao.update<span class="constructor">Stock(<span class="params">stockname</span>, <span class="params">amount</span>, <span class="params">isBuy</span>)</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public AccountDao get<span class="constructor">AccountDao()</span> &#123;</span><br><span class="line">        return accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void set<span class="constructor">AccountDao(AccountDao <span class="params">accountDao</span>)</span> &#123;</span><br><span class="line">        this.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public StockDao get<span class="constructor">StockDao()</span> &#123;</span><br><span class="line">        return stockDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void set<span class="constructor">StockDao(StockDao <span class="params">stockDao</span>)</span> &#123;</span><br><span class="line">        this.stockDao = stockDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myTracnsactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 启用事务注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;myTracnsactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="基于Aspectj-AOP配置事务"><a href="#基于Aspectj-AOP配置事务" class="headerlink" title="基于Aspectj AOP配置事务"></a>基于Aspectj AOP配置事务</h3><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 注册数据源 C3P0 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>  &gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;jdbc.driverClass&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;jdbc.url&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;jdbc.username&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;jdbc.password&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;transaction.test4.dao.AccountDaoImpl&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stockDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;transaction.test4.dao.StockDaoImpl&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;buyStockService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;transaction.test4.service.BuyStockServiceImpl&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stockDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;stockDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 事务管理器 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myTracnsactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;myTracnsactionManager&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 为连接点指定事务属性 --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;buyStock&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;BuyStockException&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 切入点配置 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..service.*.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;point&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;point&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>原文地址：<a href="https://www.cnblogs.com/h-c-g/p/10872061.html">https://www.cnblogs.com/h-c-g/p/10872061.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title>限流_sentinel</title>
    <url>/2021/08/17/%E6%A1%86%E6%9E%B6/spring/sentinel/%E9%99%90%E6%B5%81_sentinel/</url>
    <content><![CDATA[<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><h2 id="主要概念相关"><a href="#主要概念相关" class="headerlink" title="主要概念相关"></a>主要概念相关</h2><p>Sentinel 是面向分布式服务架构的高可用流量防护组件，主要以流量为切入点，从<strong>限流、流量整形、熔断降级、系统负载保护、热点防护</strong>等多个维度来帮助开发者保障微服务的稳定性。</p>
<hr>
<p><img src="/2021/08/17/%E6%A1%86%E6%9E%B6/spring/sentinel/%E9%99%90%E6%B5%81_sentinel/st.png" alt="st"></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。</p>
<p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p>
<ul>
<li><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">官方介绍文档</a></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本使用-资源与规则"><a href="#基本使用-资源与规则" class="headerlink" title="基本使用 - 资源与规则"></a><a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">基本使用 - 资源与规则</a></h3><h3 id="集成apollo"><a href="#集成apollo" class="headerlink" title="集成apollo"></a><a href="https://blog.csdn.net/a745233700/article/details/122725604">集成apollo</a></h3><hr>
<h3 id="针对来源进行限流"><a href="#针对来源进行限流" class="headerlink" title="针对来源进行限流"></a>针对来源进行限流</h3><h4 id="1-首先我们要自定义来源解析RequestOriginParser"><a href="#1-首先我们要自定义来源解析RequestOriginParser" class="headerlink" title="1.首先我们要自定义来源解析RequestOriginParser"></a>1.首先我们要自定义来源解析RequestOriginParser</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestOriginParser <span class="title">requestOriginParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (request -&gt; &#123;</span><br><span class="line">            String remoteAddr = IpUtils.getRemoteAddr(request);</span><br><span class="line">            <span class="keyword">return</span> remoteAddr;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-接下来我们设置来源-，填入限制的ip，"><a href="#2-接下来我们设置来源-，填入限制的ip，" class="headerlink" title="2.接下来我们设置来源 ，填入限制的ip，"></a>2.接下来我们设置来源 ，填入限制的ip，</h4><p><img src="/2021/08/17/%E6%A1%86%E6%9E%B6/spring/sentinel/%E9%99%90%E6%B5%81_sentinel/ip.png" alt="ip"></p>
<h4 id="3-即可实现针对ip的限流"><a href="#3-即可实现针对ip的限流" class="headerlink" title="3.即可实现针对ip的限流"></a>3.即可实现针对ip的限流</h4>]]></content>
      <categories>
        <category>java</category>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>限流</tag>
        <tag>sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka</title>
    <url>/2021/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/Eureka/</url>
    <content><![CDATA[<h1 id="Eureka-Server：注册中心服务端"><a href="#Eureka-Server：注册中心服务端" class="headerlink" title="Eureka Server：注册中心服务端"></a>Eureka Server：注册中心服务端</h1><p>注册中心服务端主要对外提供了三个功能：</p>
<ul>
<li>服务注册<br>服务提供者启动时，会通过 Eureka Client 向 Eureka Server 注册信息，Eureka Server 会存储该服务的信息，Eureka Server 内部有二层缓存机制来维护整个注册表</li>
<li>提供注册表<br> 服务消费者在调用服务时，如果 Eureka Client 没有缓存注册表的话，会从 Eureka Server 获取最新的注册表<ul>
<li>注册表的数据结构：registry的<strong>CocurrentHashMap</strong>，就是注册表的核心结构。同时维护注册表、拉取注册表、更新心跳时间，全部<strong>发生在内存里</strong>！这是Eureka Server非常核心的一个点。</li>
</ul>
</li>
<li>同步状态</li>
</ul>
<h2 id="高可用原理"><a href="#高可用原理" class="headerlink" title="高可用原理"></a>高可用原理</h2><p>其实每一个服务端（这里指实例）都内置了一个Eureka Client，也就是说一个服务端可以接受其他Client的注册，也可以作为一个Client注册到其他Server上，被其他Client发现和调用。一个服务端实例你可以理解为由一个Server+Client组成。</p>
<p><img src="/2021/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/Eureka/Eureka.jpg" alt="Eureka"></p>
<p> Eureka Server 集群相互之间通过 Replicate 来同步数据，相互之间<strong>不区分主节点和从节点</strong>，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点</p>
<p>如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点。当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它 Eureka Server 当前所知的所有节点中。</p>
<p>另外 Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个 Eureka Server 同时也是 Eureka Client，多个 Eureka Server 之间通过 P2P 的方式完成服务注册表的同步。</p>
<p>Eureka Server 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。</p>
<p><strong>Eureka 保证 AP</strong>，优先保证可用性，牺牲了一定的一致性。相对的zookeeper则是保证了CP，牺牲了部分的可用性。</p>
]]></content>
      <categories>
        <category>基础概念</category>
        <category>分布式</category>
        <category>Erueka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>Eureka高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础提升_JVM</title>
    <url>/2021/08/17/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_JVM/</url>
    <content><![CDATA[<h1 id="JVM的定义"><a href="#JVM的定义" class="headerlink" title="JVM的定义"></a>JVM的定义</h1><p>JVM(Java Virtual Machine，Java虚拟机)。<br><br>JVM是JAVA实现跨平台的主要手段，事实上jvm是有较多的实现版本，各种系统下的JVM不同。<br></p>
<p>由于jvm是处在Java语言和操作系统之间的，所以它要向上提供对Java的支持，向下与操作系统良好交互。</p>
<p><img src="/2021/08/17/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_JVM/jvm.jpg" alt="jvm"></p>
<h1 id="JVM中的数据结构"><a href="#JVM中的数据结构" class="headerlink" title="JVM中的数据结构"></a>JVM中的数据结构</h1><p>主要分为<strong>基本类型</strong>和<strong>引用类型</strong>。</p>
<span id="more"></span>

<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul>
<li>基本类型<ul>
<li><strong>数值类型</strong><ul>
<li>整型</li>
<li>浮点型</li>
<li>char类型</li>
</ul>
</li>
<li><strong>boolean类型</strong><br><ul>
<li>true</li>
<li>false<br><br>&nbsp;&nbsp;（boolean类型的操作会被转化为int类型的操作进行，boolean数组会当成byte数组去操作。1表示true，0表示false。）</li>
</ul>
</li>
<li><strong>returnAddress类型</strong><br><br>&nbsp;&nbsp;是一个指针，指向jvm指令的操作码，<br>在Java中没有与之对应的类型。<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2></li>
</ul>
</li>
<li>引用类型<ul>
<li><strong>类类型</strong></li>
<li><strong>数组类型</strong><ul>
<li>component类型<br><br>&nbsp;&nbsp;(数组去掉最外层维度后剩下的类型，可能还是一个数组类型（对于多维数组）)</li>
<li>element类型 </li>
</ul>
</li>
<li><strong>接口类型</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="JVM中的内存结构"><a href="#JVM中的内存结构" class="headerlink" title="JVM中的内存结构"></a>JVM中的内存结构</h1><ul>
<li><p><em>运行时公有数据区</em>（线程共享）</p>
<ul>
<li><strong>堆</strong>（GC发生的主要区域）<br><br>  对象实例和数组<ul>
<li>新生代 1/3<ul>
<li>Eden 区 80%</li>
<li>From Survivor 区 10%</li>
<li>To Survivor 区 10%</li>
</ul>
</li>
<li>老年代 2/3</li>
</ul>
</li>
<li><strong>方法区</strong>（永久代，Java 8后就把方法区的实现移到了本地内存中的<strong>元空间</strong>中）<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;用于存储被 JVM 加载的<strong>常量、静态变量、类信息、即时编译器编译后的代码</strong>等数据。<br><ul>
<li>运行时常量池<blockquote>
<p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p>
</li>
<li><p><em>运行时私有数据区</em>（线程私有）</p>
<ul>
<li><p><strong>pc寄存器</strong>（程序计数器）<br><br>&nbsp;&nbsp;（计数器记录的是虚拟机字节码指令的地址（当前指令的地址 （可以理解为代码的行号，线程被挂起了，再恢复回来执行时需要定位原来执行到的地方）是由字节码执行引擎更新）。如果是Native方法，则为空。<br><br>&nbsp;&nbsp;这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域）</p>
</li>
<li><p><strong>jvm栈</strong>（虚拟机栈）<br></p>
<p><img src="/2021/08/17/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_JVM/%E6%A0%88-%E6%A0%88%E5%B8%A7.jpg" alt="栈-栈帧"></p>
<ul>
<li>栈帧（ Frame）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）<br>用于存储<strong>局部变量表、操作数栈、动态链接（方法区的地址，找到方法区存的代码）、方法出口（原调用方法的调用时的信息）</strong>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;局部变量表：存放了编译期可知的各种<strong>基本类型</strong>(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型,即局部变量是对象时为<strong>对象在堆中的内存地址</strong>)和 returnAddress 类型(指向了一条字节码指令的地址)<ul>
<li><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。</p>
</li>
<li><p>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>native方法栈</strong>（本地方法栈）<br><br>调用非java方法时使用</p>
</li>
</ul>
</li>
<li><p><em>直接内存</em></p>
<ul>
<li><strong>元空间</strong>（java8以后将永久代移动到了元空间中）</li>
<li><strong>直接内存</strong><blockquote>
<p>非虚拟机运行时数据区的部分</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<!--more-->
<h1 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h1><blockquote>
<p>在 HotSpot 虚拟机中，分为 3 块区域：<br><br>对象头(Header)<br><br>实例数据(Instance Data)<br><br>对齐填充(Padding)<br></p>
</blockquote>
<h2 id="对象头-Header"><a href="#对象头-Header" class="headerlink" title="对象头(Header)"></a>对象头(Header)</h2><ul>
<li>第一部分 (Mark Word)<br><br>  用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。</li>
<li>第二部分 类型指针<br><br>即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。<h2 id="实例数据-Instance-Data"><a href="#实例数据-Instance-Data" class="headerlink" title="实例数据(Instance Data)"></a>实例数据(Instance Data)</h2>程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。<h2 id="对齐填充-Padding"><a href="#对齐填充-Padding" class="headerlink" title="对齐填充(Padding)"></a>对齐填充(Padding)</h2>不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</li>
</ul>
<hr>
<h1 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h1><p>   主要在堆中进行，java8之前还有永久代（也就是方法区），java8后方法区移到了直接内存中的元空间中去了，所以只有堆进行GC，对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收。</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>最容易想到的一种方式是引用计数法，啥叫引用计数法，简单地说，就是对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为 0），则此对象可回收，但此方法无法解决循环引用问题，循环引用后，即使没有真正的引用了，但其引用无法归0。所以现代虚拟机都不用引用计数法来判断对象是否应该被回收。</p>
<h2 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>现代虚拟机基本都是采用这种算法</strong>来判断对象是否存活，可达性算法的原理是以一系列叫做  GC Root  的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。。。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为「垃圾」,会被 GC 回收。<br></p>
<p>fullGC时虚拟机会STW（stop the world），好用来判断GC Root，（如果客户线程不停的话可能之前标记为非垃圾的对象，后面由于用户线程继续执行，栈帧后面被销毁，按可达性算法，又变为了垃圾）。</p>
<h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>哪些对象可以作为 GC Root 呢，有以下几类<br></p>
<ul>
<li><strong>虚拟机栈（栈帧中的局部变量表）</strong> 中引用的对象</li>
<li><strong>方法区中类静态属性</strong>引用的对象</li>
<li><strong>方法区中常量</strong>引用的对象</li>
<li><strong>本地方法栈中 JNI</strong>（即一般说的 Native 方法）引用的对象<h4 id="虚拟机栈中引用的对象"><a href="#虚拟机栈中引用的对象" class="headerlink" title="虚拟机栈中引用的对象"></a>虚拟机栈中引用的对象</h4>如下代码所示，a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 GC Root 的作用，a 与原来指向的实例 new Test() 断开了连接，所以对象会被回收。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicclass Test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Test a = <span class="keyword">new</span> Test();</span><br><span class="line">	a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法区中类静态属性引用的对象"><a href="#方法区中类静态属性引用的对象" class="headerlink" title="方法区中类静态属性引用的对象"></a>方法区中类静态属性引用的对象</h4>如下代码所示，当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Test a = <span class="keyword">new</span> Test();</span><br><span class="line">	a.s = <span class="keyword">new</span> Test();</span><br><span class="line">	a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法区中常量引用的对象"><a href="#方法区中常量引用的对象" class="headerlink" title="方法区中常量引用的对象"></a>方法区中常量引用的对象</h4>如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test s = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    Test a = <span class="keyword">new</span> Test();</span><br><span class="line">	    a = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="本地方法栈中-JNI-引用的对象"><a href="#本地方法栈中-JNI-引用的对象" class="headerlink" title="本地方法栈中 JNI 引用的对象"></a>本地方法栈中 JNI 引用的对象</h4>所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法。</li>
</ul>
<p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p>
<h3 id="对象可回收，就一定会被回收吗"><a href="#对象可回收，就一定会被回收吗" class="headerlink" title="对象可回收，就一定会被回收吗?"></a>对象可回收，就一定会被回收吗?</h3><p>并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！</p>
<p>注意： <strong>finalize 方法只会被执行一次</strong>，<em>如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!</em></p>
<h2 id="垃圾回收主要方法"><a href="#垃圾回收主要方法" class="headerlink" title="垃圾回收主要方法"></a>垃圾回收主要方法</h2><p><strong>Full GC</strong>就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC；</p>
<ul>
<li>标记清除算法<br>顾名思义，先标记可回收的对象，进行清除。<br><br>缺点：剩余的内存不连续</li>
<li>复制算法<br><br>将内存分为两块，一块空的，一块是已用的，在已用的里面标记出存活的对象，再复制到另一块中，再把原来的那块都清了。<br><br>缺点：可用内存减半；复制的效率低</li>
<li>标记整理法<br><br>前面两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列（如图示），再清理掉另一端的所有区域，这样的话就解决了内存碎片的问题。<br><br>缺点：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据大多数java对象的存活特征，所以分代收集算法根据对象存活周期的不同将堆分成==新生代和老生代==（Java8以前还有个永久代）,默认比例为 ==1 : 2==，新生代又分为<strong>Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1)</strong>,三者的比例为 <strong>8: 1: 1</strong> ，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把<strong>新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）</strong>*(不严谨 但可这么理解)。<br></p>
<ol>
<li>当 Eden 区将满时，触发 Minor GC。采用复制删除算法。Eden标记出来存活对象 -&gt; 复制到S0中<br></li>
<li>第二次：Eden 和 S0（或S1）存活对象一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。（后续S0和S1的角色会以此互换以重复上述过程）<br>具体过程：<a href="https://mp.weixin.qq.com/s/_AKQs-xXDHlk84HbwKUzOw">link</a><br></li>
</ol>
<p>FULL GC采用标记整理算法</p>
<h4 id="升级到老年代"><a href="#升级到老年代" class="headerlink" title="升级到老年代"></a>升级到老年代</h4><ul>
<li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li>
<li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li>
<li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4></li>
</ul>
<p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h2><p>jstack，jmap，jinfo，</p>
<h3 id="1-检查jvm配置"><a href="#1-检查jvm配置" class="headerlink" title="1.检查jvm配置"></a>1.检查jvm配置</h3><ul>
<li>通过以下命令查看JVM的启动参数：<br><br> <code>ps aux | grep &quot;applicationName=adsearch&quot;</code><h3 id="2-观察老年代的内存变化"><a href="#2-观察老年代的内存变化" class="headerlink" title="2.观察老年代的内存变化"></a>2.观察老年代的内存变化</h3></li>
<li>通过观察老年代的使用情况，可以看到：每次FGC后，内存是否有效回收了，否则考虑内存泄漏等原因。<h3 id="3-通过jmap命令查看堆内存中的对象"><a href="#3-通过jmap命令查看堆内存中的对象" class="headerlink" title="3.通过jmap命令查看堆内存中的对象"></a>3.通过jmap命令查看堆内存中的对象</h3><code>jmap -histo 7276 | head -n20</code><h3 id="4-进一步dump堆内存文件进行分析"><a href="#4-进一步dump堆内存文件进行分析" class="headerlink" title="4. 进一步dump堆内存文件进行分析"></a>4. 进一步dump堆内存文件进行分析</h3>通过以下命令dump堆内存：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=heap 7276</span><br><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure>
JVisualVM工具导入dump出来的堆内存文件，同样可以看到各个对象所占空间</li>
</ul>
<p>   在调试程序时，有时需要查看程序加载的类、内存回收情况、调用的本地接口等。这时候就需要-verbose命令。在myeclipse可以通过右键设置（如下），也可以在命令行输入java -verbose来查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-verbose:class 查看类加载情况</span><br><span class="line">-verbose:gc 查看虚拟机中内存回收情况</span><br><span class="line">-verbose:jni 查看本地方法调用的情况</span><br></pre></td></tr></table></figure>
<h4 id="阿里jvm工具"><a href="#阿里jvm工具" class="headerlink" title="阿里jvm工具"></a>阿里jvm工具</h4><p>JVM调优工具_arthas(阿尔萨斯)。</p>
<p>直接java -jar即可使用</p>
<h1 id="jvm参数详解"><a href="#jvm参数详解" class="headerlink" title="jvm参数详解"></a>jvm参数详解</h1><p>-Xms:设置Java程序启动时初始化堆大小<br><br>-Xmx:设置Java程序能获得最大的堆大小 <br><br>-Xmn：可以设置新生代的大小，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大的影响，新生代大小一般会设置整个堆空间的1/3到1/4左右。<br><br>-Xss：栈内存大小，设置单个线程栈大小，一般默认512~1024kb。单个线程栈大小跟操作系统和JDK版本都有关系-Xss = -XX:ThreadStackSize<br><br>-XX:SurvivorRatio：用来设置新生代中eden空间和from/to空间的比例。含义：-XX:SurvivorRatio=eden/from=eden/to。<br>不同的堆分布情况，对系统执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。<br><br>-XX:MetaspaceSize 初始元数据空间大小<br><br>-XX:MaxMetaspaceSize=128m    <br></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>可以通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -c ***.class</span><br></pre></td></tr></table></figure>

<p>命令进行代码反汇编</p>
<p>   类<img src="/2021/08/17/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>限流算法</title>
    <url>/2021/08/17/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>1 计数器（固定窗口）算法</p>
<p>计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。此算法可用性不高，存在一个非常严重的问题，那就是临界问题，其实只是为了引出滑动窗口算法。</p>
</blockquote>
<h2 id="2-滑动窗口算法"><a href="#2-滑动窗口算法" class="headerlink" title="2.滑动窗口算法"></a>2.滑动窗口算法</h2><p>滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。</p>
<p>如下图，假设时间周期为1min，将1min再分为2个小周期，统计每个小周期的访问数量，则可以看到，第一个时间周期内，访问数量为75，第二个时间周期内，访问数量为100，超过100的访问则被限流掉了由此可见，当<strong>滑动窗口的格子</strong>划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。此算法可以很好的解决固定窗口算法的临界问题。</p>
<h2 id="3-漏桶算法"><a href="#3-漏桶算法" class="headerlink" title="3.漏桶算法"></a>3.漏桶算法</h2><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。</p>
<h2 id="4-令牌桶算法"><a href="#4-令牌桶算法" class="headerlink" title="4.令牌桶算法"></a>4.令牌桶算法</h2><p>令牌桶算法是程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_41846320/article/details/95941361">原文出处</a></li>
</ul>
<h2 id="漏桶算法VS令牌桶算法"><a href="#漏桶算法VS令牌桶算法" class="headerlink" title="漏桶算法VS令牌桶算法"></a>漏桶算法VS令牌桶算法</h2><p><a href="https://www.baidu.com/s?wd=%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">漏桶算法</a>与<a href="https://www.baidu.com/s?wd=%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">令牌桶算法</a>的区别在于：<a href="https://www.baidu.com/s?wd=%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">漏桶算法</a>能够强行限制数据的<a href="https://www.baidu.com/s?wd=%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">传输速率</a>。<a href="https://www.baidu.com/s?wd=%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">令牌桶算法</a>能够在限制数据的平均<a href="https://www.baidu.com/s?wd=%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">传输速率</a>的同时还允许某种程度的<a href="https://www.baidu.com/s?wd=%E7%AA%81%E5%8F%91%E4%BC%A0%E8%BE%93&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">突发传输</a>。需要说明的是：在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为<a href="https://www.baidu.com/s?wd=%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">网络流量</a>提供更高效的控制。</p>
<p>总结起来：<strong>自己的系统</strong>扛不了大量请求，用<strong>令牌桶</strong>。对接的<strong>下游系统</strong>抗不了突发大量请求，可以用<strong>漏桶算法</strong>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql_优化系列_索引优化</title>
    <url>/2021/08/12/sql/mysql_%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="模糊匹配like-怎么优化"><a href="#模糊匹配like-怎么优化" class="headerlink" title="模糊匹配like %%怎么优化"></a>模糊匹配like %%怎么优化</h2><ol>
<li><strong>开启ICP（索引条件下推）</strong><br></li>
</ol>
<ul>
<li><strong>索引下推</strong>（index condition pushdown ）简称ICP，在<strong>Mysql5.6</strong>的版本上推出，用于优化查询。</li>
<li>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</li>
<li><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数</strong>。****</li>
</ul>
<p>  可以通过索引筛选，返回给Server层筛选后的记录，减少不必要的IO开销。<br><br>  如果where后只有一个 like ‘%xxx%’条件，表有主键的前提下，可以通过子查询优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> users01 a , </span><br><span class="line">(<span class="keyword">select</span> id <span class="keyword">from</span> users01 <span class="keyword">where</span> nickname <span class="keyword">like</span> <span class="string">&#x27;%SK%&#x27;</span>) b</span><br><span class="line"> <span class="keyword">where</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>建立全文索引</strong><br><br>两种检索模式</li>
</ol>
<ul>
<li><p>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</p>
</li>
<li><p>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</p>
</li>
<li><p>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</p>
</li>
<li><p>IN NATURAL LANGUAGE MODE：默认模式，以自然语言的方式搜索，AGAINST(‘看风’ IN NATURAL LANGUAGE MODE ) 等价于AGAINST(‘看风’)。</p>
</li>
<li><p>IN BOOLEAN MODE：布尔模式，表是字符串前后的字符有特殊含义，如查找包含SK，但不包含Lyn的记录，可以用+，-符号。<br>AGAINST(‘+SK -Lyn’ in BOOLEAN MODE);</p>
</li>
</ul>
<p>创建全文索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users01 <span class="keyword">add</span> fulltext index idx_full_nickname(nickname) <span class="keyword">with</span> parser ngram;</span><br></pre></td></tr></table></figure>
<p>改写like语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users01 <span class="keyword">where</span> <span class="keyword">match</span>(nickname) against(<span class="string">&#x27;看风&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>生成列（虚拟列）</strong><br><br>对于where条件后的 like ‘%xxx’ 是无法利用索引扫描，可以利用MySQL 5.7的生成列模拟函数索引的方式解决，具体步骤如下：<br>利用内置reverse函数将like ‘%风云’反转为like ‘云风%’，基于此函数添加虚拟生成列。<br>在虚拟生成列上创建索引。<br>将SQL改写成通过生成列like reverse(‘%风云’)去过滤，走生成列上的索引。<br>建立生成列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users01 <span class="keyword">add</span> reverse_nickname <span class="type">varchar</span>(<span class="number">200</span>) generated always <span class="keyword">as</span> (reverse(nickname));</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="索引很长的字段怎么优化？"><a href="#索引很长的字段怎么优化？" class="headerlink" title="索引很长的字段怎么优化？"></a>索引很长的字段怎么优化？</h2><p>有时候需要索引很长的字符(例如BLOB,TEXT,或者很长的VARCHAR)，这样会使得索引又大又慢。</p>
<ol>
<li><strong>改用哈希索引</strong>。<br>InnoDB是支持Btree索引，但不显式支持hash索引。可以<strong>使用生成列来间接使用哈希索引</strong>。</li>
<li>使用字符串的前几个字符作为索引(即前缀索引)。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `city_demo` <span class="keyword">ADD</span> INDEX `idx_city` (`city`(<span class="number">7</span>)) <span class="keyword">USING</span> BTREE ;</span><br><span class="line"><span class="comment">-- 或者这个也行</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `city_demo` <span class="keyword">ADD</span> KEY `idx_city` (`city`(<span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<p>当然在选择前缀时要选择合适的前缀索引长度，保持好的选择性。其方法主要是计算数据分布。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询重复次数最多的10条完整城市名称及其数量(图1)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) cnt, city <span class="keyword">FROM</span> city_demo <span class="keyword">GROUP</span> <span class="keyword">BY</span> city <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询重复次数最多的10条城市名称(前3个字符)及其数量,可以发现:前3个字符的相同数量过大,不适合做前缀索引(图2)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) cnt, <span class="keyword">LEFT</span>(city,<span class="number">3</span>) pref <span class="keyword">FROM</span> city_demo <span class="keyword">GROUP</span> <span class="keyword">BY</span> pref <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询重复次数最多的10条城市名称(前7个字符)及其数量,可以发现:前7个字符的相同数量和完整城市名称很相近了,可以考虑作为做前缀索引(图3)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) cnt, <span class="keyword">LEFT</span>(city,<span class="number">7</span>) pref <span class="keyword">FROM</span> city_demo <span class="keyword">GROUP</span> <span class="keyword">BY</span> pref <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h1 id="MRR"><a href="#MRR" class="headerlink" title="MRR"></a>MRR</h1><p>MRR全称是Multi-Range Read，是MYSQL5.6优化器的一个新特性，在MariaDB5.5也有这个特性。优化的功能在使用二级索引做范围扫描的过程中减少磁盘随机IO和减少主键索引的访问次数。二级索引通过将主键放在buffer中排序将<strong>随机IO转换为顺序IO</strong>。对于随机读写能力较弱的机械硬盘有比较大优化。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
        <category>索引优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
        <tag>索引优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式_适配器模式</title>
    <url>/2021/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h2><ul>
<li><p>见名知意，是作为两个不兼容的接⼝之间的桥梁，属于结构型模式</p>
</li>
<li><p>适配器模式使得原本由于接⼝不兼容⽽不能⼀起⼯作的 那些类可以⼀起⼯作</p>
</li>
<li><p>常⻅见的⼏类适配器</p>
<ul>
<li>类的适配器模式<ul>
<li>想将⼀个类转换成满⾜另⼀个新接⼝的类时，可 以使⽤类的适配器模式，创建⼀个新类，继承原 有的类，实现新的接⼝即可 </li>
<li>对象的适配器模式<ul>
<li>想将⼀个对象转换成满⾜另⼀个新接⼝的对象 时，可以创建⼀个适配器类，持有原类的⼀个实 例，在适配器类的⽅法中，调⽤实例的⽅法就⾏</li>
</ul>
</li>
<li>接⼝的适配器模式<ul>
<li>不想实现⼀个接⼝中所有的⽅法时，可以创建⼀ 个Adapter，实现所有⽅法，在写别的类的时 候，继承Adapter类即</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p> 在使⽤⼀些旧系统或者是类库时，经常会出现接⼝不兼 容的问题，适配器模式在解决这类问题具有优势</p>
</li>
<li><p>学习设计模式⼀定不要局限代码层⾯，要从软件系统整 体去考虑,⽽不是为了使⽤设计模式，⽽去使⽤设计模式</p>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>可以让任何两个没有关联的类⼀起运⾏，使得原本由于 接⼝不兼容⽽不能⼀起⼯作的那些类可以⼀起⼯作 增加灵活度, 提⾼复⽤性，适配器类可以在多个系统使 ⽤,符合开闭原则</li>
</ul>
<p><strong>缺点</strong></p>
<p>整体类的调⽤链路增加，本来A可以直接调⽤C，使⽤适 配器后 是A调⽤B，B再调⽤C</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>适配器模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><ul>
<li><p>单一职责原则</p>
<p>一个类只负责一个功能领域的相应职责</p>
<p>实现高内聚，低耦合的指导方针</p>
</li>
<li><p>开闭原则</p>
<p>对扩展开放，对修改关闭</p>
</li>
<li><p>里氏替换原则LSP</p>
</li>
<li><p>依赖倒转原则</p>
</li>
<li><p>接口隔离原则</p>
</li>
<li><p>迪米特法则</p>
<ul>
<li><p>最少知道原则，一个实体类应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对对立</p>
</li>
<li><p>类之间的耦合度越低，就越有利用于复用</p>
</li>
</ul>
</li>
</ul>
<h1 id="设计模式的三大设计模式分类"><a href="#设计模式的三大设计模式分类" class="headerlink" title="设计模式的三大设计模式分类"></a>设计模式的三大设计模式分类</h1><ul>
<li><p>创建型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用：工厂模式，抽象工厂模式，单例模式，建造者模式</span><br><span class="line">不常用：原型模式</span><br></pre></td></tr></table></figure></li>
<li><p>结构型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用：适配器、桥接、装饰器、代理</span><br><span class="line">不常用：组合、外观、享元</span><br></pre></td></tr></table></figure></li>
<li><p>行为型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用： 观察者模式、模板模式、策略模式、责任链模式、迭代器模式、状态模式。</span><br><span class="line">不常用： 访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="入门问题"><a href="#入门问题" class="headerlink" title="入门问题"></a>入门问题</h1><h2 id="1-请列举出在-JDK-中几个常用的设计模式？"><a href="#1-请列举出在-JDK-中几个常用的设计模式？" class="headerlink" title="1.请列举出在 JDK 中几个常用的设计模式？"></a>1.请列举出在 JDK 中几个常用的设计模式？</h2><p>单例模式（Singleton pattern）用于 Runtime，Calendar 和其他的一些类中。工厂模式<br>（Factory pattern）被用于各种不可变的类如 Boolean，像 Boolean.valueOf，观察者模式<br>（Observer pattern）被用于 Swing 和很多的事件监听中。装饰器设计模式（Decorator<br>design pattern）被用于多个 Java IO 类中。</p>
<h2 id="2-什么是设计模式？你是否在你的代码里面使用过任何设计模式？"><a href="#2-什么是设计模式？你是否在你的代码里面使用过任何设计模式？" class="headerlink" title="2.什么是设计模式？你是否在你的代码里面使用过任何设计模式？"></a>2.什么是设计模式？你是否在你的代码里面使用过任何设计模式？</h2><p>设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式<br>是代码可用性的延伸。</p>
<p>模板方法模式定义一个操作中的算法的骨架，将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。</p>
<p>应用场景如下：</p>
<p>对于一些功能，在不同的对象身上展示不同的作用，但是功能的框架是一样的。</p>
<h2 id="3-Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式"><a href="#3-Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式" class="headerlink" title="3.Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式"></a>3.Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</h2><p>单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个<br>特定类实例，它被所有组件共同使用。Java.lang.Runtime 是单例模式的经典例子。从 Java<br>5 开始你可以使用枚举（enum）来实现线程安全的单例。</p>
<span id="more"></span>

<h2 id="4-在-Java-中，什么叫观察者设计模式（observer-design-pattern）？"><a href="#4-在-Java-中，什么叫观察者设计模式（observer-design-pattern）？" class="headerlink" title="4.在 Java 中，什么叫观察者设计模式（observer design pattern）？"></a>4.在 Java 中，什么叫观察者设计模式（observer design pattern）？</h2><p>观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例<br>子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象<br>是一个主体，而不同的视图是观察者。</p>
<h2 id="5-使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#5-使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="5.使用工厂模式最主要的好处是什么？在哪里使用？"></a>5.使用工厂模式最主要的好处是什么？在哪里使用？</h2><p>工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后<br>你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任<br>何修改。</p>
<h2 id="6-举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#6-举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h2><p>装饰模式增加强了单个对象的能力。Java IO 到处都使用了装饰模式，典型例子就是<br>Buffered 系列类如 BufferedReader 和 BufferedWriter，它们增强了 Reader 和 Writer 对象，<br>以实现提升性能的 Buffer 层次的读取和写入。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>常见面试</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础_索引结构_基础概念</title>
    <url>/2021/08/10/sql/mysql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="mysql的4大特性-4种隔离级别："><a href="#mysql的4大特性-4种隔离级别：" class="headerlink" title="mysql的4大特性+4种隔离级别："></a>mysql的4大特性+4种隔离级别：</h2><h3 id="4大特性即ACID"><a href="#4大特性即ACID" class="headerlink" title="4大特性即ACID"></a>4大特性即ACID</h3><ul>
<li>1 原子性。事务是一个不可分割的整体，事务开始的操作，要么全部执行，要么全部不执行。</li>
<li>2 隔离性。同一时间，只允许一个事务请求同一组数据。不同的事务彼此之间没有干扰。</li>
<li>3 一致性。事务开始前和结束后，数据库的完整性约束没有被破坏 。</li>
<li>4 稳定性。事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li>
</ul>
<h3 id="4种隔离级别"><a href="#4种隔离级别" class="headerlink" title="4种隔离级别"></a>4种隔离级别</h3><p>大多数数据库<strong>默认</strong>的事务隔离级别是<strong>Read committed</strong>，比如Sql Server , Oracle。<strong>Mysql的默认隔离级别是Repeatable read</strong>。</p>
<span id="more"></span>
<p>数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。</p>
<h4 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h4><p>就是一个事务可以读取另一个未提交事务的数据。 </p>
<h4 id="Read-committed-读提交"><a href="#Read-committed-读提交" class="headerlink" title="Read committed 读提交"></a>Read committed 读提交</h4><p>一个事务要等另一个事务提交后才能读取数据</p>
<h4 id="Repeatable-read-重复读"><a href="#Repeatable-read-重复读" class="headerlink" title="Repeatable read 重复读"></a>Repeatable read 重复读</h4><p>在开始读取数据（事务开启）时，不再允许修改操作</p>
<h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable  序列化"></a>Serializable  序列化</h4><p>全都顺序执行<br><br>除了防止脏读，不可重复读之外，还避免了幻象读(<strong>幻读专指新插入的行,原来查不到，再查查到了</strong>)</p>
<blockquote>
<p>相关系统命令：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置当前会话隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level repeatable read;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看系统当前隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.tx_isolation;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="binlog-redo-log-undo-log"><a href="#binlog-redo-log-undo-log" class="headerlink" title="binlog /redo log/undo log"></a>binlog /redo log/undo log</h2><ul>
<li>binlog我们可以简单理解为：存储着每条变更的SQL语句,以及事务id等，主要用来做主从同步和数据恢复</li>
<li>redo log 记载的是物理修改的内容（xxxx页修改了xxx）。是为了持久化而使用的（异步刷盘）</li>
<li>undo log主要存储的也是逻辑日志。主要有两个作用：回滚和多版本控制(MVCC)<h2 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h2>MVCC, Multiversion Concurrency Control多版本并发控制。MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作, 因此服务器的开销更低（减少了锁的生产和分配）。<br><br>MVCC只在 READ  COMMITTED 和 REPEATABLE  READ 两个隔离级别下工作。<blockquote>
<p>MVCC带来的好处是？<br></p>
</blockquote>
</li>
</ul>
<p>首先我们发现数据库并发场景有三种，分别为：</p>
<ul>
<li>读-读：不存在任何问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p>多版本并发控制（MVCC）是一种用来解决<strong>读-写冲突</strong>的<strong>无锁并发控制</strong>；<br><br>也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 <br>所以MVCC可以为数据库解决以下问题：<br></p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能<br></li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题<br></li>
</ul>
<blockquote>
<p>MVCC的实现原理</p>
</blockquote>
<p>它的实现原理主要是依赖记录中的 3个隐式字段(DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID)，undo日志 ，Read View 来实现的。</p>
<ul>
<li>DB_TRX_ID<ul>
<li>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
</ul>
</li>
<li>DB_ROLL_PTR<ul>
<li>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
</ul>
</li>
<li>DB_ROW_ID<ul>
<li>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
</ul>
</li>
<li>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<hr>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><p>mysql常用的引擎有<strong>InnoDB，MyISAM，Memory</strong>，默认是InnoDB。</p>
<p><strong>InnoDB</strong>：磁盘表，支持事务(Redo log 和Undo log和锁)，支持行级锁（默认行级锁），B+Tree索引</p>
<p>ps:优点： 具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。</p>
<p>缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大。</p>
<p><strong>MyISAM</strong>：磁盘表，不支持事务，不支持外键，支持表级锁，B+Tree索引</p>
<p>ps: 优点：占用空间小，处理速度快（相对InnoDB来说）,强调的是性能</p>
<p>缺点：不支持事务的完整性和并发性</p>
<p>**MEMORY(Heap)**：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型</p>
<p>ps: 优点：速度要求快的，临时数据</p>
<p>缺点：丢失以后，对项目整体没有或者负面影响不大的时候。</p>
<hr>
<h3 id="InnoDB详解"><a href="#InnoDB详解" class="headerlink" title="InnoDB详解"></a>InnoDB详解</h3><p><a href="http://www.liuzk.com/410.html">二叉树 -&gt; 平衡二叉树 -&gt; B树 -&gt; B+树</a></p>
<p>在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p>
<h4 id="聚集索引（也叫聚簇索引-clustered-index"><a href="#聚集索引（也叫聚簇索引-clustered-index" class="headerlink" title="聚集索引（也叫聚簇索引) (clustered index)"></a>聚集索引（也叫聚簇索引) (clustered index)</h4><p>聚集（clustered）索引，也叫聚簇索引。</p>
<blockquote>
<p>定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p>
</blockquote>
<p>这种以主键作为 B+ 树索引的键值而构建的 索引，我们称之为聚集索引。InnoDB聚集索引的叶子节点存储行记录。</p>
<p><strong>InnoDB必须要有，且只有一个聚集索引</strong>：</p>
<p>表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键：</p>
<p>（1）如果表定义了PK（主键），则PK就是聚集索引；</p>
<p>（2）如果表没有定义PK，则第一个not NULL unique列是聚集索引；</p>
<p>（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；</p>
<p>PS：所以PK查询非常快，直接定位行记录。</p>
<h4 id="非聚集索引（非聚簇索引）"><a href="#非聚集索引（非聚簇索引）" class="headerlink" title="非聚集索引（非聚簇索引）"></a>非聚集索引（非聚簇索引）</h4><blockquote>
<p>定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p>
</blockquote>
<p>以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。（一般我们建的非唯一索引的普通索引就是这种）</p>
<p>非聚集索引与聚集索引的区别在于<strong>非聚集索引</strong>的叶子节点<strong>不存储表中的数据</strong>，而是<strong>存储该列对应的主键</strong>，想要查找数据我们还需要根据主键<strong>再去聚集索引中进行查找</strong>，这个再根据聚集索引查找数据的过程，我们称为<strong>回表</strong>。</p>
<ol>
<li>使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。</li>
<li>非聚集索引在查询的时候可以的话就避免二次查询(回表)，这样性能会大幅提升。</li>
</ol>
<h3 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h3><ol>
<li>最左前缀匹配原则,mysql<strong>会从左至右匹配</strong>直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，范围查询<br>会导致组合索引半生效。比如 a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，c 可<br>以用到索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。where<br>范围查询要放在最后 （这不绝对，但可以利用一部分索引）。</li>
<li>尽量使用<strong>区分度较高</strong>的列作为索引，区分度的公式为： count(distinct column) / count(*)，用来表示字段不重复的比例，比例越大则代表扫描到的记录数越少，唯一键的区分度是1，而一些状态、性别等字段在大数据量下则无限趋近于0，所以类似性别字段不宜作为区分度的索引列。</li>
<li>尽量扩展索引列而不是新建索引列（这会增加系统负担）。比如，表中已经有了a列的索引，现在需要加入b列的索引，则需要修改原来的索引即可。</li>
<li>对于经常存取的列避免建立索引。</li>
<li>所有的“非”类型的判断不会走索引( not , not in, not like, &lt;&gt;, != ,!&gt;,!&lt;  )。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引结构</tag>
        <tag>隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2021/08/10/sql/mybatis/</url>
    <content><![CDATA[<ol>
<li>#{}和${}的区别是什么？</li>
</ol>
<ul>
<li>#{}是预编译处理#{}可以防止Sql 注入，它会将所有传入的参数作为一个字符串来处理。</li>
<li>${}是字符串替换。${} 则将传入的参数拼接到Sql上去执行，一般用于表名和字段名参数，$ 所对应的参数应该由服务器端提供，前端可以用参数进行选择，避免 Sql 注入的风险<br>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理时，就是把{}替换成变量的值。<br><br>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>
</ul>
<ol start="2">
<li>Mybatis是如何进行<strong>分页</strong>的？分页插件的原理是什么？<br><br>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的<strong>内存分页</strong>，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br><br>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。<br></li>
</ol>
<span id="more"></span>
<ol start="3">
<li><p>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？<br><br>第一种是<strong>使用&lt;resultMap&gt;标签</strong>，逐一定义列名和对象属性名之间的映射关系。<br><br>第二种是使用sql列的<strong>别名功能</strong>，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。<br>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
</li>
<li><p>Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？<br><br>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。</p>
</li>
<li><p>简述Mybatis的<strong>插件运行原理，以及如何编写一个插件</strong><br><br>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件.<br>Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</p>
</li>
</ol>
<ol start="6">
<li>一级、二级缓存<br><br>1）一级缓存: 基于 <strong>PerpetualCache 的 HashMap 本地缓存</strong>，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。<br><br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">&lt;cache/&gt;</span><br><span class="line">````</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"><span class="number">3</span>）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 <span class="keyword">select</span> 中的缓存将被 clear。&lt;br/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？&lt;br/&gt;</span><br><span class="line">    Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。&lt;br/&gt;</span><br><span class="line">    在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=<span class="literal">true</span>|<span class="literal">false</span>。&lt;br/&gt;</span><br><span class="line">    它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是<span class="literal">null</span>值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> <span class="meta"># Mybatis 获得自动生成主键值</span></span><br><span class="line"></span><br><span class="line">  对于支持自动生成主键的数据库，如Mysql、sqlServer，可以通过 Mybatis元素**useGeneratedKeys**返回当前插入数据主键值到输入类中。</span><br><span class="line"></span><br><span class="line">  对于不支持自动生成主键的数据库。Oracle、DB2等，可以用**元素selectKey **回当前插入数据主键值到输入类中。（同时生成一个自定义的随机主键）。</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> <span class="meta"># Mybatis 在 mapper 中如何传递多个参数</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、第一种：</span><br><span class="line">DAO 层的函数</span><br><span class="line">public UserselectUser(<span class="built_in">String</span> name,<span class="built_in">String</span> area)<span class="comment">;</span></span><br><span class="line">对应的 xml,<span class="meta">#&#123;0&#125;代表接收的是 dao 层中的第一个参数，#&#123;1&#125;代表 dao 层中第二</span></span><br><span class="line">参数，更多参数一致往后加即可。</span><br><span class="line"></span><br><span class="line">```&lt;<span class="keyword">select</span> id=<span class="string">&quot;selectUser&quot;</span>resultMap=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span><br><span class="line"><span class="keyword">select</span> * fromuser_user_t whereuser_name = <span class="meta">#&#123;0&#125;</span></span><br><span class="line">anduser_area=<span class="meta">#&#123;1&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2、第二种： 使用 @param 注解:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">usermapper</span> &#123;</span><br><span class="line"><span class="selector-tag">user</span> <span class="selector-tag">selectuser</span>(<span class="variable">@param</span>(“username”) string</span><br><span class="line">username,<span class="variable">@param</span>(“hashedpassword”) string hashedpassword);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给 mapper):</p>
<figure class="highlight plain"><figcaption><span>id</span></figcaption><table><tr><td class="code"><pre><span class="line">select id, username, hashedpassword</span><br><span class="line">from some_table</span><br><span class="line">where username &#x3D; #&#123;username&#125;</span><br><span class="line">and hashedpassword &#x3D; #&#123;hashedpassword&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>3、第三种：多个参数封装成 map</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="regexp">//映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的</span></span><br><span class="line"><span class="regexp">SQL</span></span><br><span class="line"><span class="regexp">//</span>由于我们的参数超过了两个，而方法中只有一个 <span class="built_in">Object</span> 参数收集，因此</span><br><span class="line">我们使用 <span class="built_in">Map</span> 集合来装载我们的参数</span><br><span class="line"><span class="built_in">Map</span> &lt; <span class="built_in">String</span>, <span class="built_in">Object</span> &gt; <span class="keyword">map</span> = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">map</span>.put(<span class="string">&quot;start&quot;</span>, start);</span><br><span class="line"><span class="keyword">map</span>.put(<span class="string">&quot;end&quot;</span>, end);</span><br><span class="line"><span class="keyword">return</span> sqlSession.selectList(<span class="string">&quot;StudentID.pagination&quot;</span>, <span class="keyword">map</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">sqlSession.rollback();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">MybatisUtil.closeSqlSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="嵌套查询和嵌套结果"><a href="#嵌套查询和嵌套结果" class="headerlink" title="嵌套查询和嵌套结果"></a>嵌套查询和嵌套结果</h1><table>
<thead>
<tr>
<th align="center">嵌套查询</th>
<th align="center">嵌套结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">嵌套查询是在查询 SQL 后再进行一个（子）查询</td>
<td align="center">嵌套结果是一个多表查询的 SQL 语句</td>
</tr>
<tr>
<td align="center"><strong>会执行多条 SQL 语句</strong></td>
<td align="center"><strong>只有一条复杂的 SQL 语句（多表连接）</strong></td>
</tr>
<tr>
<td align="center">SQL语句编写较为简单</td>
<td align="center">SQL语句编写较为复杂</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之ThreadLocal</title>
    <url>/2021/08/10/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[<h2 id="ThreadLocal原理和用法"><a href="#ThreadLocal原理和用法" class="headerlink" title="ThreadLocal原理和用法"></a>ThreadLocal原理和用法</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><ul>
<li>ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，<br>但不会和其他线程的局部变量进行冲突，实现了线程的<strong>数据隔离</strong>。</li>
<li>实现线程级别的全局变量,避免使用一层层的传参。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Requestcontext</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;<span class="keyword">String</span>&gt; traceldLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">getTraceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadIdLocal.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">setTraceId</span> <span class="params">(<span class="keyword">String</span> traceld)</span></span>&#123;</span><br><span class="line">            threadldLocal.<span class="built_in">set</span>(traceld);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*一处设置traceid*/</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Requestcontext</span>.</span></span>set<span class="constructor">TraceId(UUID.<span class="params">randomUUID</span>()</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line"><span class="comment">/*另一处读取traceId，不在同一个类中调用*/</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">RequestContext</span>.</span></span>get<span class="constructor">TraceId()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用举例:<br><br>java8之前的日期组件,SimpleDataFormat。当我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()，如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。从而导致了线程安全问题。当然我们可以每用一次new一个新对象出来，不过这样效率太低。<br><br>所以我们可以使用了线程池加上ThreadLocal包装SimpleDataFormat，再调用initialValue让每个线程有一个SimpleDataFormat的副本，从而解决了线程安全的问题，也提高了性能。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="module-access"><span class="module"><span class="identifier">ThreadLocal</span>.</span></span><span class="keyword">with</span><span class="constructor">Initial(SimpleDateFormat::<span class="params">new</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>不过Java8之后可以用java.time.format.DateTimeFormatter了。</p>
<h4 id="注意（弱引用引起的内存泄露问题）："><a href="#注意（弱引用引起的内存泄露问题）：" class="headerlink" title="注意（弱引用引起的内存泄露问题）："></a>注意（弱引用引起的内存泄露问题）：</h4><p>当线程没有结束，但是 ThreadLocal 已经被回收，则可能导致线程中存在ThreadLocalMap&lt;null, Object&gt; 的键值对，造成内存泄露。(ThreadLocal 被回收，ThreadLocal 关联的线程共享变量还存在。<br></p>
<p>解决方案：<br></p>
<ol>
<li>使用完线程共享变量后，显式调用 ThreadLocalMap.remove 方法清除线程共享变量。</li>
</ol>
<hr>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>简单说 ThreadLocal 就是一种以空间换时间的做法，在每个 Thread 里面维护了一个以开放定址法(区别于hashmap，没有链表，发生冲突时往后找空位就行了)实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
<p>结构图：<br><br><img src="/2021/08/10/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal/ThreadLocal_structure.jpg" alt="ThreadLocal"><br>每个Thread对象中都维护了一个ThreadLocalMap，这个Map使用ThreadLocal对象作为key。<br><br>可以看到的是，ThreadLocal对象虽然是同一个，但是每个线程中的ThreadLocalMap都是单独的，所以各个线程之间是互不影响的。具体数据则时放在ThreadLocalMap的entry数组下的。</p>
<h3 id="父子线程怎么共享数据"><a href="#父子线程怎么共享数据" class="headerlink" title="父子线程怎么共享数据"></a>父子线程怎么共享数据</h3><p>可以使用<strong>interitableThreadLocals</strong>，子线程能继承到父线程的数据，子线程中的修改不影响父线程。</p>
<p>private</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 和 ReentrantLock</title>
    <url>/2021/08/10/java%E5%9F%BA%E7%A1%80/java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BReentrantlock/</url>
    <content><![CDATA[<h2 id="经典面试题："><a href="#经典面试题：" class="headerlink" title="经典面试题："></a>经典面试题：</h2><h4 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p>相同点：</p>
<p>它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的。可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。</p>
<p><strong>区别：</strong></p>
<ol>
<li>synchronized 竞争锁时会一直等待；ReentrantLock 可以尝试获取锁，并得到获取结果</li>
<li>synchronized 获取锁无法设置超时；ReentrantLock 可以设置获取锁的超时时间</li>
<li>synchronized 无法实现公平锁；ReentrantLock 可以满足公平锁，即先等待先获取到锁</li>
<li>synchronized 控制等待和唤醒需要结合加锁对象的 wait() 和 notify()、notifyAll()；ReentrantLock 控制等待和唤醒需要结合 Condition 的 await() 和 signal()、signalAll() 方法</li>
<li>synchronized 是 JVM 层面实现的；ReentrantLock 是 JDK 代码层面实现</li>
<li>synchronized 在加锁代码块执行完或者出现异常，自动释放锁；ReentrantLock 不会自动释放锁，需要在 finally{} 代码块显示释放</li>
<li>锁的细粒度和灵活度，很明显ReenTrantLock优于Synchronized。</li>
</ol>
<p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似。</p>
<ul>
<li>AQS（AbstractQueuedSynchronizer）抽象的队列式的同步器。是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建。<br>AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus</li>
</ul>
<p>ReentrantLock的基本实现可以概括为：先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：</p>
<p>非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；</p>
<p>公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        doSomeThing();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/fuyuwei2015/article/details/83719444">ReentrantLock原理</a>    </p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础提升_数据结构篇</title>
    <url>/2021/08/10/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基础结构和特点"><a href="#基础结构和特点" class="headerlink" title="基础结构和特点"></a>基础结构和特点</h2><ul>
<li>Map </li>
</ul>
<blockquote>
<p>键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</p>
</blockquote>
<blockquote>
<p>某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</p>
</blockquote>
<blockquote>
<p>Map中元素，可以将key序列、value序列单独抽取出来。<br>使用keySet()抽取key序列，将map中的所有keys生成一个Set。<br>使用values()抽取value序列，将map中的所有values生成一个Collection。<br>为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。</p>
</blockquote>
<ul>
<li>Set</li>
</ul>
<blockquote>
<p>一个<strong>不包含重复元素</strong>的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。</p>
</blockquote>
<blockquote>
<p>不可随机访问包含的元素<br> 只能用Iterator实现单向遍历<br>Set 没有同步方法</p>
</blockquote>
<ul>
<li>List</li>
</ul>
<blockquote>
<p>可随机访问包含的元素<br> 元素是==有序==的<br> 可在任意位置增、删元素<br> 不管访问多少次，元素位置不变<br> 允许重复元素<br> 用Iterator实现单向遍历，也可用ListIterator实现双向遍历 </p>
</blockquote>
<ul>
<li>Queue</li>
</ul>
<blockquote>
<p>先进先出</p>
<p>Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。 如果要使用前端而不移出该元素，使用element()或者peek()方法。<br>值得注意的是LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p>
</blockquote>
<blockquote>
<p>Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。</p>
</blockquote>
<ul>
<li>Stack</li>
</ul>
<blockquote>
<p>后进先出</p>
<p>Stack继承自Vector（可增长的对象数组），也是同步的<br>它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到<strong>堆栈顶</strong>距离的 search 方法。</p>
</blockquote>
<ul>
<li>用法</li>
</ul>
<blockquote>
<p>如果涉及到堆栈、队列等操作，应该考虑用List；</p>
</blockquote>
<blockquote>
<p>对于需要快速插入，删除元素，应该使用LinkedList；</p>
</blockquote>
<blockquote>
<p>如果需要快速随机访问元素，应该使用ArrayList。</p>
</blockquote>
<blockquote>
<p>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高 - Map </p>
</blockquote>
<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><ul>
<li>List , Set, Map都是接口，前两个继承至Collection接口，Map为独立接口</li>
<li>Set下有HashSet，LinkedHashSet，TreeSet</li>
<li>List下有ArrayList，Vector，LinkedList</li>
<li>Map下有Hashtable，LinkedHashMap，HashMap，TreeMap</li>
<li>Collection接口下还有个Queue接口，有PriorityQueue类</li>
</ul>
<p><img src="/2021/08/10/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/collection.jpeg" alt="collection"></p>
<hr>
<h2 id="ArrayList、LinkedList、Vector的区别"><a href="#ArrayList、LinkedList、Vector的区别" class="headerlink" title="ArrayList、LinkedList、Vector的区别"></a>ArrayList、LinkedList、Vector的区别</h2><p>List的三个子类的特点</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList:"></a>ArrayList:</h3><ul>
<li>底层数据结构是数组，查询快，增删慢。</li>
<li>线程不安全，效率高。</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h3><ul>
<li>底层数据结构是数组，查询快，增删慢。</li>
<li>线程安全，效率低。</li>
<li>Vector相对ArrayList查询慢(线程安全的)。</li>
<li>Vector相对LinkedList增删慢(数组结构)。</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>底层数据结构是链表，查询慢，增删快。</li>
<li>线程不安全，效率高。</li>
</ul>
<h3 id="Vector和ArrayList的区别"><a href="#Vector和ArrayList的区别" class="headerlink" title="Vector和ArrayList的区别"></a>Vector和ArrayList的区别</h3><ul>
<li>Vector是线程安全的,效率低。</li>
<li>ArrayList是线程不安全的,效率高。</li>
<li>共同点:底层数据结构都是数组实现的,查询快,增删慢。</li>
</ul>
<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><ul>
<li>ArrayList底层是动态数组结构,<strong>查询和修改快</strong>。</li>
<li>LinkedList底层是链表结构的,<strong>增和删比较快</strong>,查询和修改比较慢。</li>
<li>共同点:都是线程不安全的</li>
</ul>
<hr>
<h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><h3 id="什么是HashMap"><a href="#什么是HashMap" class="headerlink" title="什么是HashMap"></a>什么是HashMap</h3><p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。</p>
<h3 id="hashmap结构；"><a href="#hashmap结构；" class="headerlink" title="hashmap结构；"></a>hashmap结构；</h3><p>JAVA7:HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。包含四个属性：key, value, hash 值和用于单向链表的 next；</p>
<p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了<strong>红黑树</strong>，所以其由 数组+链表+红黑树组成；</p>
<p>查找时需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。一棵含有n个节点的红黑树的高度至多为2log(n+1).</p>
<h3 id="Entry节点在插入链表的方式"><a href="#Entry节点在插入链表的方式" class="headerlink" title="Entry节点在插入链表的方式"></a>Entry节点在插入链表的方式</h3><p><strong>java8之前是头插法</strong>，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。（Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系）</p>
<p>但是，<strong>在java8之后，都是所用尾部插入了。</strong></p>
<h3 id="什么对象能做为key"><a href="#什么对象能做为key" class="headerlink" title="什么对象能做为key?"></a>什么对象能做为key?</h3><p>重写过hashCode和equals的对象，才能做为key，如果要将对象做为key，需要重写hashCode和equals。null可以做为key值，null也可以做为value值。<br>时间复杂度：理想情况下是 O(1)的，但是实际中会出现 hash 碰撞，导致无法达到效果。</p>
<p><a href="https://blog.csdn.net/zxt0601/article/details/77413921">HASHMAP源码解析</a>    </p>
<hr>
<h2 id="hashtable-concurrentHashMap-hashtable比较"><a href="#hashtable-concurrentHashMap-hashtable比较" class="headerlink" title="hashtable,concurrentHashMap,hashtable比较"></a>hashtable,concurrentHashMap,hashtable比较</h2><ul>
<li>Hashtable：底层数组+链表实现，<strong>无论key还是value都不能为null</strong>，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化；</li>
<li>Hashmap：底层数组+链表实现，<strong>可以存储null键和null值</strong>，线程不安全。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象<br>。</li>
<li>ConcurrentHashMap：分段锁概念实现，相当于多个hashtable，底层采用分段的数组+链表实现，线程安全。</li>
</ul>
<h2 id="什么是HashSet"><a href="#什么是HashSet" class="headerlink" title="什么是HashSet"></a>什么是HashSet</h2><p>HashSet实现了Set接口，它<strong>不允许集合中有重复的值</strong>，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。</p>
<p>public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。</p>
<p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p>
<h3 id="hashmap和hashset比较"><a href="#hashmap和hashset比较" class="headerlink" title="hashmap和hashset比较"></a>hashmap和hashset比较</h3><table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap实现了Map接口</td>
<td>HashSet实现了Set接口       HashMap储存键值对</td>
</tr>
<tr>
<td>使用put()方法将元素放入map中</td>
<td>使用add()方法将元素放入set</td>
</tr>
<tr>
<td>HashMap中使用键对象来计算hashcode值</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap比较快，因为是使用唯一的键来获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础_基础特征和相关概念</title>
    <url>/2021/08/05/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E7%89%B9%E5%BE%81%E5%92%8C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="面向对象的三大基本特征，五大基本原则"><a href="#面向对象的三大基本特征，五大基本原则" class="headerlink" title="面向对象的三大基本特征，五大基本原则"></a>面向对象的三大基本特征，五大基本原则</h1><h2 id="三大基本特征：封装、继承、多态"><a href="#三大基本特征：封装、继承、多态" class="headerlink" title="三大基本特征：封装、继承、多态"></a>三大基本特征：<strong>封装、继承、多态</strong></h2><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h3><p>　　封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。<br>封装的<strong>目的</strong>是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。<br>（面向对象的不就是使用程序处理事情时以对象为中心去分析吗，与面向过程不同，面向过程关心处理的逻辑、流程等问题，而不关心事件主体。而面向对象即面向主体，所以我们在解决问题时应该先进行对象的封装（对象是封装类的实例，比如张三是人，人是一个封装类，张三只是对象中的一个实例、一个对象）。比如我们日常生活中的小兔子、小绵羊都可以封装为一个类）。</p>
<h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><p>　　继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h3><p>　　多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p>多态存在的三个<strong>必要条件</strong>：</p>
<ul>
<li>继承</li>
<li>重写（子类继承父类后对父类方法进行重新定义）</li>
<li>父类引用指向子类对象</li>
</ul>
<p>多态的优点：</p>
<ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<p>　　简言之，多态其实是在继承的基础上的。比如说今天我们要去动物园参观动物，那么你说我们去参观兔子、参观绵羊、参观狮子、参观豹子都是对的，但你不能说我们去参观汽车。在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。</p>
<p>ps可参照此篇博文:<a href="https://www.cnblogs.com/vamei/archive/2013/04/01/2992662.html">https://www.cnblogs.com/vamei/archive/2013/04/01/2992662.html</a></p>
<span id="more"></span>

<p>扩展知识点：</p>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>运行时类型识别(RTTI, Run-Time Type Identification)是Java中非常有用的机制，在Java运行时，RTTI维护类的相关信息。<br>多态(polymorphism)是基于RTTI实现的。RTTI的功能主要是由Class这个类实现的。
　　</p>
<h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><h3 id="1、单一职责原则（SRP）"><a href="#1、单一职责原则（SRP）" class="headerlink" title="1、单一职责原则（SRP）"></a>1、单一职责原则（SRP）</h3><p>　　一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。</p>
<p>　　比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要if else判断是哪种情况，从类结构上来说将会十分臃肿。</p>
<h3 id="2、开放封闭原则（OCP）"><a href="#2、开放封闭原则（OCP）" class="headerlink" title="2、开放封闭原则（OCP）"></a>2、开放封闭原则（OCP）</h3><p>　　对象或实体应该对扩展开放，对修改封闭。</p>
<p>　　更改封闭即是在我们对模块进行扩展时，勿需对原有程序代码和DLL进行修改或重新编译文件！这个原则对我们在设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术！</p>
<h3 id="3、里氏替换原则（LSP）"><a href="#3、里氏替换原则（LSP）" class="headerlink" title="3、里氏替换原则（LSP）"></a>3、里氏替换原则（LSP）</h3><p>　　在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类）</p>
<h3 id="4、依赖倒置原则（DIP）"><a href="#4、依赖倒置原则（DIP）" class="headerlink" title="4、依赖倒置原则（DIP）"></a>4、依赖倒置原则（DIP）</h3><p>　　高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。</p>
<p>　　可以这样理解，上面我举例子的时候先说了兔子和绵羊，然后才推出食草动物。但如果我们继续认识了牛、马等食草动物，我们会发现我们需要不断调整食草动物的描述，这样程序会变得僵化，所以我们不应该让子类依赖于实体，不应该让父类模块依赖于子类模块。所以我们需要将食草动物设计为抽象类，即抽象类或接口。这样下层只需要实现相应的细节而不会影响父类。</p>
<h3 id="5、接口隔离原则（ISP）"><a href="#5、接口隔离原则（ISP）" class="headerlink" title="5、接口隔离原则（ISP）"></a>5、接口隔离原则（ISP）</h3><p>　　不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法，使用多个专门的接口比使用单个接口要好的多！</p>
<p>　　比如，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后会发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！</p>
<hr>
<h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><p>基本类型变量的值传递，意味着变量本身被复制，并传递给Java方法。<strong>Java方法对变量的修改不会影响到原变量</strong>。</p>
<p>引用的值传递，意味着对象的地址被复制，并传递给Java方法。<strong>Java方法根据该引用的访问将会影响对象</strong>。</p>
<p>即 基础类型可以直接用= 赋值，不会影响原变量，而复合类型使用=赋值时，之后复合变量改变后，原值也会改变</p>
<hr>
<h1 id="java基础类和对应封装类"><a href="#java基础类和对应封装类" class="headerlink" title="java基础类和对应封装类"></a>java基础类和对应封装类</h1><table>
<thead>
<tr>
<th>基本类型</th>
<th>大小（字节）</th>
<th>默认值</th>
<th>封装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>byte（0）</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>\uoooo(null)</td>
<td>Character</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>short（0）</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>Double</td>
</tr>
</tbody></table>
<p>注：提供封装类是为了更好的对数据基本类型进行操作。java的集合部分，只允许存储引用类型。</p>
<hr>
<h2 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h2><ol>
<li>使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。</li>
<li>==是判断两个变量或实例是不是指向同一个内存空间。 equals是判断两个变量或实例所指向的内存空间的值是不是相同。</li>
<li>==是指对内存地址进行比较。 equals()是对字符串的内容进行比较。</li>
<li>==指引用是否相同。 equals()指的是值是否相同。</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>参考：<br><br><a href="https://www.cnblogs.com/coprince/p/8603492.html">https://www.cnblogs.com/coprince/p/8603492.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>基础概念</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础提升_IO模型</title>
    <url>/2021/08/05/java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87_IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在研究java的IO模型前有必要先对操作系统的IO模型有个认识。</p>
<h1 id="操作系统层面的IO模型"><a href="#操作系统层面的IO模型" class="headerlink" title="操作系统层面的IO模型"></a>操作系统层面的IO模型</h1><p>在Linux(UNIX)操作系统中，共有五种IO模型，分别是：</p>
<ol>
<li><p><strong>阻塞IO模型</strong></p>
<ul>
<li>阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。</li>
</ul>
</li>
<li><p><strong>非阻塞IO模型</strong></p>
<ul>
<li>应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。</li>
</ul>
</li>
<li><p><strong>IO复用模型</strong></p>
<ul>
<li>多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。</li>
</ul>
</li>
<li><p><strong>信号驱动IO模型</strong></p>
<ul>
<li>应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>以上模型都是<strong>同步</strong>的，原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行的。信号驱动IO模型只能说 数据准备阶段是异步，数据拷贝操作还是同步的。只有<strong>系统将数据已经全都从内核空间拷贝到用户空间然后再发信号通知线程已经完成</strong>。</p>
</blockquote>
<ol start="5">
<li><strong>异步IO模型</strong>。<ul>
<li>应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。</li>
</ul>
</li>
</ol>
<hr>
<span id="more"></span>

<h1 id="java中三种IO模型"><a href="#java中三种IO模型" class="headerlink" title="java中三种IO模型"></a>java中三种IO模型</h1><p><strong>在Java中，主要有三种IO模型：</strong></p>
<ul>
<li>阻塞IO（BIO/Blocking I/O）<ul>
<li><strong>同步阻塞</strong>I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</li>
</ul>
</li>
<li>非阻塞IO（NIO）<ul>
<li>一种叫非阻塞IO（Non-blocking I/O），另一种也叫新的IO（New I/O），其实是同一个概念。它是一种<strong>同步非阻塞</strong>的I/O模型，也是<strong>I/O多路复用的基础</strong>。</li>
<li>NIO是一种基于<strong>通道和缓冲区</strong>的I/O方式，它可以使用Native函数库<strong>直接分配堆外内存</strong>（区别于JVM的运行时数据区），然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的直接引用进行操作。这样能在一些场景显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li>
</ul>
</li>
<li>异步IO（AIO/Asynchronous I/O）<ul>
<li>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是<strong>异步非阻塞</strong>的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。(目前来说使用还不广泛，netty使用的是NIO)</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="NIO与BIO的区别"><a href="#NIO与BIO的区别" class="headerlink" title="NIO与BIO的区别"></a>NIO与BIO的区别</h2><p>1）BIO以流的方式处理数据，而NIO以<strong>块的方式</strong>处理数据，块I/O的效率比流I/O高很多；</p>
<p>2）BIO是阻塞的，NIO是<strong>非阻塞</strong>的；</p>
<p>3）BIO基于字节流和字符流进行操作，而NIO基于<strong>Channel（通道）和Buffer（缓冲区）进行操作</strong>，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<strong>Selector（选择器）用于监听多个通道</strong>的时间（比如：连接请求，数据到达等），因此使用<strong>单个线程就可以监听多个客户端通道</strong>；</p>
<p>4）BIO是单向的，如：InputStream, OutputStream；而<strong>NIO是双向的</strong>，既可以用来进行读操作，又可以用来进行写操作。</p>
</blockquote>
<h1 id="NIO主要组件介绍"><a href="#NIO主要组件介绍" class="headerlink" title="NIO主要组件介绍"></a>NIO主要组件介绍</h1><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer（缓冲区）是一个用于存储特定基本类型数据的容器。除了boolean外，其余每种基本类型都有一个对应的buffer类。</p>
<p>Buffer类的子类(基础类型中<strong>除了boolean</strong>外都有对应的buffer)有：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<h3 id="Buffer常用方法"><a href="#Buffer常用方法" class="headerlink" title="Buffer常用方法"></a>Buffer常用方法</h3><ol>
<li>建立缓冲区分配容量：allocate(capacity)</li>
<li>装载数据：put() 及其重载方法</li>
<li>改变缓冲区的读写模式：flip()</li>
<li>获取数据：get() 及其重载方法</li>
<li>标记：mark()/reset()</li>
<li>判断：remaining()：返回当前位置与限制之间的元素数；<br>hasRemaining()：判断当前位置与限制之间是否还有元素存在；<br>isReadOnly()：判断此缓冲区是否为只读缓冲区；<br>clear()：清空缓冲区，只是将缓冲区的三个属性恢复到初始状态，其中的数据依然存在。</li>
</ol>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel（通道）表示到实体，如硬件设备、文件、网络套接字或可以执行一个或多个不同 I/O 操作（如读取或写入）的程序组件的开放的连接。</p>
<p>Channel接口的常用实现类有：</p>
<ul>
<li>FileChannel（对应文件IO）</li>
<li>DatagramChannel（对应UDP）</li>
<li>SocketChannel和ServerSocketChannel（对应TCP的客户端和服务器端）</li>
</ul>
<p>Channel和IO中的Stream（流）是差不多一个等级的。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector（选择器）用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。即用选择器，借助单一线程，就可对数量庞大的活动I/O通道实施监控和维护。</p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>IO多路复用（IO Multiplexing) 是这么一种机制：程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”。</p>
<p>IO多路复用是要和NIO一起使用的。尽管在操作系统级别，NIO和IO多路复用是两个相对独立的事情。NIO仅仅是指IO API总是能立刻返回，不会被Blocking；而IO多路复用仅仅是操作系统提供的一种便利的通知机制。操作系统并不会强制这俩必须得一起用——你可以用NIO，但不用IO多路复用；也可以只用IO多路复用 + BIO，这时效果还是当前线程被卡住。但是，<strong>IO多路复用和NIO是要配合一起使用才有实际意义</strong>。因此，在使用IO多路复用之前，请总是先把fd设为<code>O_NONBLOCK</code>。</p>
<p>对IO多路复用，还存在一些常见的误解，比如：</p>
<ul>
<li><p><strong>❌IO多路复用是指多个数据流共享同一个Socket</strong>。其实IO多路复用说的是多个Socket，只不过操作系统是一起监听他们的事件而已。</p>
<blockquote>
<p>多个数据流共享同一个TCP连接的场景的确是有，比如Http2 Multiplexing就是指Http2通讯中中多个逻辑的数据流共享同一个TCP连接。但这与IO多路复用是完全不同的问题。</p>
</blockquote>
</li>
<li><p><strong>❌IO多路复用是NIO，所以总是不Block的</strong>。其实IO多路复用的关键API调用(<code>select</code>，<code>poll</code>，<code>epoll_wait</code>）总是Block的。</p>
</li>
<li><p>❌<strong>IO多路复用和NIO一起减少了IO</strong>。实际上，IO本身（网络数据的收发）无论用不用IO多路复用和NIO，都没有变化。请求的数据该是多少还是多少；网络上该传输多少数据还是多少数据。IO多路复用和NIO一起仅仅是解决了调度的问题，避免CPU在这个过程中的浪费，使系统的瓶颈更容易触达到网络带宽，而非CPU或者内存。要提高IO吞吐，还是提高硬件的容量（例如，用支持更大带宽的网线、网卡和交换机）和依靠并发传输（例如HDFS的数据多副本并发传输）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>IO模型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>BIO</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式_单例模式</title>
    <url>/2021/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式是比较常见的一种设计模式，目的是保证<strong>一个类只能有一个实例</strong>，而且<strong>自行实例化</strong>（不对外开放new ）并向整个系统提供这个实例，避免频繁创建对象，节约内存。</p>
<h1 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h1><ul>
<li>多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。</li>
<li>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>网站的计数器，一般也是采用单例模式实现，否则难以同步<h1 id="饿汉式和懒汉式，"><a href="#饿汉式和懒汉式，" class="headerlink" title="饿汉式和懒汉式，"></a>饿汉式和懒汉式，</h1>饿汉式：提前创建对象。在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。<br><br>懒汉式：延迟创建对象。在类加载时不初始化，等到第一次被使用时才初始化。</li>
</ul>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在类加载的时候就完成了实例化，避免了多线程的同步问题。缺点就是浪费内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><p>这种写法用了两个if判断，也就是Double-Check，并且同步的不是方法，而是代码块，效率较高</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么要做两次判断呢？这是为了线程安全考虑，还是那个场景，对象还没实例化，两个线程A和B同时访问静态方法并同时运行到第一个if判断语句，这时线程A先进入同步代码块中实例化对象，结束之后线程B也进入同步代码块，如果没有第二个if判断语句，那么线程B也同样会执行实例化对象的操作了。</p>
</blockquote>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成对象的实例化。</p>
<p>同时，因为类的静态属性只会在第一次加载类的时候初始化，也就保证了SingletonInstance中的对象只会被实例化一次，并且这个过程也是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        Singleton.INSTANCE.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java错题集</title>
    <url>/2021/08/03/java%E5%9F%BA%E7%A1%80/Java%E9%94%99%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<ol>
<li>String.split()<br><br>使用,时可以不用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsplit</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String s = <span class="string">&quot;119001,119002&quot;</span>;</span><br><span class="line">      List&lt;String&gt; slst = Arrays.asList(s.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">      <span class="comment">//split里面是正则  使用|时要转义！！！！</span></span><br><span class="line">      <span class="comment">//List&lt;String&gt; slst = Arrays.asList(s.split(&quot;\\|&quot;));</span></span><br><span class="line">      <span class="keyword">for</span>(String i :slst)&#123;</span><br><span class="line">          System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">slst.contain(<span class="string">&quot;119001&quot;</span>);<span class="comment">//return true</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>错题集</category>
      </categories>
      <tags>
        <tag>错题集</tag>
      </tags>
  </entry>
  <entry>
    <title>编程基础之网络知识篇</title>
    <url>/2021/08/03/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP/</url>
    <content><![CDATA[<h1 id="IP分类（IPV4）"><a href="#IP分类（IPV4）" class="headerlink" title="IP分类（IPV4）"></a>IP分类（IPV4）</h1><p>IP地址由四段组成，每个字段是一个字节，8位，最大值是255。<br><br>IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。<br><br>IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。<br><br><img src="/2021/08/03/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BIP/five-ipv4.png" alt="IP分类"></p>
<p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。   全0和全1的都保留不用。</p>
<p>A类：(<strong>1.0.0.0-126.0.0.0</strong>)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</p>
<p>B类：(<strong>128.0.0.0-191.255.0.0</strong>)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</p>
<p>C类：(<strong>192.0.0.0-223.255.255.0</strong>)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</p>
<p>D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1]  。</p>
<p>E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><ul>
<li><p>作用：首相IP地址是以网络号和主机号来标示网络上的主机，子网掩码就是用来标记ip中哪些位是表示的网络号，哪些是主机位。</p>
</li>
<li><p>表示：同IP地址一样，子网掩码是由长度为<strong>32位二进制</strong>数组成的一个地址，IP地址如果某位是<strong>网络地址</strong>，则子网掩码为<strong>1</strong>，主机地址则为0。</p>
</li>
<li><p>子网掩码的表示方式：</p>
<p>例子：192.168.1.100/24，其子网掩码表示为255.255.255.0，二进制表示为11111111.11111111.11111111.00000000</p>
<pre><code>- **点分十进制表示法**（”例子中的255.255.255.0“）
- **CIDR斜线记法**（例子中的”/24“）
</code></pre>
</li>
</ul>
<h2 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h2><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：<br>A类地址：10.0.0.0～10.255.255.255<br>B类地址：172.16.0.0～172.31.255.255<br>C类地址：192.168.0.0～192.168.255.255</p>
<p>回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP/IP是否正常。</p>
]]></content>
      <categories>
        <category>网络</category>
        <category>IP</category>
      </categories>
      <tags>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>股票主要技术指标解析</title>
    <url>/2021/08/03/k%E7%BA%BF%E6%8C%87%E6%A0%87/%E8%82%A1%E7%A5%A8%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="MA"><a href="#MA" class="headerlink" title="MA"></a>MA</h1><p>Moving Average - 移动平均线 ，将一定时期内的证券价格（指数）<strong>加以平均</strong>，并把不同时间的<strong>平均值</strong>连接起来，形成一根MA，用以观察证券价格变动趋势的一种技术指标。</p>
<ul>
<li>MA(X,N)，X的N日简单移动平均，算法为(X1+X2+X3+…+Xn)/N。</li>
</ul>
<h2 id="SMA"><a href="#SMA" class="headerlink" title="SMA"></a>SMA</h2><p>Simple Moving Average-简单移动平均,  对近期数值可以赋予更高权重，这也是SMA和MA最明显的区别。</p>
<ul>
<li><p>SMA（x，n，m），X的N日移动平均，M为权重，如Y=(X<em>M+Y’</em>(N-M))/N。其中Y’表示上一周期Y值，N必须大于M</p>
</li>
<li><p>SMA=p1+(1-a)*p2+(1-a)² *p3+(1-a)³ *p4+…/1+(1-a)+(1-a)²+(1-a)³+…</p>
<p>随着时间的回推，数值的权重呈现指数级缩小，由此SMA可以达到给予近期数值更高的权重，更贴合市场价格的表现。(p1当天价格，p2昨天价格。。。，a为平滑指数)</p>
</li>
</ul>
<h2 id="EMA"><a href="#EMA" class="headerlink" title="EMA"></a>EMA</h2><p>Exponential Moving Average-指数移动平均值</p>
<ul>
<li><p>EMA（x，n）－指数移动平均，又名EXPMA，各数值的加权影响力随时间而<strong>指数式</strong>递减，越近期的数据加权影响力越重。</p>
</li>
<li><p>数学本质上SMA和EMA同属于指数移动平均，只不过EMA属于SMA的一个特例，赋予了今日更高的权重，相同数值天数条件下比SMA均线表现更加敏感。</p>
<p>EMA(X,N)就相当于SMA(X,N+1,2)。</p>
</li>
</ul>
<h2 id="WMA"><a href="#WMA" class="headerlink" title="WMA"></a>WMA</h2><p>weighted moving average - 加权移动平均，指计算平均值时将个别数据<a href="https://zh.wikipedia.org/wiki/%E4%B9%98%E6%B3%95">乘</a>以不同数值。</p>
]]></content>
      <categories>
        <category>K线</category>
        <category>技术指标</category>
      </categories>
      <tags>
        <tag>MA</tag>
        <tag>BOLL - MACD - KDJ - RSI - WR</tag>
      </tags>
  </entry>
  <entry>
    <title>常见英文</title>
    <url>/2021/08/03/codeEnglish/code_language/</url>
    <content><![CDATA[<p>one write;read everywhere.</p>
<ul>
<li>Algorithm  算法</li>
<li>Array 数组</li>
<li>Atomic 原子的</li>
<li>Capacity 容量</li>
<li>Constructor 构造器</li>
<li>Diagram 图解</li>
<li>Dispatcher 调度器 分发器</li>
<li>Duplicate  完全一样的; 复制的;</li>
<li>Element 要素; 基本部分 </li>
<li>Enterprise 企业</li>
<li>Exclusively 独占 isHeldExclusively（）</li>
<li>fetch 拿来</li>
<li>filter 过滤</li>
<li>Generic 泛型</li>
<li>Hierarchical 分等级的, 等级的, 分层, 层次, 分层的 hierarchy 等级制度(尤指社会或组织); 统治集团; 层次体系;</li>
<li>Implements 实现</li>
<li>Inherited 继承(金钱、财产等), 经遗传获得(品质、身体特征等), 接替(责任等), 继任 inherit的过去分词和过去式</li>
<li>interpreter 翻译人员</li>
<li>isolation 隔离</li>
<li>priority 优先级</li>
<li>propagation 传播</li>
<li>protocol 协议</li>
<li>Qualifier 预选赛</li>
<li>reference 参考</li>
<li>Retention 维持</li>
<li>Serializable 可序列化的 </li>
<li>stamped 盖章</li>
<li>Statement 说明</li>
<li>transient 短暂的  临时工; java中 不可反序列</li>
<li>vector 向量</li>
<li>mandatory 强制的</li>
<li>nested 嵌套的</li>
</ul>
]]></content>
      <categories>
        <category>英文</category>
      </categories>
      <tags>
        <tag>code_language</tag>
      </tags>
  </entry>
  <entry>
    <title>基础概念_分布式事务</title>
    <url>/2021/08/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>一般是指要做的或所做的事情。<br>在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。<br>事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。<br>事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</p>
<span id="more"></span>
<p>事务<strong>是恢复和并发控制</strong>的<strong>基本单位</strong>。</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>事务应该具有4个属性：<strong>原子性、一致性、隔离性、持久性</strong>。这四个属性通常称为<strong>ACID</strong>特性。</p>
<ul>
<li><p><strong>原子性（atomicity）</strong>：一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。</p>
</li>
<li><p><strong>一致性（consistency）</strong>：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</p>
</li>
<li><p><strong>隔离性（isolation）</strong>：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（durability）</strong>：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
</li>
</ul>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>分布式系统最基础的理论</p>
<p>在分布式系统中，</p>
<h3 id="一致性（Consistency）、"><a href="#一致性（Consistency）、" class="headerlink" title="一致性（Consistency）、"></a>一致性（<em>C</em>onsistency）、</h3><h3 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（<em>A</em>vailability）</h3><h3 id="分区容忍性（Partition-Tolerance）"><a href="#分区容忍性（Partition-Tolerance）" class="headerlink" title="分区容忍性（Partition Tolerance）"></a>分区容忍性（<em>P</em>artition Tolerance）</h3><p>3个要素最多只能<strong>同时满足两个</strong>，不可兼得。其中，分区容忍性又是不可或缺的。</p>
<p>（eureka 保证了可用性，实现最终一致性。）<br>（zookeeper CP，ookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务）</p>
<h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2><p>核心思想：</p>
<h3 id="基本可用（Basically-Available）："><a href="#基本可用（Basically-Available）：" class="headerlink" title="基本可用（Basically Available）："></a>基本可用（Basically Available）：</h3><p>指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。</p>
<h3 id="软状态（Soft-State）"><a href="#软状态（Soft-State）" class="headerlink" title="软状态（Soft State）"></a>软状态（Soft State）</h3><p>指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。</p>
<h3 id="最终一致性（Eventual-Consistency）："><a href="#最终一致性（Eventual-Consistency）：" class="headerlink" title="最终一致性（Eventual Consistency）："></a>最终一致性（Eventual Consistency）：</h3><p>指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。</p>
<p><strong>分布式事务</strong></p>
<ul>
<li>2pc（两段式提交）</li>
<li>3pc（三段式提交）</li>
<li>TCC（Try、Confirm、Cancel）   </li>
<li>最大努力通知</li>
<li>XA</li>
<li>本地消息表（ebay研发出的）</li>
<li>半消息/最终一致性（RocketMQ）</li>
</ul>
]]></content>
      <categories>
        <category>基础概念</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title>PMP备考系列_1-3章笔记</title>
    <url>/2021/07/23/pmp/PMP1-3/</url>
    <content><![CDATA[<h1 id="PMBOK指南笔记"><a href="#PMBOK指南笔记" class="headerlink" title="PMBOK指南笔记"></a>PMBOK指南笔记</h1><h2 id="1-引论"><a href="#1-引论" class="headerlink" title="1.引论"></a>1.引论</h2><blockquote>
<p>1.1《PMBOK®指南》<br>收录项目管理知识体系中被普遍认可为“良好实践”的那一部分。</p>
</blockquote>
<ul>
<li>所谓<strong>普遍认可</strong>，是指这些知识和做法在<strong>大多数时候适用于大多数项目</strong>。<br></li>
<li>所谓<strong>良好实践</strong>，在项目管理过程中使用这些知识、技能、工具和技术，<br>能够达成预期的商业价值和成果，<strong>从而提高很多项目成功的可能性</strong>。</li>
</ul>
<blockquote>
<p>1.1.3 道德与专业行为规范</p>
</blockquote>
<ul>
<li>全球项目管理业界定义的最重要的价值观是:<strong>责任、尊重、公正和诚实</strong>。<span id="more"></span>
<blockquote>
<p>1.2.1 项目</p>
</blockquote>
</li>
<li>项目定义：项目是为创造<strong>独特</strong>的产品、服务或成果而进行的<strong>临时性</strong>工作。<br><ul>
<li>项目的“临时性”是指项目有<strong>明确的起点和终点</strong>。</li>
<li>项目终止原因 -&gt; 收尾：<ul>
<li> 达成项目目标</li>
<li>不会或不能达成目标</li>
<li>项目资金缺乏或没有可分配资金；</li>
<li>项目需求不复存在（例如，客户不再要求完成项目，战略或优先级的变更致使项目终止，组织管理层下达终止项目的指示）；</li>
<li>无法获得所需人力或物力资源；</li>
<li> 出于法律或便利原因而终止项目。</li>
</ul>
</li>
</ul>
</li>
<li>可交付成果定义：可交付成果指的是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产<br>品、成果或服务能力。可交付成果可能是有形的，也可能是无形的。<ul>
<li>虽然项目是临时性工作，但其可交付成果可能会在项目的终止后依然存在</li>
</ul>
</li>
</ul>
<hr>
<p><img src="/2021/07/23/pmp/PMP1-3/pmpflow.jpg" alt="流程"></p>
<ul>
<li>项目成功标准：项目章程。</li>
<li>可交付成果物的验收标准：范围说明书。</li>
</ul>
<hr>
<p> 项目创造商业价值。<br><br> PMI 将商业价值定义为从商业运作中获得的可量化净效益。效益可以是有<br>形的、无形的或两者兼有之。<br><br>无形效益的例子包括:</p>
<ul>
<li>商誉；</li>
<li>品牌认知度;</li>
<li>声誉.</li>
</ul>
<blockquote>
<p>1.2.2 项目管理的重要性</p>
</blockquote>
<p>项目管理<strong>定义</strong>：就是将知识、技能、工具与技术应用于项目活动，以满足项目的要求。</p>
<blockquote>
<p>1.2.3 项目、项目集、项目组合以及运营管理之间的关系</p>
</blockquote>
<p>从组织的角度来看项目、项目集和项目组合管理：</p>
<ul>
<li>项目集和项目管理的重点在于以<strong>“正确”的方式</strong>开展项目集和项目；</li>
<li>项目组合管理则注重于<strong>开展“正确”的</strong>项目集和项目<br><img src="/2021/07/23/pmp/PMP1-3/%E9%A1%B9%E7%9B%AE-%E9%A1%B9%E7%9B%AE%E9%9B%86-%E9%A1%B9%E7%9B%AE%E7%BB%84%E5%90%88%E7%AE%A1%E7%90%86.jpg" alt="项目-项目集-项目组合管理的比较概述"></li>
</ul>
<h4 id="1-2-3-2-项目集管理-（重点是：存在相互依赖的关系）"><a href="#1-2-3-2-项目集管理-（重点是：存在相互依赖的关系）" class="headerlink" title="1.2.3.2 项目集管理 （重点是：存在相互依赖的关系）"></a>1.2.3.2 项目集管理 （重点是：存在相互依赖的关系）</h4><p>项目管理注重项目本身的相互依赖关系，以确定管理项目的最佳方法。<br><br>项目集管理注重作为组成部分的项目与项目集之间的依赖关系，以确定管理这些项目的最佳方法。<br><br>都是管理内部的依赖关系。</p>
<h4 id="1-2-3-3-项目组合管理-（重点是：存在优先级）"><a href="#1-2-3-3-项目组合管理-（重点是：存在优先级）" class="headerlink" title="1.2.3.3 项目组合管理 （重点是：存在优先级）"></a>1.2.3.3 项目组合管理 （重点是：存在优先级）</h4><p>项目组合是指为实现战略目标而组合在一起管理的项目、项目集、子项目组合和运营工作。<br><br>项目组合中的项目集或项目不一定彼此依赖或直接相关。<br><br>要实现项目组合价值的最大化，需要精心检查项目组合的组成部分。确定组成部分的<strong>优先顺序</strong>，<br>使最有利于组织战略目标的组成部分拥有所需的财力、人力和实物资源。</p>
<h4 id="1-2-3-4-运营管理"><a href="#1-2-3-4-运营管理" class="headerlink" title="1.2.3.4 运营管理"></a>1.2.3.4 运营管理</h4><p>运营管理关注产品的持续生产和（或）服务的持续运作。</p>
<h4 id="1-2-3-5-运营与项目管理"><a href="#1-2-3-5-运营与项目管理" class="headerlink" title="1.2.3.5 运营与项目管理"></a>1.2.3.5 运营与项目管理</h4><p>项目与运营会在产品生命周期的不同时点交叉.</p>
<h4 id="1-2-3-6-组织级项目管理-OPM-和战略"><a href="#1-2-3-6-组织级项目管理-OPM-和战略" class="headerlink" title="1.2.3.6 组织级项目管理 (OPM) 和战略"></a>1.2.3.6 组织级项目管理 (OPM) 和战略</h4><ul>
<li>项目组合、项目集和项目均需符合组织战略，或由组织战略驱动，并以不同的方式服务于战略目标的实现。</li>
<li>组织级项目管理 (OPM)。OPM 指为实现战略目标而整合项目组合、<br>项目集和项目管理与组织驱动因素的框架。</li>
</ul>
<h4 id="1-2-4-1-项目和开发生命周期"><a href="#1-2-4-1-项目和开发生命周期" class="headerlink" title="1.2.4.1 项目和开发生命周期"></a>1.2.4.1 项目和开发生命周期</h4><p>项目生命周期指项目从启动到完成所经历的一系列阶段。它为项目管理提供了一个基本框架。不论项目涉及的具体工作是什么，这个基本框架都适用。这些阶段之间的关系可以顺序、迭代或交叠进行。<br><br>项目生命周期内通常有一个或多个阶段与产品、服务或成果的开发相关，这些阶段称为开发生命周期。<br><br>开发周期分类：</p>
<ul>
<li><strong>预测型生命周期</strong>。在生命周期的早期阶段确定项目范围、时间和成本。也称瀑布性生命周期。主要是范围确定，行业经验足。</li>
<li> <strong>迭代型生命周期</strong>。迭代方法是通过一系列重复的循环活动来开发产品，而<br>增量方法是渐进地增加产品的功能。</li>
<li><strong>增量型生命周期</strong>是通过在预定的时间区间内<strong>渐进增加</strong>产品功能的一系列增量来产出可交付成果。</li>
<li><strong>适应型生命周期</strong>属于敏捷型、迭代型或增量型。<ul>
<li>敏捷型：1.以较小增量，快速迭代。2.有限增加最有价值的。</li>
</ul>
</li>
<li><strong>混合型生命周期</strong>是预测型生命周期和适应型生命周期的组合。</li>
</ul>
<p>由项目管理团队确定各个项目最适合的生命周期。<br><br>项目生命周期与产品生命周期相互独立，后者可能由项目产生。产品生命周期指一个产品从概<br>念、交付、成长、成熟到衰退的整个演变过程的一系列阶段</p>
<h4 id="1-2-4-2-项目阶段"><a href="#1-2-4-2-项目阶段" class="headerlink" title="1.2.4.2 项目阶段"></a>1.2.4.2 项目阶段</h4><p>项目阶段是一组具有逻辑关系的项目活动的集合，通常以一个或多个可交付成果的完成为结束。<br><br>用处：分为多个阶段的方式有助于更好地掌控项目管理，同时还提供了评估项目绩效并在后续阶段采取必要的纠正或预防措施的机会。</p>
<h4 id="1-2-4-3-阶段关口"><a href="#1-2-4-3-阶段关口" class="headerlink" title="1.2.4.3 阶段关口"></a>1.2.4.3 阶段关口</h4><p>阶段关口在项目阶段结束时进行，将项目的绩效和进度与项目和业务文件比较。<br>阶段关口可能被称为阶段审查、阶段门、关键决策点和阶段入口或阶段出口（里程碑，杀点）。</p>
<h4 id="1-2-4-7-项目管理数据和信息"><a href="#1-2-4-7-项目管理数据和信息" class="headerlink" title="1.2.4.7 项目管理数据和信息"></a>1.2.4.7 项目管理数据和信息</h4><ul>
<li>工作绩效数据。原始观察结果和测量值。</li>
<li> 工作绩效信息。从各控制过程收集，，并结合相关背景和跨领域关系进行整合分析而得到的绩效数据。</li>
<li>  工作绩效报告。汇编工作绩效信息所形成的实物或电子项目文件。</li>
</ul>
<hr>
<hr>
<h2 id="2-项目运行环境"><a href="#2-项目运行环境" class="headerlink" title="2.项目运行环境"></a>2.项目运行环境</h2><blockquote>
<p>2.2事业环境因素</p>
</blockquote>
<p>事业环境因素（EEFs）是指项目团队<strong>不能控制</strong>(可更新EEFS)的，将对项目产生影响、限制或指令作用的各种条件。</p>
<h3 id="2-2-1-组织内部的事业环境因素"><a href="#2-2-1-组织内部的事业环境因素" class="headerlink" title="2.2.1 组织内部的事业环境因素"></a>2.2.1 组织内部的事业环境因素</h3><ul>
<li> 组织文化、结构和治理。</li>
<li> 设施和资源的地理分布。</li>
<li> 基础设施。</li>
<li> 信息技术软件。例如包括进度计划软件工具、配置管理系统、进入其他在线自动化系统的网络界面和工作授权系统(PMIS)。</li>
<li> 资源可用性。</li>
<li> 员工能力。<h3 id="2-2-2-组织外部的事业环境因素-和人相关"><a href="#2-2-2-组织外部的事业环境因素-和人相关" class="headerlink" title="2.2.2 组织外部的事业环境因素(和人相关)"></a>2.2.2 组织外部的事业环境因素(和人相关)</h3>如：</li>
<li>市场条件</li>
<li>法律限制</li>
</ul>
<blockquote>
<p>2.3 组织过程资产</p>
</blockquote>
<p>由于组织过程资产存在于组织内部，在整个项目期间，项目团队成员可对组织过程资产进行必要的更新和增补。<br></p>
<p>组织过程资产可分成以下两大类:</p>
<ul>
<li>过程、政策和程序；(PMO项目管理办公室更新)</li>
<li>组织知识库。</li>
</ul>
<h2 id="2-4-组织系统"><a href="#2-4-组织系统" class="headerlink" title="2.4 组织系统"></a>2.4 组织系统</h2><p>组织结构<br>项目中人员或组织的组织结构对日后的项目影响深远，PMBOK定义了几种组织结构，分别是：</p>
<ul>
<li>职能型组织</li>
<li>矩阵型组织</li>
<li>项目型组织 </li>
</ul>
<ol>
<li><p>项目型：将所有的能兵强将集结在一起，财务部、业务部、IT管理部等的精英们脱离原有的岗位。形成一个正式的部门，并由项目经理领导。这样的优势是项目经理的权利很强、资源充足，所有的项目经理都希望有这样的团队。但是就公司而言，单独团队对公司整体资源的浪费，是显而易见的；对被抽调的个人而言，脱离了原有的岗位。待项目结束之后，精英们将无家可归。（我就亲眼见过无家可归的人，某很有负罪感）</p>
</li>
<li><p> 职能型：对于项目经理来说，这种情况可是最惨淡的了，无权无资源彻底杯具了。所有项目人员还在属部门里面供职，仅仅花费小部分的时间来处理项目的事情。特别他们还有相应的职能经理，这样的双重管理，对于项目来说是最可怕的了。当然好处也是有的，就公司来说。为这个项目消耗的资源不是很多。个人来说，还在自己的萝卜坑里面。</p>
</li>
<li><p>矩阵型：可能是最微妙的组织关系了，分为弱矩阵，平衡矩阵，强矩阵。那么这个强、弱、平衡关系是如何界定的呢。就是项目经理与职能经理的权利的强弱关系决定；</p>
</li>
</ol>
<p>项目经理&gt;职能经理=强矩阵<br>项目经理=职能经理=平衡矩阵<br>项目经理 &lt; 职能经理=弱矩阵<br>弱矩阵（Weak Matrix）、平衡矩阵（Balanced Matrix）、强矩阵（Strong Matrix）是矩阵型组织的三类细分，它们的区别主要是职能经理与项目经理之间的权力大小。职能经理与项目经理之间的权力基本相等时是平衡矩阵，两个极端分别是弱矩阵和强矩阵。</p>
<p>其优点与职能型一样，对于公司资源均衡；对于个人岗位还在；对于你，项目经理来说横向沟通顺畅。缺点是：双重管理，纵向沟通困难。</p>
<p>矩阵型组织是PMP考试的一个重点，在美国，很多项目都是在矩阵型组织中进行的。<br><img src="/2021/07/23/pmp/PMP1-3/2-1.jpg" alt="组织结构"></p>
<h4 id="2-4-4-3-项目管理办公室（PMO）"><a href="#2-4-4-3-项目管理办公室（PMO）" class="headerlink" title="2.4.4.3 项目管理办公室（PMO）"></a>2.4.4.3 项目管理办公室（PMO）</h4><ul>
<li>支持型。支持型 PMO 担当顾问的角色。这种类型的 PMO 其实就是一个项目资源库，对项目的控制程度很低。</li>
<li>控制型。控制型 PMO不仅给项目提供支持，而且通过各种手段要求项目服从。</li>
<li>指令型。指令型 PMO 直接管理和控制项目。项目经理由 PMO 指定并向其报告。这种类型的 PMO<br>对项目的控制程度很高</li>
</ul>
<hr>
<hr>
<h2 id="3-项目经理的角色-第6版中扩充，重要性增加"><a href="#3-项目经理的角色-第6版中扩充，重要性增加" class="headerlink" title="3.项目经理的角色(第6版中扩充，重要性增加)"></a>3.项目经理的角色(第6版中扩充，重要性增加)</h2><blockquote>
<p>3.1 概述</p>
</blockquote>
<p>项目经理在领导项目团队达成项目目标方面发挥至关重要的作用。<br><br>项目管理角色需要符合组织需求，如同项目管理过程需要符合项目需求一般。<br></p>
<ul>
<li>项目经理无需承担项目中的每个角色，但应具备项目管理知识、技术知识、理解和经验。项目经理通过沟通领导项目团队进行规划和协调。</li>
</ul>
<blockquote>
<p>3.2 项目经理的<strong>定义</strong></p>
</blockquote>
<p>项目经理是由执行组织委派，领导团队<br>实现项目目标的个人.</p>
<h3 id="3-3-2-项目"><a href="#3-3-2-项目" class="headerlink" title="3.3.2 项目"></a>3.3.2 项目</h3><p>项目经理领导项目团队<strong>实现项目目标</strong>和<strong>相关方的期望</strong>。<br><br>项目经理还充当项目发起人、团队成员与其他相关方之间的<strong>沟通者</strong>。项目经理使用<strong>软技能</strong>（例如人际关系技能和人员管理技能）来平衡项目相关方之间相互冲突和竞争的目标，以达成共识。<br><br>成功的项目经理可以持续和有效地使用某些基本技能。<br></p>
<h3 id="3-3-3-组织"><a href="#3-3-3-组织" class="headerlink" title="3.3.3 组织"></a>3.3.3 组织</h3><h3 id="3-3-4-行业"><a href="#3-3-4-行业" class="headerlink" title="3.3.4 行业"></a>3.3.4 行业</h3><blockquote>
<p>3.4项目经理的能力</p>
</blockquote>
<h3 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h3><p> PMI 人才三角。<br><br> 人才三角重点关注三个关键技能组合：</p>
<ul>
<li> 技术项目管理。</li>
<li>领导力。</li>
<li>战略和商务管理。</li>
</ul>
<h3 id="3-4-2-技术项目管理技能"><a href="#3-4-2-技术项目管理技能" class="headerlink" title="3.4.2 技术项目管理技能"></a>3.4.2 技术项目管理技能</h3><p>技术项目管理技能指有效运用项目管理知识实现项目集或项目的预期成果的能力。</p>
<hr>
<p><img src="/2021/07/23/pmp/PMP1-3/5%E5%A4%A7%E8%BF%87%E7%A8%8B-10%E4%B8%AA%E7%9F%A5%E8%AF%86%E9%A2%86%E5%9F%9F.jpg" alt="5大过程-10个知识领域"></p>
<hr>
<blockquote>
<p>帮助记忆的7大原则</p>
</blockquote>
<ol>
<li>首要原则，每天早上黄金时间。</li>
<li>就近原则，最后的部分更能记住。</li>
<li>分类原则，记忆 7个左右，可以对知识点分类</li>
<li>记录原则，边记边画或者写</li>
<li>联想原则，关联记忆，</li>
<li>重复原则，6x，重复 重复 重复。</li>
<li>突出原则，区分重点   </li>
</ol>
]]></content>
      <categories>
        <category>PMP</category>
      </categories>
      <tags>
        <tag>PMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础提升_String类</title>
    <url>/2021/07/05/java%E5%9F%BA%E7%A1%80/String%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="String（字符串常量）概述"><a href="#String（字符串常量）概述" class="headerlink" title="String（字符串常量）概述"></a>String（字符串常量）概述</h1><p>在API中是这样描述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*String 类代表字符串。Java 程序中的所有字符串字面值（如 &quot;abc&quot; ）都作为此类的实例实现。</span></span><br><span class="line"><span class="comment">字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</span></span><br><span class="line"><span class="comment">       String str = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">相当于：</span></span><br><span class="line"><span class="comment">       char data[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span></span><br><span class="line"><span class="comment">       String str = new String(data);</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">以下是一些有关如何使用字符串的更多示例：</span></span><br><span class="line"><span class="comment">       System.out.println(&quot;abc&quot;);</span></span><br><span class="line"><span class="comment">       String cde = &quot;cde&quot;;</span></span><br><span class="line"><span class="comment">       System.out.println(&quot;abc&quot; + cde);</span></span><br><span class="line"><span class="comment">       String c = &quot;abc&quot;.substring(2,3);</span></span><br><span class="line"><span class="comment">       String d = cde.substring(1, 2);</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">类String包括用于检查序列中的单个字符、比较字符串、搜索字符串、提取子字符串以及创建所有字符都转换为大写或小写的字符串副本的方法。 大小写映射基于Character类指定的 Unicode 标准版本。</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是：String是一个<strong>不可变对象</strong>，可以认为是特殊的常量，因此存在方法区的<strong>运行时常量池</strong>中，可以被共享使用(<strong>享元模式</strong>),而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化<br></p>
</blockquote>
<p>由此引申出许多判断各种情况下，string对象是否相等的判断</p>
<h2 id="常见的String-比较"><a href="#常见的String-比较" class="headerlink" title="常见的String == 比较"></a>常见的String == 比较</h2><p>首先，我们在比较两个string对象之前，需要了解：</p>
<ol>
<li>通过<strong>构造方法</strong>创建（new创建）的String对象，存放在java虚拟机的<strong>堆内存</strong>，堆内存里存放的是<strong>字符串常量的地址</strong>，字符串常量存放在方法区的常量池中；</li>
<li>直接赋值：通过直接赋值所创建的对象直接是<strong>方法区中的常量池</strong>中的字符串常量。</li>
</ol>
<p>下面列举一些常见的比较例子：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">   String <span class="built_in">s1</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">   String <span class="built_in">s2</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">   String <span class="built_in">s3</span> = <span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">   String <span class="built_in">s4</span> = <span class="string">&quot;Hel&quot;</span> + new String(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">   String <span class="built_in">s5</span> = new String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">   String <span class="built_in">s6</span> = <span class="built_in">s5</span>.intern();</span><br><span class="line">   String <span class="built_in">s7</span> = <span class="string">&quot;H&quot;</span>;</span><br><span class="line">   String <span class="built_in">s8</span> = <span class="string">&quot;ello&quot;</span>;</span><br><span class="line">   String s9 = <span class="built_in">s7</span> + <span class="built_in">s8</span>;</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="built_in">s1</span> == <span class="built_in">s2</span>)<span class="comment">;  // true 都是方法区常量池</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>.equals(<span class="built_in">s2</span>))<span class="comment">;  //true 值都相同</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>.equals(<span class="built_in">s5</span>))<span class="comment">;  //true 值都相同</span></span><br><span class="line">   System.out.println(<span class="built_in">s1</span> == <span class="built_in">s3</span>)<span class="comment">;  // true 做+号的时候，会进行优化，自动生成Hello赋值给s3都是方法区常量池</span></span><br><span class="line">   System.out.println(<span class="built_in">s1</span> == <span class="built_in">s4</span>)<span class="comment">;  // false s4最后生成的是一个在堆中的string对象</span></span><br><span class="line">   System.out.println(<span class="built_in">s1</span> == s9)<span class="comment">;  // false 用的是动态调用，所以s9返回的是一个新的String对象</span></span><br><span class="line">   System.out.println(<span class="built_in">s4</span> == <span class="built_in">s5</span>)<span class="comment">;  // false s4，s5不同的对象</span></span><br><span class="line">   System.out.println(<span class="built_in">s1</span> == <span class="built_in">s6</span>)<span class="comment">;  // true</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li>s1 = = s2 很容易可以判断出来。s1 和 s2 都指向了方法区常量池中的Hello。</li>
<li>s1 = = s3 这里要注意一下，因为做+号的时候，会进行优化，自动生成Hello赋值给s3，所以也是true</li>
<li>s1 = = s4 s4是分别用了常量池中的字符串和存放对象的堆中的字符串，做+的时候会进行动态调用，最后生成的仍然是一个String对象存放在堆中。</li>
<li>s1 = = s9 在JAVA9中，因为用的是动态调用，所以返回的是一个新的String对象。所以s9和s4，s5这三者都不是指向同一块内存</li>
<li>s1 = = s6 为啥s1 和 s6地址相等呢？ 归功于intern方法，这个方法首先在常量池中查找是否存在一份equal相等的字符串如果有的话就返回该字符串的引用，没有的话就将它加入到字符串常量池中，所以存在于class中的常量池并非固定不变的，可以用intern方法加入新的</li>
</ol>
<h2 id="String、StringBuffer、StringBuilder。"><a href="#String、StringBuffer、StringBuilder。" class="headerlink" title="String、StringBuffer、StringBuilder。"></a>String、StringBuffer、StringBuilder。</h2><ul>
<li>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，<strong>每次操作</strong>都会生成<strong>新的 String 对象</strong>，然后将指针指向新的 String 对象；</li>
<li>而 StringBuffer、StringBuilder 可以在<strong>原有对象的基础</strong>上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</li>
<li>StringBuffer 和 StringBuilder 最大的区别在于，<strong>StringBuffer</strong> 是<strong>线程安全</strong>的，而 <strong>StringBuilder</strong> 是<strong>非线程安全</strong>的；</li>
<li>但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</li>
</ul>
<h2 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.<span class="keyword">append</span>(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(stringBuffer.<span class="keyword">reverse</span>()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>
<h2 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h2><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础提升_Object</title>
    <url>/2021/07/05/java%E5%9F%BA%E7%A1%80/Object%E7%B1%BB/</url>
    <content><![CDATA[<p>Object类  是类层次结构的根类。</p>
<p>Object类是所有类的超类。所有对象（包括数组）都实现这个类的方法。</p>
<p>所以需要了解Object类的所有方法：</p>
<h3 id="1-hashCode"><a href="#1-hashCode" class="headerlink" title="1.hashCode()"></a>1.hashCode()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>；</span></span><br></pre></td></tr></table></figure>
<p>返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。<br>不同对象的 hashCode() 的值一般是不相同。但是，同一个对象的hashCode() 值肯定相同。</p>
<span id="more"></span>
<h3 id="2-getClass"><a href="#2-getClass" class="headerlink" title="2.getClass()"></a>2.getClass()</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">Class</span> getClass()</span><br></pre></td></tr></table></figure>


<p>返回此 Object 的运行时类。</p>
<h3 id="2-1-getName"><a href="#2-1-getName" class="headerlink" title="2.1.getName()"></a>2.1.getName()</h3><p>可以通过 Class 类中的一个方法，获取对象的真实类的全名称。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Object</span> obj = new <span class="keyword">Object</span>();</span><br><span class="line"><span class="keyword">Class</span> c1 = obj.getClass();</span><br><span class="line"><span class="keyword">String</span> <span class="keyword">name</span> =c1.getName();</span><br></pre></td></tr></table></figure>


<h3 id="3-toString"><a href="#3-toString" class="headerlink" title="3.toString()"></a>3.toString()</h3><p>getClass().getName() + “@” + Integer.toHexString(hashCode())  这返回的是：类的全路径名称+它的哈希码值<del>在实际的开发中对我们来说是没有意义的</del>所以我们一般会重写该方法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public String <span class="keyword">to</span><span class="constructor">String()</span> &#123;</span><br><span class="line">        return get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot;@&quot;</span> + <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">HexString(<span class="params">hashCode</span>()</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-equals"><a href="#4-equals" class="headerlink" title="4.equals()"></a>4.equals()</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">equals</span>(<span class="params"><span class="built_in">Object</span> obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>默认方法是比较的是对象的引用是否相同。由于比较对象的引用对于我们在实际开发中没有意义，一般还是要重写该方法。 一般来说基础类型用==，比较引用数据类型使用equals</p>
<h3 id="5-wait"><a href="#5-wait" class="headerlink" title="5.wait()"></a>5.wait()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使当前线程等待，直到另一个线程为此对象调用notify()方法或notifyAll()方法，或者经过了指定的时间。</span></span><br><span class="line"><span class="comment">当前线程必须拥有该对象的监视器。</span></span><br><span class="line"><span class="comment">此方法使当前线程（称为T ）将自己置于该对象的等待集中，然后放弃对该对象的任何和所有同步声明。 出于线程调度的目的，线程T被禁用，并且处于休眠状态，直到发生以下四种情况之一：</span></span><br><span class="line"><span class="comment">其他一些线程为此对象调用notify方法，并且线程T恰好被任意选择为要唤醒的线程。</span></span><br><span class="line"><span class="comment">其他一些线程为此对象调用notifyAll方法。</span></span><br><span class="line"><span class="comment">其他一些线程中断线程T。</span></span><br><span class="line"><span class="comment">指定的实时量或多或少已经过去。 但是，如果timeout为零，则不考虑实时，线程只是等待直到通知。</span></span><br><span class="line"><span class="comment">然后将线程T从该对象的等待集中删除，并重新启用线程调度。 然后，它以通常的方式与其他线程竞争在对象上进行同步的权利。 一旦它获得了对象的控制权，它对对象的所有同步声明都将恢复到原样-即，恢复到调用wait方法时的情况。 然后，线程T从调用wait方法返回。 因此，从wait方法返回时，对象和线程T的同步状态与调用wait方法时的状态完全相同。</span></span><br><span class="line"><span class="comment">线程也可以被唤醒，而不会被通知，中断或超时，即所谓的虚假唤醒。 尽管在实践中这种情况很少发生，但是应用程序必须通过测试应该导致线程唤醒的条件来防范它，并在条件不满足时继续等待。 换句话说，等待应该总是在循环中发生，就像这样：</span></span><br><span class="line"><span class="comment">           synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">               while (&lt;condition does not hold&gt;)</span></span><br><span class="line"><span class="comment">                   obj.wait(timeout);</span></span><br><span class="line"><span class="comment">               ... // Perform action appropriate to condition</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">（有关此主题的更多信息，请参见Doug Lea的“ Java并发编程（第二版）”（Addison-Wesley，2000年）中的3.2.3节，或Joshua Bloch的“有效的Java编程语言指南”（Addison-卫斯理（Wesley），2001年）。</span></span><br><span class="line"><span class="comment">如果当前线程被中断任何线程之前或在等待时，那么InterruptedException被抛出。 如上所述，直到该对象的锁定状态恢复之前，不会引发此异常。</span></span><br><span class="line"><span class="comment">请注意， wait方法将当前线程放入该对象的等待集中，因此只会解锁该对象； 当线程等待时，当前线程可以在其上同步的所有其他对象保持锁定。</span></span><br><span class="line"><span class="comment">此方法只能由作为该对象的监视器的所有者的线程调用。 有关线程可以成为监视器所有者的方式的描述，请参见notify方法。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">超时–等待的最长时间（以毫秒为单位）。</span></span><br><span class="line"><span class="comment">投</span></span><br><span class="line"><span class="comment">IllegalArgumentException如果超时值为负。</span></span><br><span class="line"><span class="comment">IllegalMonitorStateException如果当前线程不是对象监视器的所有者。</span></span><br><span class="line"><span class="comment">InterruptedException如果任何线程在当前线程等待通知之前或之时中断了当前线程。 引发此异常时，将清除当前线程的中断状态。</span></span><br><span class="line"><span class="comment">请参见：</span></span><br><span class="line"><span class="comment">notify() ， notifyAll() */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>



<h3 id="5-1-notify"><a href="#5-1-notify" class="headerlink" title="5.1-notify()"></a>5.1-notify()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*唤醒正在此对象的监视器上等待的单个线程。 </span></span><br><span class="line"><span class="comment">如果有任何线程在此对象上等待，则选择其中一个唤醒。 </span></span><br><span class="line"><span class="comment">**该选择是任意**的，并且可以根据实现情况进行选择。 </span></span><br><span class="line"><span class="comment">线程通过调用其中一个wait方法在对象的监视器上wait 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在当前线程放弃对该对象的锁定之前，唤醒的线程将无法继续。 </span></span><br><span class="line"><span class="comment">唤醒的线程将以通常的方式与可能正在主动竞争以在此对象上进行同步的任何</span></span><br><span class="line"><span class="comment">其他线程竞争。 例如，被唤醒的线程在成为锁定该对象的下一个线程时没有任</span></span><br><span class="line"><span class="comment">何可靠的特权或劣势。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此方法只能由作为该对象的监视器的所有者的线程调用。 </span></span><br><span class="line"><span class="comment">线程通过以下三种方式之一成为对象监视器的所有者：</span></span><br><span class="line"><span class="comment">- 通过执行该对象的同步实例方法。</span></span><br><span class="line"><span class="comment">- 通过执行在对象上synchronized语句的主体。</span></span><br><span class="line"><span class="comment">- 对于Class,类型的对象Class,通过执行该类的同步静态方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一次只能有一个线程拥有对象的监视器。</span></span><br><span class="line"><span class="comment">throw IllegalMonitorStateException如果当前线程不是此对象的监视器的所有者。</span></span><br><span class="line"><span class="comment">请参见：</span></span><br><span class="line"><span class="comment">notifyAll() ， wait()*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-notifyAll"><a href="#5-2-notifyAll" class="headerlink" title="5.2-notifyAll()"></a>5.2-notifyAll()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 唤醒正在此对象的监视器上等待的所有线程。 线程通过调用其中一个wait方法在对象的监视器上wait 。</span></span><br><span class="line"><span class="comment">在当前线程放弃对该对象的锁定之前，唤醒的线程将无法继续。 唤醒的线程将以通常的方式与任何其他可能正在主动竞争以在此对象上进行同步的线程竞争。 例如，被唤醒的线程在成为锁定该对象的下一个线程时没有任何可靠的特权或劣势。</span></span><br><span class="line"><span class="comment">此方法只能由作为该对象的监视器的所有者的线程调用。 有关线程可以成为监视器所有者的方式的描述，请参见notify方法。</span></span><br><span class="line"><span class="comment">投</span></span><br><span class="line"><span class="comment">IllegalMonitorStateException如果当前线程不是此对象的监视器的所有者。</span></span><br><span class="line"><span class="comment">请参见：</span></span><br><span class="line"><span class="comment">notify() ， wait()*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-finalize"><a href="#6-finalize" class="headerlink" title="6.finalize()"></a>6.finalize()</h3><p>finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当垃圾回收确定不再有对该对象的引用时，由垃圾回收器在对象上调用。 子类覆盖finalize方法以处置系统资源或执行其他清除。</span></span><br><span class="line"><span class="comment">finalize的一般约定是，当Java™虚拟机确定不再有任何手段可以使尚未死亡的任何线程访问该对象时（除非是由于操作而导致），调用finalize由完成的其他某些对象或类的完成确定。 finalize方法可以采取任何措施，包括使该对象可再次用于其他线程。 但是， finalize的通常目的是在清除对象之前将其清除。 例如，代表输入/输出连接的对象的finalize方法可能会执行显式I / O事务，以在永久丢弃该对象之前中断连接。</span></span><br><span class="line"><span class="comment">Object类的finalize方法不执行任何特殊操作； 它只是正常返回。 Object子类可以覆盖此定义。</span></span><br><span class="line"><span class="comment">Java编程语言不能保证哪个线程将为任何给定对象调用finalize方法。 但是，可以保证，调用finalize的线程在调用finalize时不会持有任何用户可见的同步锁。 如果finalize方法抛出未捕获的异常，则该异常将被忽略，并且该对象的终止将终止。</span></span><br><span class="line"><span class="comment">在为对象调用finalize方法之后，在Java虚拟机再次确定不再有任何方法可以使尚未死亡的任何线程访问该对象之前，不采取进一步的措施，包括可能采取的措施可以通过其他准备完成的对象或类来完成，此时可以丢弃该对象。</span></span><br><span class="line"><span class="comment">对于任何给定的对象，Java虚拟机都不会多次调用finalize方法。</span></span><br><span class="line"><span class="comment">由finalize方法引发的任何异常都将导致此对象的终止终止，但否则将被忽略。</span></span><br><span class="line"><span class="comment">投</span></span><br><span class="line"><span class="comment">Throwable –此方法引发的Exception</span></span><br><span class="line"><span class="comment">请参见：</span></span><br><span class="line"><span class="comment">ref.WeakReference ， ref.PhantomReference */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>下面是引申出的一些问题</p>
<blockquote>
<p>为什么 wait，notify 和 notifyAll 是在 Object 类中定义的而不是在 Thread 类中定义?</p>
</blockquote>
<ol>
<li><p>wait 和 notify 不仅仅是普通方法或同步工具，更重要的是它们是 Java 中两个线程之间的通信机制。对语言设计者而言, 如果不能通过 Java 关键字(例如 synchronized)实现通信此机制，同时又要确保这个机制对每个对象可用, 那么 Object 类则是的正确声明位置。记住同步和等待通知是两个不同的领域，不要把它们看成是相同的或相关的。同步是提供互斥并确保 Java 类的线程安全，而 wait 和 notify 是两个线程之间的通信机制。</p>
</li>
<li><p>每个对象都可上锁，这是在 Object 类而不是 Thread 类中声明 wait 和 notify 的另一个原因。</p>
</li>
<li><p>在 Java 中为了进入代码的临界区，线程需要锁定并等待锁定，他们不知道哪些线程持有锁，而只是知道锁被某个线程持有， 并且他们应该等待取得锁, 而不是去了解哪个线程在同步块内，并请求它们释放锁定。</p>
</li>
<li><p>Java 是基于 Hoare 的监视器的思想，在Java中，所有对象都有一个监视器。<br>线程在监视器上等待，为执行等待，我们需要2个参数：<br>一个线程<br>一个监视器(任何对象)<br>在 Java 设计中，线程不能被指定，它总是运行当前代码的线程。但是，我们可以指定监视器(这是我们称之为等待的对象)。这是一个很好的设计，因为如果我们可以让任何其他线程在所需的监视器上等待，这将导致“入侵”，导致在设计并发程序时会遇到困难。请记住，在 Java 中，所有在另一个线程的执行中侵入的操作都被弃用了(例如 stop 方法)。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>shell中for循环的用法</title>
    <url>/2021/06/15/shell/unix%E4%B8%ADfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>for循环是程序处理中常见的的一种处理逻辑，那么shell中如何使用呢？</p>
<ul>
<li>循环逐个处理指定路径下的文件</li>
<li>for循环快速占用指定线程数cpu<span id="more"></span>
<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1></li>
</ul>
<p>循环逐个处理指定路径下的文件</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">filelist = `<span class="keyword">ls</span> -<span class="keyword">l</span> <span class="variable">$path</span>`</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filelist;<span class="keyword">do</span> <span class="keyword">ls</span> -lrt done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>for循环快速占用指定线程数cpu</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq <span class="number">1</span> <span class="variable">$cat</span> <span class="regexp">/proc/</span>cpuinfo|grep <span class="string">&quot;physical id&quot;</span>|wc -l`;<span class="keyword">do</span> dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>zero of=<span class="regexp">/dev/</span>null &amp; done</span><br><span class="line"><span class="comment"># 指定到了后台运行</span></span><br><span class="line"><span class="comment"># kill -9 dd 结束进程</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unix</category>
        <category>shell</category>
        <category>for循环</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本中$</title>
    <url>/2021/06/15/shell/shell%20%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84$%20/</url>
    <content><![CDATA[<h1 id="Shell脚本中-0、-、-、-、-、-、"><a href="#Shell脚本中-0、-、-、-、-、-、" class="headerlink" title="Shell脚本中$0、$?、$!、$$、$*、$#、$@"></a>Shell脚本中$0、$?、$!、$$、$*、$#、$@</h1><h2 id="1"><a href="#1" class="headerlink" title="1. $$"></a>1. $$</h2><p>Shell本身的PID（ProcessID）</p>
<h2 id="2"><a href="#2" class="headerlink" title="2. $!"></a>2. $!</h2><p>Shell最后运行的后台Process的PID</p>
<h2 id="3"><a href="#3" class="headerlink" title="3. $?"></a>3. $?</h2><p>最后运行的命令的结束代码（返回值）</p>
<h2 id="4"><a href="#4" class="headerlink" title="4. $-"></a>4. $-</h2><p>使用Set命令设定的Flag一览</p>
<h2 id="5"><a href="#5" class="headerlink" title="5. $*"></a>5. $*</h2><p>所有参数列表。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</p>
<h2 id="6"><a href="#6" class="headerlink" title="6. $@"></a>6. $@</h2><p>所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<h2 id="7"><a href="#7" class="headerlink" title="7. $#"></a>7. $#</h2><p>添加到Shell的参数个数</p>
<h2 id="8-0"><a href="#8-0" class="headerlink" title="8. $0"></a>8. $0</h2><p>Shell本身的文件名</p>
<h2 id="9-1～-n"><a href="#9-1～-n" class="headerlink" title="9.$1～$n"></a>9.$1～$n</h2><p>添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>
<hr>
<p>我们先写一个简单的脚本，执行以后再解释各个变量的意义</p>
<p>mkdir test.sh<br>脚本内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;number:$#&quot;</span><br><span class="line">echo &quot;scname:$0&quot;</span><br><span class="line">echo &quot;first :$1&quot;</span><br><span class="line">echo &quot;second:$2&quot;</span><br><span class="line">echo &quot;argume:$@&quot;</span><br></pre></td></tr></table></figure>
<p>保存退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wqa!</span><br></pre></td></tr></table></figure>
<p>赋予脚本执行权限并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash test.sh</span><br><span class="line">chmod 755 test.sh</span><br><span class="line"> ./test.sh</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">number:2</span><br><span class="line">scname:./variable</span><br><span class="line">first: aa</span><br><span class="line">second:bb</span><br><span class="line">argume:aa bb</span><br></pre></td></tr></table></figure>
<p>结果分析</p>
<p>通过显示结果可以看到：<br>$# 是传给脚本的参数个数<br>$0 是脚本本身的名字<br>$1是传递给该shell脚本的第一个参数<br>$2是传递给该shell脚本的第二个参数<br>$@ 是传给脚本的所有参数的列表</p>
]]></content>
      <categories>
        <category>unix</category>
        <category>shell</category>
        <category>Shell脚本中$0、$?、$!、$$、$*、$#、$@</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell命令之网络篇</title>
    <url>/2021/06/15/shell/shell%E5%91%BD%E4%BB%A4%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/</url>
    <content><![CDATA[<h3 id="要想知道网络的配置和状态，我们可以使用-ifconfig-或者-ip-命令来查看。"><a href="#要想知道网络的配置和状态，我们可以使用-ifconfig-或者-ip-命令来查看。" class="headerlink" title="要想知道网络的配置和状态，我们可以使用 ifconfig 或者 ip 命令来查看。"></a>要想知道网络的配置和状态，我们可以使用 ifconfig 或者 ip 命令来查看。</h3><p>这两个命令功能都差不多，不过它们属于不同的软件包，ifconfig 属于 net-tools 软件包，ip 属于 iproute2 软件包，我的印象中 net-tools 软件包没有人继续维护了，而 iproute2 软件包是有开发者依然在维护，所以更推荐你使用 ip 工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipconfig eth0</span><br><span class="line">ip -s addr show dev eth0</span><br></pre></td></tr></table></figure>
<p>第一，网口的连接状态标志。其实也就是表示对应的网口是否连接到交换机或路由器等设备，如果 ifconfig 输出中看到有 RUNNING，或者 ip 输出中有 LOWER_UP，则说明物理网路是连通的，如果看不到，则表示网口没有接网线。</p>
<p>第二，MTU 大小。默认值是 1500 字节，其作用主要是限制网络包的大小，如果 IP 层有一个数据报要传，而且数据帧的长度比链路层的 MTU 还大，那么 IP 层就需要进行分片，即把数据报分成干片，这样每一片就都小于 MTU。事实上，每个网络的链路层 MTU 可能会不一样，所以你可能需要调大或者调小 MTU 的数值。</p>
<p>第三，网口的 IP 地址、子网掩码、MAC 地址、网关地址。这些信息必须要配置正确，网络功能才能正常工作。</p>
<p>第四，网路包收发的统计信息。通常有网络收发的字节数、包数、错误数以及丢包情况的信息，如果 TX（发送） 和 RX（接收） 部分中 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，则说明网络发送或者接收出问题了，这些出错统计信息的指标意义如下：</p>
<span id="more"></span>
<ul>
<li><p>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等；</p>
</li>
<li><p>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer（这个缓冲区是在内核内存中，更具体一点是在网卡驱动程序里），但因为系统内存不足等原因而发生的丢包；</p>
</li>
<li><p>overruns 表示超限数据包数，即网络接收/发送速度过快，导致 Ring Buffer 中的数据包来不及处理，而导致的丢包，因为过多的数据包挤压在 Ring Buffer，这样 Ring Buffer 很容易就溢出了；</p>
</li>
<li><p>carrier 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；</p>
</li>
<li><p>collisions 表示冲突、碰撞数据包数；</p>
</li>
</ul>
<h3 id="协议栈的相关信息的查询（如TCP-UDP）"><a href="#协议栈的相关信息的查询（如TCP-UDP）" class="headerlink" title="协议栈的相关信息的查询（如TCP/UDP）"></a>协议栈的相关信息的查询（如TCP/UDP）</h3><p>ss 或者  netstat</p>
]]></content>
      <categories>
        <category>unix</category>
        <category>shell</category>
        <category>网络命令</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识TCP</title>
    <url>/2021/05/22/%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%E7%B1%BB/%E5%9F%BA%E7%A1%80%E4%B9%8Btcp/</url>
    <content><![CDATA[<p>&nbsp;</p>
<h2 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h2><p>Transmission Control Protocol（传输控制协议）<br><br>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li><p>面向连接：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p>
</li>
<li><p>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p>
</li>
<li><p>字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p>
</li>
</ul>
<h2 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h2><p>TCP连接主要包括三个部分：socket，序列号，窗口大小。<br><br>通过TCP连接可以控制流量，和提高可靠性。<br></p>
<ul>
<li>Socket：由 IP 地址和端口号组成</li>
<li>序列号：用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<p><img src="/2021/05/22/%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%E7%B1%BB/%E5%9F%BA%E7%A1%80%E4%B9%8Btcp/tcp.jpeg" alt="TCP"></p>
<h2 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h2><ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口<span id="more"></span>
<h2 id="有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h2>主要受限于服务器的资源，第一是文件描述符限制，TCP连接中得socket是文件得，所以受文件描述符限制，这个由系统参数ulimit 配置，但这个也受限于系统内存，内存不大，参数设置得过大也无法实现。</li>
</ul>
<h2 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h2><p>UDP 是不需要连接，即刻传输数据。且可以一对多，多对多。UDP 是尽最大努力交付，不保证可靠交付数据。UDP没有流量控制。UDP首部只有 8 个字节，并且是固定不变的，开销较小<br><br>TCP则是面向连接的，只能一对一，TCP比较可靠数据可以无差错、不丢失、不重复、按需到达，可以进行流量控制。<br></p>
<p>一句话来说UDP比较高效，舍弃了可靠性，TCP则是专注于点对点的高质量传输。<br><br><strong>TCP：</strong><br><br>FTP 文件传输<br><br>HTTP / HTTPS<br><br><br><strong>UDP</strong><br><br>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<p>包总量较少的通信，如 DNS 、SNMP 等</p>
<p>视频、音频等多媒体通信</p>
<p>广播通信</p>
<h2 id="为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h2><p>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。</p>
<h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol>
<li>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态;<br></li>
<li>客户端发起一个SYN请求，同时送过去随机生成的客户端序列号client_isn,之后客户端处于 SYN-SENT 状态。<br></li>
<li>服务端接收到SYN请求，返回一个ACK和服务端的SYN，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1，生成一个服务端的序列号server_isn，传送给客户端，之后服务端处于 SYN-RCVD 状态;<br></li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。</li>
<li>服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。</li>
</ol>
<h3 id="三次握手的意义"><a href="#三次握手的意义" class="headerlink" title="三次握手的意义"></a>三次握手的意义</h3><p>阻止历史重复连接的初始化（主要原因）</p>
<p>三次握手才可以同步双方的初始序列号</p>
<p>三次握手才可以避免资源浪费<br></p>
<p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据</strong>的。</p>
<h3 id="如何在-Linux-系统中查看-TCP-状态？"><a href="#如何在-Linux-系统中查看-TCP-状态？" class="headerlink" title="如何在 Linux 系统中查看 TCP 状态？"></a>如何在 Linux 系统中查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 <strong>netstat -napt</strong> 命令查看。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li>
<li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。</li>
<li>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li>
<li>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</li>
<li>服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</li>
</ol>
<p><strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h2 id="TCP性能的优化"><a href="#TCP性能的优化" class="headerlink" title="TCP性能的优化"></a>TCP性能的优化</h2><p>tcp_syn_retries 控制SYN包重传的次数，默认值是5</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo <span class="number">5</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/net/i</span>pv4/tcp_syn_retries</span><br></pre></td></tr></table></figure>
<h2 id="如何查看由于-SYN-半连接队列已满，而被丢弃连接的情况？"><a href="#如何查看由于-SYN-半连接队列已满，而被丢弃连接的情况？" class="headerlink" title="如何查看由于 SYN 半连接队列已满，而被丢弃连接的情况？"></a>如何查看由于 SYN 半连接队列已满，而被丢弃连接的情况？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -s |grep &quot;SYNs to LISTEN&quot;</span><br></pre></td></tr></table></figure>
<p>&nbsp;上面输出的数值是累计值，表示共有多少个 TCP<br> 连接因为半连接队列溢出而被丢弃。隔几秒执行几次，如果有上升的趋势，说明当前存在半连接队列溢出的现象。</p>
<h2 id="如何查看由于-accept-连接队列已满，而被丢弃的连接？"><a href="#如何查看由于-accept-连接队列已满，而被丢弃的连接？" class="headerlink" title="如何查看由于 accept 连接队列已满，而被丢弃的连接？"></a>如何查看由于 accept 连接队列已满，而被丢弃的连接？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date;netstat -s |grep overflowed</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cs基础</category>
        <category>tcp</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础之贪心算法</title>
    <url>/2021/05/22/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。<br>贪心算法的理解： 整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</p>
<span id="more"></span>

<p>贪心算法经典之找零钱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeMoney</span><span class="params">(<span class="keyword">int</span>  money)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] moneybox = &#123;<span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] changArray = <span class="keyword">new</span> <span class="keyword">int</span>[moneybox.length];</span><br><span class="line">        Arrays.sort(moneybox);</span><br><span class="line">        <span class="comment">//  System.out.println(Arrays.toString(changArray));</span></span><br><span class="line">        <span class="keyword">int</span> change = money;</span><br><span class="line">        <span class="keyword">if</span> (money &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (change &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = moneybox.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; change - moneybox[i] &gt;= <span class="number">0</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = change - moneybox[i];</span><br><span class="line">                        <span class="keyword">if</span> (tmp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            change = tmp;</span><br><span class="line">                            changArray[i] = j;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; moneybox.length; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (changArray[p] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;需要找零&quot;</span> + moneybox[p] + <span class="string">&quot; &quot;</span> + changArray[p] + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识HTTP</title>
    <url>/2021/05/22/%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%E7%B1%BB/%E5%9F%BA%E7%A1%80%E4%B9%8Bhttp/</url>
    <content><![CDATA[<h2 id="什么是HTTP？"><a href="#什么是HTTP？" class="headerlink" title="什么是HTTP？"></a>什么是HTTP？</h2><p>HyperText Transfer Protocol（超文本传输协议）,它是一个<strong>无状态的工作在应用层的协议</strong>.<br><br>超文本指的是<strong>HTML</strong>，css，JavaScript和图片等，HTTP的出现是为了接收和发布HTML页面，也可以用于接收一些音频，视频，文件等内容。<br><br>HTTP协议是用于客户端和服务器端之间的通信，用于客户端和服务器端之间的通信有HTTP协议和TCP/IP协议族在内的其他众多的协议。<br></p>
<h2 id="HTTP的短连接和长连接"><a href="#HTTP的短连接和长连接" class="headerlink" title="HTTP的短连接和长连接"></a>HTTP的短连接和长连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。可以持久连接，TCP连接默认不关闭，可以被多个请求复用，只有在一段时间内，没有请求，就可以自动关闭。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认：</span></span><br><span class="line"><span class="symbol">Connection:</span><span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="HTTP的特点："><a href="#HTTP的特点：" class="headerlink" title="HTTP的特点："></a>HTTP的特点：</h2><p>支持客户端、服务器端模式，简单快速，客户端向服务器端请求服务时，只需传送请求方法和路径，灵活，HTTP允许传输任意类型的数据对象，无状态，HTTP协议是无状态协议，指明协议对于事务处理没有记忆能力。</p>
<p>HTTP1.1虽然是无状态协议，但是为了实现期望的保持状态功能，于是引入了Cookie技术，有了Cookie，和HTTP协议通信，就可以管理状态了。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p> HTTPS 的全称是 Hypertext Transfer Protocol Secure。<br> 从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。</p>
<ul>
<li>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。<br>http和https的比对</li>
<li>数据完整性：内容传输经过完整性校验</li>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>身份认证：第三方无法伪造服务端(客户端)身份</li>
</ul>
<p>SSL过程<br>建立连接获取证书</p>
<ol>
<li>SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握<br>手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算<br>法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所<br>需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书<br>的公司，公共秘钥）。<br>证书验证</li>
<li>Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公<br>共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。<br>数据加密和传输</li>
<li>如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务<br>器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li>
</ol>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">客户端-&gt;&gt;服务端: 请求http连接（消息里面包含了自己可实现的算法列表和其它一些需要的消息）</span><br><span class="line">服务端-&gt;&gt;客户端: 返回私钥签名后的证书（公钥）</span><br><span class="line">客户端-&gt;&gt;客户端: 接收证书，用机构的公钥验证证书签名，使用算法产生随机的对称密钥，并且使用公钥对此对称密钥加密</span><br><span class="line">客户端-&gt;&gt;服务端: 发送加密后的堆成密钥</span><br><span class="line">客户端-&gt;&gt;服务端: 通过对称密钥加密的密文进行通信</span><br><span class="line">服务端-&gt;&gt;客户端: 通过对称密钥加密的密文进行通信</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cs基础</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql知识点</title>
    <url>/2021/05/22/sql/sql%E4%B8%AD%E6%AF%94%E8%BE%83%E7%89%B9%E6%AE%8A%E7%9A%84%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="用-rownum-rownum-1-实现-rownum-功能"><a href="#用-rownum-rownum-1-实现-rownum-功能" class="headerlink" title="用 @rownum := @rownum+1 实现 rownum 功能"></a>用 @rownum := @rownum+1 实现 rownum 功能</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@rownum</span> :<span class="operator">=</span> <span class="variable">@rownum</span><span class="operator">+</span><span class="number">1</span> <span class="keyword">AS</span> rownum, </span><br><span class="line">               table1.<span class="operator">*</span> </span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="variable">@rownum</span>:<span class="operator">=</span><span class="number">0</span>) r ，</span><br><span class="line">       table1;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h3 id="分组排序取样"><a href="#分组排序取样" class="headerlink" title="分组排序取样"></a>分组排序取样</h3><p>按分组取最小的两个(N个)val</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> tb a <span class="keyword">where</span></span><br><span class="line"><span class="number">2</span> <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> tb <span class="keyword">where</span> </span><br><span class="line">name <span class="operator">=</span> a.name  <span class="comment">/*按哪些分组就哪些相等*/</span></span><br><span class="line"><span class="keyword">and</span> val <span class="operator">&lt;</span> a.val ) <span class="comment">/*找个分组内大部分不相等的来做比较*/</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.name,a.val</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> tb a <span class="keyword">where</span> <span class="keyword">exists</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb <span class="keyword">where</span> name <span class="operator">=</span> a.name <span class="keyword">and</span> val <span class="operator">&lt;</span> a.val <span class="keyword">having</span> <span class="built_in">Count</span>(<span class="operator">*</span>) <span class="operator">&lt;</span> <span class="number">2</span>) </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.name</span><br></pre></td></tr></table></figure>
<h3 id="根据注释来查询表名："><a href="#根据注释来查询表名：" class="headerlink" title="根据注释来查询表名："></a>根据注释来查询表名：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> table_name 表名,TABLE_COMMENT <span class="string">&#x27;媒资&#x27;</span> <span class="keyword">from</span></span><br><span class="line">INFORMATION_SCHEMA.TABLES <span class="keyword">Where</span>  TABLE_COMMENT  <span class="keyword">LIKE</span> <span class="string">&#x27;%媒资%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="HAVING子句示例"><a href="#HAVING子句示例" class="headerlink" title="HAVING子句示例"></a>HAVING子句示例</h3><p>1、查询重复的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="keyword">select</span> name <span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> name <span class="keyword">having</span> (<span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)) <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>
<p>查询student表中重名的学生，结果包含id和name，按name,id升序</p>
<p>2、查询分组中特定要求的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sid,<span class="built_in">avg</span>(score) <span class="keyword">as</span> avg_score <span class="keyword">from</span> student_course <span class="keyword">group</span> <span class="keyword">by</span> sid </span><br><span class="line"><span class="keyword">having</span> (avg_score <span class="operator">&lt;</span> <span class="number">60</span>);</span><br></pre></td></tr></table></figure>
<p>在student_course表中查询平均分不及格的学生，列出学生id和平均分</p>
<p>3、显示每个地区的总人口数和总面积．仅显示那些面积超过1000000的地区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> region,<span class="built_in">sum</span>(population),<span class="built_in">sum</span>(area) <span class="keyword">from</span> china <span class="keyword">group</span> <span class="keyword">by</span> region </span><br><span class="line"><span class="keyword">having</span> (<span class="built_in">sum</span>(area) <span class="operator">&gt;</span> <span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="强制索引使用"><a href="#强制索引使用" class="headerlink" title="强制索引使用"></a>强制索引使用</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students FORCE INDEX (idx_class_id) <span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle大批量数据更新操作，提供并发&amp;小事务</title>
    <url>/2021/05/22/sql/oracle%E5%A4%A7%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>oracle提供了很好用的大数据量数据更新的函数dbms_parallel_execute，改用dbms_parallel_execute执行，可以进行并行更新并且事务大小可控。</p>
<p>以下在命令窗口执行：</p>
<ol>
<li>首先创建一个TASK，名称为update_pzjcxx:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_parallel_execute.create_task(<span class="string">&#x27;update_pzjcxx&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>把将要更新的表按照ROWID进行分批，分到各个CHUNK中：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_parallel_execute.create_chunks_by_rowid(task_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;update_pzjcxx&#x27;</span>,table_owner <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;V7PROD&#x27;</span>,table_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;KCDY_PZJCXX&#x27;</span>,by_row <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">true</span>,chunk_size <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
BY_ROW：分CHUNK的类型。如果为TRUE，则后面的CHUNK_SIZE表示是行；如果是FALSE，则后面的CHUNK_SIZE表示的是BLOCK。<br>CHUNK_SIZE：CHUNK大小。如果BY_ROW为TRUE，表示多少行分为一个CHUNK；如果BY_ROW为FALSE，则表示多少块分为一个CHUNK。<span id="more"></span></li>
<li>执行并行任务：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> DBMS_PARALLEL_EXECUTE.run_task(task_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;update_pzjcxx&#x27;</span>,sql_stmt <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;update /*+ROWID(dda)*/ kcdy_pzjcxx set ( ZHHAOXUH, CHAPBHAO, HUOBDAIH, CHAOHUBZ, NLJSKACS ) = </span></span><br><span class="line"><span class="string">( select ZHHAOXUH, CHAPBHAO, HUOBDAIH, CHAOHUBZ, SFYZBZHI from kdpy_jbxinx where zhanghao = kcdy_pzjcxx.zhanghao and farendma = &#x27;&#x27;9999&#x27;&#x27; ) where rowid between :start_id and :end_id&#x27;</span>,language_flag <span class="operator">=</span><span class="operator">&gt;</span> DBMS_SQL.native,parallel_level <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">16</span>);</span><br></pre></td></tr></table></figure>
start_id和end_id是两个占位符，用来标识CHUNK的开始和结束；PARALLEL表示平行度；LANGUAGE_FLAG意义如下：<br>V6 (or 0) specifies version 6 behavior<br>NATIVE (or 1) specifies normal behavior for the database to which the program is connected<br>V7 (or 2) specifies Oracle database version 7 behavior</li>
</ol>
<ol start="4">
<li>查看task执行情况<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_parallel_execute_tasks;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_parallel_execute_tasks;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_parallel_execute_chunks ; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_parallel_execute_chunks ; </span><br></pre></td></tr></table></figure></li>
</ol>
<p> 每个CHUNK是在单独一个事务中提交的。所以某几个CHUNK发生错误后，可以修正错误，并使用下面的方法来继续未完成的CHUNK的任务：<br>  4.1 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_parallel_execute.resume_task(task_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;update_pzjcxx&#x27;</span>,sql_stmt <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;update /*+ROWID(dda)*/ kcdy_pzjcxx set ( ZHHAOXUH, CHAPBHAO, HUOBDAIH, CHAOHUBZ, NLJSKACS ) = </span></span><br><span class="line"><span class="string">( select ZHHAOXUH, CHAPBHAO, HUOBDAIH, CHAOHUBZ, SFYZBZHI from kdpy_jbxinx where zhanghao = kcdy_pzjcxx.zhanghao and farendma = &#x27;&#x27;9999&#x27;&#x27; ) where rowid between :start_id and :end_id&#x27;</span>,language_flag <span class="operator">=</span><span class="operator">&gt;</span> DBMS_SQL.native);</span><br></pre></td></tr></table></figure>
<pre><code>4.2 停止执行： 
</code></pre>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_parallel_execute.stop_task(update_pzjcxx);</span><br></pre></td></tr></table></figure>

<p>  最后可以删除完成的任务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_parallel_execute.drop_task( <span class="string">&#x27;update_pzjcxx&#x27;</span> );</span><br></pre></td></tr></table></figure>



<p>–开启计时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span></span><br></pre></td></tr></table></figure>
<p>–设置并行收集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_stats.set_global_prefs(<span class="string">&#x27;CONCURRENT&#x27;</span>,<span class="string">&#x27;TRUE&#x27;</span>);</span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> resource_manager_plan <span class="operator">=</span> <span class="string">&#x27;DEFAULT_PLAN&#x27;</span> <span class="keyword">scope</span><span class="operator">=</span><span class="keyword">both</span>;</span><br></pre></td></tr></table></figure>
<p>–开始收集全库统计信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">dbms_stats.gather_database_stats(</span><br><span class="line">ESTIMATE_PERCENT<span class="operator">=</span><span class="operator">&gt;</span>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;for all indexed columns&#x27;</span>, cascade<span class="operator">=</span><span class="operator">&gt;</span><span class="literal">true</span>, degree<span class="operator">=</span><span class="operator">&gt;</span><span class="number">16</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure>
<p>–关闭并行收集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_stats.set_global_prefs(<span class="string">&#x27;CONCURRENT&#x27;</span>,<span class="string">&#x27;FALSE&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>–gather——重新分析整个架构（Schema）。<br>–gather empty——只分析目前还没有统计的表。<br>–gather stale——只重新分析修改量超过10%的表（这些修改包括插入、更新和删除）。<br>–gather auto——重新分析当前没有统计的对象，以及统计数据过期（变脏）的对象。注意，使用gather auto类似于组合使用gather stale和gather empty。<br>begin<br>dbms_stats.gather_schema_stats(ownname=&gt;user,options=&gt;’gather stale’,degree =&gt; 32);<br>end;</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>redis使用之缓存问题及解决方案</title>
    <url>/2021/04/01/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指<strong>缓存和数据库中都没有</strong>的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p>举例：<br>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了</p>
<p>解决方案：</p>
<ol>
<li><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</p>
</li>
<li><p>Bloom Filter 布隆过滤器</p>
</li>
</ol>
<p>   ，把缓存中有的key做哈希<strong>存起来</strong>，如果是布隆过滤器里面匹配不到的直接返回。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指<strong>缓存中没有但数据库中有</strong>的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力<br>解决方案：</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，保证只有一个线程去查数据库，其他等待一段时间再查缓存。</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>是指缓存中数据<strong>大批量到过期时间</strong>，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，</p>
<p>解决方案：</p>
<ol>
<li>缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>设置热点数据永远不过期</li>
</ol>
<h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。（setnx和expire可以合成一条指令，防止setnx之后执行expire之前进程意外crash或者要重启维护）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">EX seconds：设置失效时长，单位秒</span><br><span class="line">PX milliseconds：设置失效时长，单位毫秒</span><br><span class="line">NX：key不存在时设置value，成功返回OK，失败返回(nil)</span><br><span class="line">XX：key存在时设置value，成功返回OK，失败返回(nil)</span><br></pre></td></tr></table></figure>

<h3 id="redis设置的锁过期时间到了，但业务并没有执行完成，怎么办？"><a href="#redis设置的锁过期时间到了，但业务并没有执行完成，怎么办？" class="headerlink" title="redis设置的锁过期时间到了，但业务并没有执行完成，怎么办？"></a>redis设置的锁过期时间到了，但业务并没有执行完成，怎么办？</h3><p><code>redisson</code>这个客户端工具，内部有一个监控锁的看门狗，默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒。</p>
<h2 id="双写一致性问题"><a href="#双写一致性问题" class="headerlink" title="双写一致性问题"></a>双写一致性问题</h2><p>两个请求同时修改同一个数据，可能导致脏数据。</p>
<ul>
<li><p>严格要求 “缓存+数据库” 必须保持一致性 ： 读请求和写请求串行化</p>
</li>
<li><p>Cache Aside Pattern(旁路缓存方案)<br><br> 最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。<br><br> 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。<br><br> 更新的时候，先更新数据库，然后再<strong>删除</strong>缓存<br>注：(区别于更新缓存，如果是更新，在1和2两个并发写发生时，由于无法保证时序，此时不管先操作缓存还是先操作数据库，都可能出现：（1）请求1先操作数据库，请求2后操作数据库（2）请求2先set了缓存，请求1后set了缓存导致，数据库与缓存之间的数据不一致。)</p>
</li>
</ul>
<h2 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h2><p>  上面这种方案，是先更新数据库，再删除缓存，但是改了库，清理缓存前，有部分事务还是会拿到旧缓存，这样如果再更新了缓存之后就还是不对的。可以采用延时双删策略。</p>
<p>  在更新数据库前，清理缓存，再执行更新操作，然后第二次清空缓存之前，多延时一会儿，等B更新缓存结束了，再删除缓存，这样就缓存就不存在了，其他事务查询到的为新缓存。</p>
<p>  延时是确保 <strong>修改数据库 -&gt; 清空缓存前，其他事务的更改缓存操作已经执行完。</strong></p>
<p>  采用延时删最后一次缓存，但这其中难免还是会大量的查询到旧缓存数据的。</p>
<p>  这个时候可以采用通过加锁来解决，一次性不让太多的线程都来请求，另外从图上看，我们可以尽量缩短<code>第一次删除缓存</code>和<code>更新数据库</code>的时间差。</p>
<h2 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h2><blockquote>
<p>分析:比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么? <br><br>回答: redis采用的是定期删除+惰性删除 + 淘汰策略。<br></p>
</blockquote>
<h4 id="定期删除-惰性删除-淘汰策略是如何工作的呢"><a href="#定期删除-惰性删除-淘汰策略是如何工作的呢" class="headerlink" title="定期删除+惰性删除 + 淘汰策略是如何工作的呢?"></a>定期删除+惰性删除 + 淘汰策略是如何工作的呢?</h4><blockquote>
<p>纯定时删除,十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。 <br></p>
</blockquote>
<ul>
<li>定期删除：redis默认每个100ms<strong>随机抽取</strong>进行检查是否有过期的key,有过期key则删除。<br><blockquote>
<p>（如果只采用定期删除策略，会导致很多key到时间没有删除。所以加入惰性删除 ）<br></p>
</blockquote>
</li>
<li>惰性删除：也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期，如果过期了此时就会删除。 <br><blockquote>
<p>（如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。）<br>在redis.conf中有一行配置该配置就是配内存淘汰策略的 ）<br></p>
</blockquote>
</li>
<li>淘汰策略：<ol>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。 </li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。 </li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐 </li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐 </li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐 ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>nosql</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存击穿/雪崩/穿透</tag>
        <tag>淘汰策略</tag>
      </tags>
  </entry>
</search>
